import{_ as a,c as s,o as e,N as n}from"./chunks/framework.255dec5c.js";const h=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"blogs/tween.js 中文使用指南.md"}'),l={name:"blogs/tween.js 中文使用指南.md"},p=n(`<blockquote><p><a href="https://github.com/tweenjs/tween.js/blob/master/docs/user_guide.md" target="_blank" rel="noreferrer">tween.js 英文使用指南</a> 首先来看个例子: <a href="https://codepen.io/zhaoqize/pen/xpXKwN" target="_blank" rel="noreferrer">hello,tween.js</a></p></blockquote><p>补间(动画)（来自 <a href="https://en.wikipedia.org/wiki/Inbetweening" target="_blank" rel="noreferrer">in-between</a>）是一个概念，允许你以平滑的方式更改对象的属性。你只需告诉它哪些属性要更改，当补间结束运行时它们应该具有哪些最终值，以及这需要多长时间，补间引擎将负责计算从起始点到结束点的值。</p><p>例如，position对象拥有x和y两个坐标:</p><div class="language-auto"><button title="Copy Code" class="copy"></button><span class="lang">auto</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">var position = { x: 100, y: 0 }</span></span></code></pre></div><p>如果你想将x坐标的值从100变成200，你应该这么做：</p><div class="language-auto"><button title="Copy Code" class="copy"></button><span class="lang">auto</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">// 首先为位置创建一个补间(tween)</span></span>
<span class="line"><span style="color:#A6ACCD;">var tween = new TWEEN.Tween(position);</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// 然后告诉 tween 我们想要在1000毫秒内以动画的形式移动 x 的位置</span></span>
<span class="line"><span style="color:#A6ACCD;">tween.to({ x: 200 }, 1000);</span></span></code></pre></div><p>一般来说这样还不够，tween 已经被创建了，但是它还没被激活(使用)，你需要这样启动：</p><div class="language-sql"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">//</span><span style="color:#A6ACCD;"> 启动</span></span>
<span class="line"><span style="color:#A6ACCD;">tween.start</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;">;</span><span style="color:#F78C6C;">12</span></span></code></pre></div><p>最后，想要成功的完成这种效果，你需要在主函数中调用TWEEN.update，如下使用：</p><div class="language-r"><button title="Copy Code" class="copy"></button><span class="lang">r</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">animate</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">function animate</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    requestAnimationFrame</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">animate</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">//</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[</span><span style="color:#F78C6C;">...</span><span style="color:#89DDFF;">]</span></span>
<span class="line"><span style="color:#A6ACCD;">    TWEEN.update</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">//</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[</span><span style="color:#F78C6C;">...</span><span style="color:#89DDFF;">]</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>这样在更新每帧的时候都会运行补间动画；经过 1秒后 (1000 毫秒) position.x将会变成 200。</p><p>除非你在控制台中打印出 x 的值，不然你看不到它的变化。你可能想要使用 onUpdate 回调:</p><div class="language-auto"><button title="Copy Code" class="copy"></button><span class="lang">auto</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">tween.onUpdate(function(object) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    console.log(object.x);</span></span>
<span class="line"><span style="color:#A6ACCD;">});</span></span></code></pre></div><blockquote><p>tips:你可能在这里获取不到 object.x ,具体的见我提的这个 <a href="https://github.com/tweenjs/tween.js/issues/402" target="_blank" rel="noreferrer">issue</a></p></blockquote><p>这个函数将会在动画每次更新的时候被调用；这种情况发生的频率取决于很多因素 - 例如，计算机或设备的速度有多快（以及如何繁忙）。</p><p>到目前为止，我们只使用补间动画向控制台输出值，但是您可以将它与 three.js 对象结合：</p><div class="language-auto"><button title="Copy Code" class="copy"></button><span class="lang">auto</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">var tween = new TWEEN.Tween(cube.position)</span></span>
<span class="line"><span style="color:#A6ACCD;">        .to({ x: 100, y: 100, z: 100 }, 10000)</span></span>
<span class="line"><span style="color:#A6ACCD;">        .start();</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">animate();</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">function animate() {</span></span>
<span class="line"><span style="color:#A6ACCD;">    requestAnimationFrame(animate);</span></span>
<span class="line"><span style="color:#A6ACCD;">    TWEEN.update();</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">    threeRenderer.render(scene, camera);</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span></code></pre></div><p>在这种情况下，因为three.js渲染器将在渲染之前查看对象的位置，所以不需要使用明确的onUpdate回调。</p><p>你可能也注意到了一些不同的地方：tween.js 可以链式调用！ 每个tween函数都会返回tween实例，所以你可以重写下面的代码：</p><div class="language-auto"><button title="Copy Code" class="copy"></button><span class="lang">auto</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">var tween = new TWEEN.Tween(position);</span></span>
<span class="line"><span style="color:#A6ACCD;">tween.to({ x: 200 }, 1000);</span></span>
<span class="line"><span style="color:#A6ACCD;">tween.start();</span></span></code></pre></div><p>改成这样：</p><div class="language-auto"><button title="Copy Code" class="copy"></button><span class="lang">auto</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">var tween = new TWEEN.Tween(position)</span></span>
<span class="line"><span style="color:#A6ACCD;">    .to({ x: 200 }, 1000)</span></span>
<span class="line"><span style="color:#A6ACCD;">    .start();</span></span></code></pre></div><p>在将会看到很多例子，所以熟悉它是很好的！比如 04-simplest 这个例子。</p><h2 id="tween-js的动画" tabindex="-1">tween.js的动画 <a class="header-anchor" href="#tween-js的动画" aria-label="Permalink to &quot;tween.js的动画&quot;">​</a></h2><p>Tween.js 不会自行运行。你需要显式的调用 update 方法来告诉它何时运行。推荐的方法是在主动画循环中执行这个操作。使用 requestAnimationFrame 调用此循环以获得最佳的图形性能。</p><p>比如之前这个例子：</p><div class="language-r"><button title="Copy Code" class="copy"></button><span class="lang">r</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">animate</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">function animate</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    requestAnimationFrame</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">animate</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">//</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[</span><span style="color:#F78C6C;">...</span><span style="color:#89DDFF;">]</span></span>
<span class="line"><span style="color:#A6ACCD;">    TWEEN.update</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">//</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[</span><span style="color:#F78C6C;">...</span><span style="color:#89DDFF;">]</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>如果调用的时候不传入参数，update 将会判断当前时间点以确定自上次运行以来已经有多久。</p><p>当然你也可以传递一个明确的时间参数给 update</p><div class="language-sql"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">TWEEN.update(</span><span style="color:#F78C6C;">100</span><span style="color:#A6ACCD;">);</span></span></code></pre></div><p>意思是”更新时间 = 100 毫秒”。你可以使用它来确保代码中的所有时间相关函数都使用相同的时间值。例如，假设你有一个播放器，并希望同步运行补间。 你的 animate 函数可能看起来像这样：</p><div class="language-auto"><button title="Copy Code" class="copy"></button><span class="lang">auto</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">var currentTime = player.currentTime;</span></span>
<span class="line"><span style="color:#A6ACCD;">TWEEN.update(currentTime);</span></span></code></pre></div><p>我们使用明确的时间值进行单元测试。你可以看下 tests.js 这个例子，看看我们如何用不同的值调用TWEEN.update() 来模拟时间传递。</p><h2 id="控制一个补间" tabindex="-1">控制一个补间 <a class="header-anchor" href="#控制一个补间" aria-label="Permalink to &quot;控制一个补间&quot;">​</a></h2><h3 id="start-和-stop" tabindex="-1">start 和 stop <a class="header-anchor" href="#start-和-stop" aria-label="Permalink to &quot;start 和 stop&quot;">​</a></h3><p>到目前为止，我们已经了解了Tween.start方法，但是还有更多的方法来控制单个补间。 也许最重要的一个是 star 对应的方法：停止 。 如果你想取消一个补间，只要调用这个方法通过一个单独的补间:</p><div class="language-auto"><button title="Copy Code" class="copy"></button><span class="lang">auto</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">tween.stop();</span></span></code></pre></div><p>停止一个从未开始或已经停止的补间没有任何效果。 没有错误被抛出。</p><p>start 方法接受一个参数 time。如果你使用它，那么补间不会立即开始，直到特定时刻，否则会尽快启动（i.e 即在下次调用 TWEEN.update）。</p><h3 id="update" tabindex="-1">update <a class="header-anchor" href="#update" aria-label="Permalink to &quot;update&quot;">​</a></h3><p>补间也有一个更新的方法—这实际上是由 TWEEN.update 调用的。 你通常不需要直接调用它，除非你是个 疯狂的hacker。</p><h3 id="chain" tabindex="-1">chain <a class="header-anchor" href="#chain" aria-label="Permalink to &quot;chain&quot;">​</a></h3><p>当你顺序排列不同的补间时，事情会变得有趣，例如在上一个补间结束的时候立即启动另外一个补间。我们称这为链式补间，这使用 chain 方法去做。因此，为了使 tweenB 在 tewwnA 启动：</p><div class="language-auto"><button title="Copy Code" class="copy"></button><span class="lang">auto</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">tweenA.chain(tweenB);</span></span></code></pre></div><p>或者，对于一个无限的链式，设置tweenA一旦tweenB完成就开始：</p><div class="language-auto"><button title="Copy Code" class="copy"></button><span class="lang">auto</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">tweenA.chain(tweenB);</span></span>
<span class="line"><span style="color:#A6ACCD;">tweenB.chain(tweenA);</span></span></code></pre></div><p>关于无限的链式查看 <a href="https://github.com/tweenjs/tween.js/blob/master/examples/00_hello_world.html" target="_blank" rel="noreferrer">Hello world</a> 。</p><p>在其他情况下，您可能需要将多个补间链接到另一个补间，以使它们（链接的补间）同时开始动画：</p><div class="language-auto"><button title="Copy Code" class="copy"></button><span class="lang">auto</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">tweenA.chain(tweenB,tweenC);</span></span></code></pre></div><blockquote><p>警告：调用 tweenA.chain（tweenB） 实际上修改了tweenA，所以tweenA总是在tweenA完成时启动。 chain 的返回值只是tweenA，不是一个新的tween。</p></blockquote><h3 id="repeat" tabindex="-1">repeat <a class="header-anchor" href="#repeat" aria-label="Permalink to &quot;repeat&quot;">​</a></h3><p>如果你想让一个补间永远重复，你可以链接到自己，但更好的方法是使用 repeat 方法。 它接受一个参数，描述第一个补间完成后需要多少次重复</p><div class="language-auto"><button title="Copy Code" class="copy"></button><span class="lang">auto</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">tween.repeat(10); // 循环10次</span></span>
<span class="line"><span style="color:#A6ACCD;">tween.repeat(Infinity); // 无限循环</span></span></code></pre></div><p>补间的总次数将是重复参数加上一个初始补间。查看 <a href="https://github.com/tweenjs/tween.js/blob/master/examples/08_repeat.html" target="_blank" rel="noreferrer">Repeat</a>。</p><h3 id="yoyo" tabindex="-1">yoyo <a class="header-anchor" href="#yoyo" aria-label="Permalink to &quot;yoyo&quot;">​</a></h3><p>这个功能只有在独自使用 repeat 时才有效果。 活跃时，补间的行为将像 yoyo 一样，i.e 它会从起始值和结束值之间跳出，而不是从头开始重复相同的顺序。</p><h3 id="delay" tabindex="-1">delay <a class="header-anchor" href="#delay" aria-label="Permalink to &quot;delay&quot;">​</a></h3><p>更复杂的安排可能需要在实际开始运行之前延迟补间。 你可以使用 delay 方法来做到这一点</p><div class="language-sql"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">tween.delay(</span><span style="color:#F78C6C;">1000</span><span style="color:#A6ACCD;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">tween.start</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;">;</span></span></code></pre></div><p>将在调用启动方法后的1秒钟后开始执行。</p><h2 id="控制所有补间" tabindex="-1">控制所有补间 <a class="header-anchor" href="#控制所有补间" aria-label="Permalink to &quot;控制所有补间&quot;">​</a></h2><p>在 TWEEN 全局对象中可以找到以下方法，除了 update 之外，通常不需要使用其中的大部分对象。</p><h3 id="tween-update-time" tabindex="-1">TWEEN.update(time) <a class="header-anchor" href="#tween-update-time" aria-label="Permalink to &quot;TWEEN.update(time)&quot;">​</a></h3><p>我们已经讨论过这种方法。 它用于更新所有活动的补间。 如果 time 不指定，它将使用当前时间。</p><h3 id="tween-getall-and-tween-removeall" tabindex="-1">TWEEN.getAll and TWEEN.removeAll <a class="header-anchor" href="#tween-getall-and-tween-removeall" aria-label="Permalink to &quot;TWEEN.getAll and TWEEN.removeAll&quot;">​</a></h3><p>用于获取对活动 tweens <a href="https://so.csdn.net/so/search?q=%E6%95%B0%E7%BB%84&amp;spm=1001.2101.3001.7020" target="_blank" rel="noreferrer">数组</a>的引用，并分别仅从一个调用中将它们全部从数组中删除</p><h3 id="tween-add-tween-and-tween-remove-tween" tabindex="-1">TWEEN.add(tween) and TWEEN.remove(tween) <a class="header-anchor" href="#tween-add-tween-and-tween-remove-tween" aria-label="Permalink to &quot;TWEEN.add(tween) and TWEEN.remove(tween)&quot;">​</a></h3><p>用于将补间添加到活动补间的列表，或者分别从列表中删除特定的补间。</p><p>这些方法通常只在内部使用，但是如果您想要做一些有趣的事情，则会被暴露。</p><h2 id="控制补间组" tabindex="-1">控制补间组 <a class="header-anchor" href="#控制补间组" aria-label="Permalink to &quot;控制补间组&quot;">​</a></h2><p>使用 TWEEN 单例来管理补间可能会导致包含许多组件的大型应用程序出现问题。 在这些情况下，您可能希望创建自己的更小的补间组。</p><h3 id="示例-交叉组件冲突" tabindex="-1">示例：交叉组件冲突 <a class="header-anchor" href="#示例-交叉组件冲突" aria-label="Permalink to &quot;示例：交叉组件冲突&quot;">​</a></h3><p>如果使用 TWEEN 有多个组件，并且每个组件都想管理自己的一组补间，则可能发生冲突。 如果一个组件调用 TWEEN.update（） 或 TWEEN.removeAll（），则其他组件的补间也将被更新或删除。</p><h3 id="创建你自己的补间组" tabindex="-1">创建你自己的补间组 <a class="header-anchor" href="#创建你自己的补间组" aria-label="Permalink to &quot;创建你自己的补间组&quot;">​</a></h3><p>为了解决这个问题，每个组件都可以创建自己的 TWEEN.Group 实例（这是全局的 TWEEN 对象在内部使用的）。 实例化新的补间时，可以将这些组作为第二个可选参数传入：var groupA = new TWEEN.Group();</p><div class="language-auto"><button title="Copy Code" class="copy"></button><span class="lang">auto</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">var groupB = new TWEEN.Group();</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">var tweenA = new TWEEN.Tween({ x: 1 }, groupA)</span></span>
<span class="line"><span style="color:#A6ACCD;">    .to({ x: 10 }, 100)</span></span>
<span class="line"><span style="color:#A6ACCD;">    .start();</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">var tweenB = new TWEEN.Tween({ x: 1 }, groupB)</span></span>
<span class="line"><span style="color:#A6ACCD;">    .to({ x: 10 }, 100)</span></span>
<span class="line"><span style="color:#A6ACCD;">    .start();</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">var tweenC = new TWEEN.Tween({ x: 1 })</span></span>
<span class="line"><span style="color:#A6ACCD;">    .to({ x: 10 }, 100)</span></span>
<span class="line"><span style="color:#A6ACCD;">    .start();</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">groupA.update(); // 只更新tweenA</span></span>
<span class="line"><span style="color:#A6ACCD;">groupB.update(); // 只更新tweenB</span></span>
<span class="line"><span style="color:#A6ACCD;">TWEEN.update(); // 只更新tweenC</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">groupA.removeAll(); // 只移除tweenA</span></span>
<span class="line"><span style="color:#A6ACCD;">groupB.removeAll(); // 只移除tweenB</span></span>
<span class="line"><span style="color:#A6ACCD;">TWEEN.removeAll(); // 只移除tweenC</span></span></code></pre></div><p>通过这种方式，每个组件都可以处理创建，更新和销毁自己的一组补间。</p><h2 id="改变缓动功能" tabindex="-1">改变缓动功能 <a class="header-anchor" href="#改变缓动功能" aria-label="Permalink to &quot;改变缓动功能&quot;">​</a></h2><p>Tween.js 将以线性方式执行值之间的插值（即缓动），所以变化将与流逝的时间成正比。 这是可以预见的，但在视觉上也是相当无趣的。 不要担心 - 使用缓动方法可以轻松更改此行为。 例如：</p><div class="language-auto"><button title="Copy Code" class="copy"></button><span class="lang">auto</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">tween.easing(TWEEN.Easing.Quadratic.In);</span></span></code></pre></div><p>这将导致缓慢地开始向最终值变化，向中间加速，然后迅速达到其最终值，相反，TWEEN.Easing.Quadratic.Out 一开始会加速，但随着值的接近最终放缓。</p><h3 id="可用的缓动函数-tween-easing" tabindex="-1">可用的缓动函数：TWEEN.Easing <a class="header-anchor" href="#可用的缓动函数-tween-easing" aria-label="Permalink to &quot;可用的缓动函数：TWEEN.Easing&quot;">​</a></h3><p>tween.js提供了一些现有的缓动功能。它们按照它们表示的方程式进行分组：线性，二次，三次，四次，五次，正弦，指数，圆形，弹性，背部和弹跳，然后是缓动型：In，Out和InOut。</p><p>除非您已经熟悉这些概念，否则这些名称可能不会对您说什么，所以您可能需要查看 Graphs 示例，该示例将一个页面中的所有曲线进行图形化，以便比较它们如何看待一瞥。</p><p>这些功能是从 Robert Penner 慷慨地提供几年前作为自由软件提供的原始方程派生而来的，但是已经被优化以便与JavaScript很好地发挥作用。</p><h3 id="使用自定义缓动功能" tabindex="-1">使用自定义缓动功能 <a class="header-anchor" href="#使用自定义缓动功能" aria-label="Permalink to &quot;使用自定义缓动功能&quot;">​</a></h3><p>您不仅可以使用任何现有的功能，还可以提供您自己的功能，只要遵循一些约定即可：</p><ul><li>它必须接受一个参数： k: 缓动过程，或我们的补间所处的时间有多长。允许的值在[0，1]的范围内。</li><li>它必须根据输入参数返回一个值。</li></ul><p>不管要修改多少个属性，easing函数在每次更新时只调用一次。 然后将结果与初始值以及这个值和最终值之间的差值（delta）一起使用，就像这个伪代码一样：</p><div class="language-auto"><button title="Copy Code" class="copy"></button><span class="lang">auto</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">easedElapsed = easing(k);</span></span>
<span class="line"><span style="color:#A6ACCD;">for each property:</span></span>
<span class="line"><span style="color:#A6ACCD;">    newPropertyValue = initialPropertyValue + propertyDelta * easedElapsed;</span></span></code></pre></div><p>对于更注重性能表现的人来说：只有在补间上调用 start() 时才会计算增量值。</p><p>因此，让我们假设您想使用一个缓解值的自定义缓动函数，但是将 Math.floor 应用于输出，所以只返回整数部分，从而产生一种梯级输出:</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">tenStepEasing</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">k</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">Math</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">floor</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">k</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">*</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">10</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">/</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">10</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>你可以通过简单地调用它的缓动方法来使用它，就像我们之前看到的那样：</p><div class="language-auto"><button title="Copy Code" class="copy"></button><span class="lang">auto</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">tween.easing(tenStepEasing);1</span></span></code></pre></div><p>查看 <a href="https://github.com/tweenjs/tween.js/blob/master/examples/12_graphs_custom_functions.html" target="_blank" rel="noreferrer">graphs for custom easing functions</a> 示例，以查看这个动作（还有一些用于生成步进函数的元编程）。</p><h2 id="回调函数" tabindex="-1">回调函数 <a class="header-anchor" href="#回调函数" aria-label="Permalink to &quot;回调函数&quot;">​</a></h2><p>另一个强大的特性是能够在每个补间的生命周期的特定时间运行自己的功能。 当更改属性不够时，通常需要这样做。</p><p>例如，假设你正在试图给一些不能直接访问属性的对象设置动画，但是需要你调用setter。 您可以使用 update 回调来读取新的更新值，然后手动调用setters。 所有的回调函数都将补间对象作为唯一的参数。</p><div class="language-auto"><button title="Copy Code" class="copy"></button><span class="lang">auto</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">var trickyObjTween = new TWEEN.Tween({</span></span>
<span class="line"><span style="color:#A6ACCD;">    propertyA: trickyObj.getPropertyA(),</span></span>
<span class="line"><span style="color:#A6ACCD;">    propertyB: trickyObj.getPropertyB()</span></span>
<span class="line"><span style="color:#A6ACCD;">})</span></span>
<span class="line"><span style="color:#A6ACCD;">    .to({ propertyA: 100, propertyB: 200 })</span></span>
<span class="line"><span style="color:#A6ACCD;">    .onUpdate(function(object) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        object.setA( object.propertyA );</span></span>
<span class="line"><span style="color:#A6ACCD;">        object.setB( object.propertyB );</span></span>
<span class="line"><span style="color:#A6ACCD;">    });</span></span></code></pre></div><p>或者想象一下，当一个补间开始时，你想播放声音。你可以使用 start 回调：</p><div class="language-auto"><button title="Copy Code" class="copy"></button><span class="lang">auto</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">var tween = new TWEEN.Tween(obj)</span></span>
<span class="line"><span style="color:#A6ACCD;">    .to({ x: 100 })</span></span>
<span class="line"><span style="color:#A6ACCD;">    .onStart(function() {</span></span>
<span class="line"><span style="color:#A6ACCD;">        sound.play();</span></span>
<span class="line"><span style="color:#A6ACCD;">    });</span></span></code></pre></div><p>每个回调的范围是补间对象–在这种情况下，是 obj。</p><h3 id="onstart" tabindex="-1">onStart <a class="header-anchor" href="#onstart" aria-label="Permalink to &quot;onStart&quot;">​</a></h3><p>在补间开始之前执行–i.e. 在计算之前。每个补间只能执行一次，i.e. 当通过 repeat() 重复补间时，它将不会运行。</p><p>同步到其他事件或触发您要在补间启动时发生的操作是非常好的。</p><p>补间对象作为第一个参数传入。</p><h3 id="onstop" tabindex="-1">onStop <a class="header-anchor" href="#onstop" aria-label="Permalink to &quot;onStop&quot;">​</a></h3><p>当通过 stop() 显式停止补间时执行，但在正常完成时并且在停止任何可能的链补间之前执行补间。</p><p>补间对象作为第一个参数传入。</p><h3 id="onupdate" tabindex="-1">onUpdate <a class="header-anchor" href="#onupdate" aria-label="Permalink to &quot;onUpdate&quot;">​</a></h3><p>每次补间更新时执行，实际更新后的值。</p><p>补间对象作为第一个参数传入。</p><h3 id="oncomplete" tabindex="-1">onComplete <a class="header-anchor" href="#oncomplete" aria-label="Permalink to &quot;onComplete&quot;">​</a></h3><p>当补间正常完成（即不停止）时执行。</p><p>补间对象作为第一个参数传入。</p><h2 id="高级补间" tabindex="-1">高级补间 <a class="header-anchor" href="#高级补间" aria-label="Permalink to &quot;高级补间&quot;">​</a></h2><h3 id="相对值" tabindex="-1">相对值 <a class="header-anchor" href="#相对值" aria-label="Permalink to &quot;相对值&quot;">​</a></h3><p>使用 to 方法时，也可以使用相对值。 当tween启动时，Tween.js将读取当前属性值并应用相对值来找出新的最终值。 但是你需要使用引号，否则这些值将被视为绝对的。 我们来看一个例子:</p><div class="language-auto"><button title="Copy Code" class="copy"></button><span class="lang">auto</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">// This will make the \`x\` property be 100, always</span></span>
<span class="line"><span style="color:#A6ACCD;">var absoluteTween = new TWEEN.Tween(absoluteObj).to({ x: 100 });</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// Suppose absoluteObj.x is 0 now</span></span>
<span class="line"><span style="color:#A6ACCD;">absoluteTween.start(); // Makes x go to 100</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// Suppose absoluteObj.x is -100 now</span></span>
<span class="line"><span style="color:#A6ACCD;">absoluteTween.start(); // Makes x go to 100</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// In contrast...</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// This will make the \`x\` property be 100 units more,</span></span>
<span class="line"><span style="color:#A6ACCD;">// relative to the actual value when it starts</span></span>
<span class="line"><span style="color:#A6ACCD;">var relativeTween = new TWEEN.Tween(relativeObj).to({ x: &quot;+100&quot; });</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// Suppose relativeObj.x is 0 now</span></span>
<span class="line"><span style="color:#A6ACCD;">relativeTween.start(); // Makes x go to 0 +100 = 100</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// Suppose relativeObj.x is -100 now</span></span>
<span class="line"><span style="color:#A6ACCD;">relativeTween.start(); // Makes x go to -100 +100 = 0</span></span></code></pre></div><p>查看 <a href="https://github.com/tweenjs/tween.js/blob/master/examples/09_relative_values.html" target="_blank" rel="noreferrer">09_relative_values</a> 示例。</p><h3 id="补间值的数组" tabindex="-1">补间值的数组 <a class="header-anchor" href="#补间值的数组" aria-label="Permalink to &quot;补间值的数组&quot;">​</a></h3><p>除了补间为绝对值或相对值之外，还可以让Tween.js跨一系列值更改属性。 要做到这一点，你只需要指定一个数组的值，而不是一个属性的单个值。 例如：</p><div class="language-auto"><button title="Copy Code" class="copy"></button><span class="lang">auto</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">var tween = new TWEEN.Tween(relativeObj).to({ x: [0, -100, 100] });</span></span></code></pre></div><p>将使 x 从初始值变为0，-100和100。</p><p>这些值的计算方法如下：</p><ul><li>首先，补间进度如常计算</li><li>进度（从0到1）用作插值函数的输入</li><li>基于进度和值的数组，生成内插值</li></ul><p>例如，当补间刚刚启动（进度为0）时，插值函数将返回数组中的第一个值。 当补间到一半时，插值函数将返回一个大约在数组中间的值，当补间结束时，插值函数将返回最后一个值。</p><p>您可以使用插值方法更改插值函数。 例如：</p><div class="language-auto"><button title="Copy Code" class="copy"></button><span class="lang">auto</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">tween.interpolation( TWEEN.Interpolation.Bezier );</span></span></code></pre></div><p>以下值可用：</p><ul><li>TWEEN.Interpolation.Linear</li><li>TWEEN.Interpolation.Bezier</li><li>TWEEN.Interpolation.CatmullRom</li></ul><p>默认是 Linear。</p><p>请注意，插值函数对于与同一补间中的数组进行补间的所有属性是全局的。 您不能使用数组和线性函数进行属性A的更改，也不能使用相同的补间进行数组B的属性B和Bezier函数的更改; 您应该使用运行在同一对象上的两个补间对象，但修改不同的属性并使用不同的插值函数。</p><p>查看 <a href="https://github.com/tweenjs/tween.js/blob/master/examples/06_array_interpolation.html" target="_blank" rel="noreferrer">06_array_interpolation</a> 示例。</p><h2 id="获得最佳性能" tabindex="-1">获得最佳性能 <a class="header-anchor" href="#获得最佳性能" aria-label="Permalink to &quot;获得最佳性能&quot;">​</a></h2><p>虽然Tween.js试图自己执行，但是没有什么能够阻止你以一种反作用的方式使用它。 这里有一些方法可以避免在使用Tween.js时（或者在网页中进行动画制作时）减慢项目速度。</p><h3 id="使用高性能的css" tabindex="-1">使用高性能的CSS <a class="header-anchor" href="#使用高性能的css" aria-label="Permalink to &quot;使用高性能的CSS&quot;">​</a></h3><p>当您尝试在页面中设置元素的位置时，最简单的解决方案是为 top 和 left 属性设置动画，如下所示：</p><div class="language-auto"><button title="Copy Code" class="copy"></button><span class="lang">auto</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">var element = document.getElementById(&#39;myElement&#39;);</span></span>
<span class="line"><span style="color:#A6ACCD;">var tween = new TWEEN.Tween({ top: 0, left: 0 })</span></span>
<span class="line"><span style="color:#A6ACCD;">    .to({ top: 100, left: 100 }, 1000)</span></span>
<span class="line"><span style="color:#A6ACCD;">    .onUpdate(function(object) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        element.style.top = object.top + &#39;px&#39;;</span></span>
<span class="line"><span style="color:#A6ACCD;">        element.style.left = object.left + &#39;px&#39;;</span></span>
<span class="line"><span style="color:#A6ACCD;">    });</span></span></code></pre></div><p>但这实际上是效率低下的，因为改变这些属性会迫使浏览器在每次更新时重新计算布局，这是非常昂贵的操作。 相反的，您应该使用 transform，这不会使布局无效，并且在可能的情况下也将被硬件加速，比如：</p><div class="language-auto"><button title="Copy Code" class="copy"></button><span class="lang">auto</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">var element = document.getElementById(&#39;myElement&#39;);</span></span>
<span class="line"><span style="color:#A6ACCD;">var tween = new TWEEN.Tween({ top: 0, left: 0 })</span></span>
<span class="line"><span style="color:#A6ACCD;">    .to({ top: 100, left: 100 }, 1000)</span></span>
<span class="line"><span style="color:#A6ACCD;">    .onUpdate(function(object) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        element.style.transform = &#39;translate(&#39; + object.left + &#39;px, &#39; + object.top + &#39;px);&#39;;</span></span>
<span class="line"><span style="color:#A6ACCD;">    });</span></span></code></pre></div><p>如果你想了解更多关于这个，看看<a href="https://www.paulirish.com/2012/why-moving-elements-with-translate-is-better-than-posabs-topleft/" target="_blank" rel="noreferrer">这篇文章</a>。</p><p>但是，如果您的动画需求非常简单，那么在适用的情况下使用CSS动画或转换可能会更好，以便浏览器尽可能优化。 当您的动画需要涉及复杂的布局时，Tween.js是非常有用的，也就是说，您需要将多个补间同步到一起，在完成一些动作之后，循环多次等等。</p><h3 id="对垃圾收集器-别名gc" tabindex="-1">对垃圾收集器（别名GC） <a class="header-anchor" href="#对垃圾收集器-别名gc" aria-label="Permalink to &quot;对垃圾收集器（别名GC）&quot;">​</a></h3><p>如果你使用onUpdate回调函数，你需要非常小心的使用它。 因为这个函数每秒钟会被调用很多次，所以如果每次更新都要花费很多的代价，那么你可能会阻塞主线程并导致可怕的结果，或者如果你的操作涉及到内存分配的话， 垃圾收集器运行太频繁，也导致结果。 所以只是不要做些事情中的其中一个。 保持你的onUpdate回调非常轻量级，并确保在开发时也使用内存分析器。</p><h3 id="疯狂的补间" tabindex="-1">疯狂的补间 <a class="header-anchor" href="#疯狂的补间" aria-label="Permalink to &quot;疯狂的补间&quot;">​</a></h3><p>这是你可能不经常使用的东西，但是你可以在Tween.js之外使用补间公式。 毕竟，它们只是功能。 所以你可以使用它们来计算平滑曲线作为输入数据。 例如，他们用于在 <a href="http://5013.es/toys/tween.audio/" target="_blank" rel="noreferrer">这个实验</a> 中生成音频数据。</p><p><a href="http://www.jqhtml.com" target="_blank" rel="noreferrer">前端库</a></p>`,149),t=[p];function o(r,c,i,C,A,d){return e(),s("div",null,t)}const u=a(l,[["render",o]]);export{h as __pageData,u as default};
