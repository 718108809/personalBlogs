[TOC]


# Vue

## vue

### 什么是Vue

<font color=e32d40>**是什么 :** </font>用于构建用户页面的<font color=997722>**渐进式开源javascript框架** </font>也是一个创建<font color=997722>**SPA单页应用的**</font>Web应用框架，Vue所关注的核心是MVC模式中的视图层，同时，它也能方便地获取数据更新，并通过组件内部特定的方法实现视图与模型的交互

渐进式代表的含义是：主张最少, 自底向上, 增量开发, 组件集合, 便于复用

<font color=e32d40>**特性 : **</font>数据驱动(MVVM)，组件化开发，特殊的指令系统 

1. **数据驱动** : MVVM`表示的是 `Model-View-ViewModel
   - Model：模型层，负责处理业务逻辑以及和服务器端进行交互
   - View：视图层：负责将数据模型转化为UI展示出来，可以简单的理解为HTML页面
   - ViewModel：视图模型层，用来连接Model和View，是Model和View之间的通信桥梁
2. **组件开发** : 把图形、非图形的各种逻辑均抽象为一个统一的概念（组件）来实现开发的模式
   * 降低整个系统的耦合度，在保持接口不变的情况下，我们可以替换不同的组件快速完成需求
   * 调试方便，由于整个系统是通过组件组合起来的，在出现问题的时候，可以用排除法直接移除组件，或者根据报错的组件快速定位问题，之所以能够快速定位，是因为每个组件之间低耦合，职责单一，所以逻辑会比分析整个系统要简单
   * 提高可维护性，由于每个组件的职责单一，并且组件在系统中是被复用的，所以对代码进行优化可获得系统的整体升级
3. **指令系统** : 指令 (Directives) 是带有 v- 前缀的特殊属性作用：当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM
   * 条件渲染指令 `v-if`
   * 列表渲染指令`v-for`
   * 属性绑定指令`v-bind`
   * 事件绑定指令`v-on`
   * 双向数据绑定指令`v-model`



### vue常用的修饰符

**v-on** 

- `.stop` - 调用 `event.stopPropagation()`。 阻止默认事件
- `.prevent` - 调用 `event.preventDefault()`。阻止默认行为
- `.native` - 监听组件根元素的原生事件。

**v-bind**

- `.prop` - 作为一个 DOM property 绑定而不是作为 attribute 绑定。([差别在哪里？](https://stackoverflow.com/questions/6003819/properties-and-attributes-in-html#answer-6004028))
- `.camel` - (2.1.0+) 将 kebab-case attribute 名转换为 camelCase。(从 2.1.0 开始支持)
- `.sync` (2.3.0+) 语法糖，会扩展成一个更新父组件绑定值的 `v-on` 侦听器。

**v-model**

- [`.lazy`](https://cn.vuejs.org/v2/guide/forms.html#lazy) - 取代 `input` 监听 `change` 事件
- [`.number`](https://cn.vuejs.org/v2/guide/forms.html#number) - 输入字符串转为有效的数字
- [`.trim`](https://cn.vuejs.org/v2/guide/forms.html#trim) - 输入首尾空格过滤

### 内置组件

<font color=cc3355>**component**</font>

渲染一个“元组件”为动态组件。依 is 的值，来决定哪个组件被渲染

在一个多标签的界面中使用 is attribute 来切换不同的组件：tap栏切换

<font color=cc3355>**transition**</font>

用于在 Vue 插入、更新或者移除 DOM 时， 提供多种不同方式的应用过渡、动画效果。

<font color=cc3355>**transition-group**</font>

`<transition-group>` 用于给列表统一设置过渡动画。

<font color=cc3355>**keep-alive**</font>

- 主要用于保留组件状态或避免组件重新渲染。
- include 属性用于指定哪些组件会被缓存，具有多种设置方式。
- exclude 属性用于指定哪些组件不会被缓存。
- max 属性用于设置最大缓存个数。

<font color=cc3355>**slot**</font>

* **name** - string，用于命名插槽。

* < slot> 元素作为组件模板之中的内容分发插槽。< slot> 元素自身将被替换。

### SPA单页面应用

SPA（single-page application），翻译过来就是单页应用`SPA`是一种网络应用程序或网站的模型

它通过动态重写当前页面来与用户交互，这种方法避免了页面之间切换打断用户体验在单页应用中，所有必要的代码（`HTML`、`JavaScript`和`CSS`）都通过单个页面的加载而检索，

或者根据需要（通常是为响应用户操作）动态装载适当的资源并添加到页面页面在任何时间点都不会重新加载，也不会将控制转移到其他页面

举个例子来讲就是你去公司上班老婆给你送饭，饭盒早上装的包子 豆浆 油条。饭盒中午装的米饭 面条 大鸡腿，饭盒晚上装的蔬菜沙拉 烤地瓜。我们发现变的始终是早中晚饭和饭盒里菜的样式，而饭盒始终是那个饭盒

我们熟知的JS框架如`react`,`vue`,`angular`都属于`SPA`

**单页应用优缺点**

1. 优点：
   * 具有桌面应用的即时性、网站的可移植性和可访问性
   * 用户体验好、快，内容的改变不需要重新加载整个页面

2. 缺点：
   * 首次渲染速度相对较慢
   * 不利于搜索引擎的抓取

**解决首次加载慢的问题**

	1. 减少入口文件体积
	2. 静态资源本地缓存
	3. UI框架按需加载
	4. 路由懒加载

### 什么是MVVM ，MVC 模型

Vue2 中双向数据绑定的原理是通过 `Object.defineProperty` 去递归劫持 data 里面的属性，都转换成 getter 和 setter 的形式，为我们获取和设置数据的操作提供了机会（修改视图），当我们去设置数据的时候会触发 setter，setter 内部去修改视图。

而 MVVM 我的理解是这样的。

M => V 是通过 Data Bindings（通过 Object.defineProperty 进行数据递归劫持）去实现的，V => M 是通过 DOM Listeners（DOM 监听）去实现的，无论 Data Bindings 还是 DOM Listeners 都是通过 VM 去做的（Vue）。

### 父子组件的生命周期钩子

1.加载渲染过程

父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount->子mounted->父mounted

2.子组件更新过程

父beforeUpdate->子beforeUpdate->子updated->父updated

3.父组件更新过程

父beforeUpdate->父updated

4.销毁过程

父beforeDestroy->子beforeDestroy->子destroyed->父destroyed

### Vue双向绑定的原理

Vue 数据双向绑定原理是通过 `数据劫持` + `发布者-订阅者模式` 的方式来实现的，首先是通过 `ES5` 提供的 `Object.defineProperty()` 方法来劫持（监听）各属性的 **getter、setter**，并在当监听的属性发生变动时通知订阅者，是否需要更新，若更新就会执行对应的更新函数。

<font color=cc3355>**什么是数据劫持**</font>

数据劫持比较好理解，通常我们利用`Object.defineProperty`劫持对象的访问器，在属性值发生变化时我们可以获取变化，从而进行进一步操作。

<font color=cc3355>**发布者模式 / 订阅者模式**</font>

在软件架构中，**发布订阅**是一种消息范式，消息的发送者（称为发布者）不会将消息直接发送给特定的接收者（称为订阅者）。而是将发布的消息分为不同的类别，无需了解哪些订阅者（如果有的话）可能存在。同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需了解哪些发布者（如果有的话）存在。

这里很明显了，区别就在于，不同于观察者和被观察者，**发布者和订阅者是互相不知道对方的存在的，发布者只需要把消息发送到订阅器里面，订阅者只管接受自己需要订阅的内容**

### Object.defineProperty

Object.defineProperty( obj, prop, descriptor )

三个参数: 

​	obj 要定义的对象 

​	prop 要定义或修改的属性名称或 Symbol

​	descriptor 要定义或修改的属性描述符

属性描述符

get
属性的 getter 函数，如果没有 getter，则为 `undefined`。当访问该属性时，会调用此函数。执行时不传入任何参数，但是会传入 `this` 对象（由于继承关系，这里的`this`并不一定是定义该属性的对象）。该函数的返回值会被用作属性的值。
**默认为 [`undefined`]**
set
属性的 setter 函数，如果没有 setter，则为 `undefined`。当属性值被修改时，会调用此函数。该方法接受一个参数（也就是被赋予的新值），会传入赋值时的 `this` 对象。
**默认为 [`undefined`]**

### v-model 的本质

v-model 的本质是一个语法糖, 它做了两件事 

第一件事给 input 绑定了一个 value 属性, 

第二件事给 input 绑定了input事件 事件触发时将绑定的变量重新赋值

v-model 也可以给组件实现双向数据绑定 props.value

### v-mode和.sync的对比

v-model与.sync的共同点：都是[语法糖](https://so.csdn.net/so/search?q=语法糖&spm=1001.2101.3001.7020)，都可以实现父子组件中的数据的双向通信。

v-model与.sync的不共同点：  

v-model：

1.父组件 v-model="" 子组件 @(input,value)

2.一个组件只能绑定`一个`v-model

3.v-model针对更多的是最终操作结果，是`双向绑定的结果`，是`value`，是一种`change操作`。

.sync：

1.父组件 :my-prop-name.sync 子组件@update:my-prop-name 的模式来替代事件触发，实现父子组件间的双向绑定。

2.一个组件可以`多个`属性用.sync修饰符，可以同时"双向绑定多个“prop”

3..sync针对更多的是各种各样的状态，是`状态的互相传递`，是`status`，是一种`update操作`。

### v-if 和v-show有什么区别？

`v-if` 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建，操作的实际上是dom元素的创建或销毁。

`v-show`  就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换 它操作的是display:none/block属性。

一般来说，`v-if` 有更高的切换开销，而 `v-show` 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 `v-show` 较好；如果在运行时条件很少改变，则使用 `v-if` 较好。

### v-for 循环为什么一定要绑定key ?

页面上的标签都对应具体的虚拟dom对象(虚拟dom就是js对象), 循环中 ,如果没有唯一key , 页面上删除一条标签, 由于并不知道删除的是那一条! 所以要把全部虚拟dom重新渲染, 如果知道key为对应标签被删除掉, 只需要把渲染的dom为对应标签去掉即可! 

### v-if和v-for为什么不建议一起用

v-for 比 v-if 高，每一次都需要先遍历整个数组再进行v-if判断，造成不必要的计算，影响性能，即使100个list中只需要使用一个数据，也会循环整个数组

在vue3中 v-if的优先级比v-for高,更不能放在一行,会直接报错

### 组件通信 / 组件传值
<font color=cc3355>**什么是组件通信**</font>


​		组件(`.vue`)通过某种方式来传递信息以达到某个目的

<font color=cc3355>**组件通信解决了什么问题**</font>

​		每个组件之间的都有独自的作用域，组件间的数据是无法共享的但实际开发工作中我们常常需要让组件之间共享数据，这也是组件通信的目的要让它们互相之间能进行通讯，这样才能构成完整系统

<font color=cc3355>**父子组件通信**</font>

方法一: props / $emit

* 父组件A通过props的方式向子组件B传递，B 传 A 通过在 B 组件中 $emit, A 组件中 v-on 的方式实现。

方法二: $children / $parent

* `$children`：获取到一个包含所有子组件(不包含孙子组件)的 VueComponent 对象数组，可以直接拿到子组件中所有数据和方法等

* `$parent`：获取到一个父节点的 VueComponent 对象，同样包含父节点中所有数据和方法等

方法三: $attrs / $listeners

* `$attrs`：包含父作用域里除 class 和 style 除外的非 props **属性集合**。通过 this.$attrs 获取父作用域中所有符合条件的属性集合，然后还要继续传给子组件内部的其他组件，就可以通过 v-bind="$attrs"

* `$listeners`：包含父作用域里 .native 除外的监听**事件集合**。如果还要继续传给子组件内部的其他组件，就可以通过 v-on="$linteners"

------

<font color=cc3355>**兄弟组件通信**</font>

状态（数据）提升

* A 修改 B，把 B 中的数据提升到公共的父组件里面，A 通过**子传父**修改父亲的数据，父亲通过**父传子**传递把数据传递到 B

------

<font color=cc3355>**跨层级组件通信**</font>

vuex 全局状态共享

EventBus 中央事件总线

> 不管是父子组件，兄弟组件，跨层级组件等都可以使用它完成通信操作
>
> 定义方法 
>
> 1. 抽离成一个单独的 js 文件 Bus.js , 然后在需要的地方引入
>    * A / B=> import Bus from "./Bus.js"
>    * A => Bus.$emit('自定义事件名', '传输的数据')
>    * B => Bus.$on('自定义事件名', function(接收的数据 ) { } )
> 2. 直接挂载到全局 Vue.prototype.$bus = new Vue() 使用的时候$bus.
>    * A => this.$bus.$emit('自定义事件名', '传输的数据')
>    * B => this.$bus.$on('自定义事件名', function(接收的数据 ) { } )
> 3. 注入到 Vue 根对象上面 new Vue( { data : { Bus : new Vue() } )

------

### 什么是组件

组件就是把图形、非图形的各种逻辑均抽象为一个``统一的概念`（组件）来实现开发的模式，在`Vue`中每一个`.vue`文件都可以视为一个组件

**组件的优势**

1. 降低整个系统的耦合度，在保持接口不变的情况下，我们可以替换不同的组件快速完成需求
2. 调试方便，由于整个系统是通过组件组合起来的，在出现问题的时候，可以用排除法直接移除组件，或者根据报错的组件快速定位问题，之所以能够快速定位，是因为每个组件之间低耦合，职责单一，所以逻辑会比分析整个系统要简单
3. 提高可维护性，由于每个组件的职责单一，并且组件在系统中是被复用的，所以对代码进行优化可获得系统的整体升级

------



### 什么是插件 / Vue.use()

Vue.use( )的参数类型必须是 object 或 Function

如果是 Function 那么这个函数就被当做 install 方法

如果是 object 则需要定义一个 install 方法



插件通常用来为 `Vue` 添加全局功能。插件的功能范围没有严格的限制——一般有下面几种：

- 添加全局方法或者属性。如: `vue-custom-element`
- 添加全局资源：指令/过滤器/过渡等。如 `vue-touch`
- 添加全局公共组件 Vue.component()
- 添加全局公共指令 Vue.directive()
- 通过全局混入来添加一些组件选项。如`vue-router`
- 添加 `Vue` 实例方法，通过把它们添加到 `Vue.prototype` 上实现。
- 一个库，提供自己的 `API`，同时提供上面提到的一个或多个功能。如`vue-router`

------

### vue2中如何自定义指令

Vue 允许注册自定义指令。代码复用和抽象的主要形式是组件。在需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。可以注册全局自定义指令，也可以注册局部指令。

参数:

- `el`：指令所绑定的元素，可以用来直接操作 DOM。

- `binding`：一个对象，包含以下 property

  ```js
  // 注册一个全局自定义指令 `v-focus`
  Vue.directive('focus', {
    // 当被绑定的元素插入到 DOM 中时……
    inserted: function (el) {
      // 聚焦元素
      el.focus()
    }
  })
  directives: {
    focus: {
      // 指令的定义
      inserted: function (el) {
        el.focus()
      }
    }
  }
  ```

  

### Vue中组件和插件有什么区别？

两者的区别主要表现在以下几个方面：

1. 编写形式
2. 注册形式
3. 使用场景

<font color=cc3355>**编写形式**</font>

**编写组件**

* 编写一个组件，可以有很多方式，我们最常见的就是`vue`单文件的这种格式，每一个`.vue`文件我们都可以看成是一个组件

**编写插件**

* `vue`插件的实现应该暴露一个 `install` 方法。这个方法的第一个参数是 `Vue` 构造器，第二个参数是一个可选的选项对象

<font color=cc3355>**注册使用**</font>

**组件注册**

* `vue`组件注册主要分为全局注册与局部注册
* 全局注册通过`Vue.component`方法，第一个参数为组件的名称，第二个参数为传入的配置项
* 局部注册只需在用到的地方通过`components`属性注册一个组件

**插件注册**

* 插件的注册通过`Vue.use()`的方式进行注册（安装），第一个参数为插件的名字，第二个参数是可选择的配置项
* 注意的是：
  * 注册插件的时候，需要在调用 `new Vue()` 启动应用之前完成
  * `Vue.use`会自动阻止多次注册相同插件，只会注册一次

<font color=cc3355>**使用场景**</font>

组件 `(Component)` 是用来构成你的 `App` 的业务模块，它的目标是 `App.vue`

插件 `(Plugin)` 是用来增强你的技术栈的功能模块，它的目标是 `Vue` 本身

简单来说，插件就是指对`Vue`的功能的增强或补充

### Vue中的$nextTick有什么作用？

<font color=cc3355>**$nextTick是什么**</font>

`Vue` 在更新 `DOM` 时是异步执行的。当数据发生变化，`Vue`将开启一个异步更新队列，视图需要等队列中所有数据变化完成之后，再统一进行更新

应用场景: 

一个输入框本来是隐藏的, 想让他显示的同时获取焦点

### 说说你对vue的mixin的理解

在导出的对象中可以写组件的配置项 如: data  methods  computed watch ....

作用: 将组件内相同的业务逻辑提取到一个公共的模块,当组件需要时再混入到组件内

特性:

1. 要混入的对象中如果是 生命周期函数  "依次执行"  先执行混入的生命钩子函数

2. 要混入的对象中 data  如果变量的值冲突,以组件内的值为准   (覆盖)

3. 要混入的对象中 methods  如果函数名冲突,以组件内的值为准  (覆盖)

### 说说你对slot的理解？slot使用场景有哪些？

<font color=cc3355>**slot是什么**</font>

`Slot` 艺名插槽，花名“占坑”，我们可以理解为`solt`在组件模板中占好了位置，当使用该组件标签时候，组件标签里面的内容就会自动填坑（替换组件模板中`slot`位置），作为承载分发内容的出口
<font color=cc3355>**应用场景**</font>

通过插槽可以让用户可以拓展组件，去更好地复用组件和对其做定制化处理

通过`slot`插槽向组件内部指定位置传递内容，完成这个复用组件在不同场景的应用

比如布局组件、表格列、下拉选、弹框显示内容等

<font color=cc3355>**分类**</font>

**默认插槽**

​	子组件用`<slot>`标签来确定渲染的位置，标签里面可以放`DOM`结构，当父组件使用的时候没有往插槽传入内容，标签内`DOM`结构就会显示在页面

父组件在使用的时候，直接在子组件的标签内写入内容即可

**具名插槽**

子组件用`name`属性来表示插槽的名字，不传为默认插槽

父组件中在使用时在默认插槽的基础上加上`slot`属性，值为子组件插槽`name`属性值

**作用域插槽**

子组件在作用域上绑定属性来将子组件的信息传给父组件使用，这些属性会被挂在父组件`v-slot`接受的对象上

父组件中在使用时通过`v-slot:`（简写：#）获取子组件的信息，在内容中使用

<font color=cc3355>**小结**</font>

- `v-slot`属性只能在`<template>`上使用，但在只有默认插槽时可以在组件标签上使用
- 默认插槽名为`default`，可以省略default直接写`v-slot`
- 缩写为`#`时不能不写参数，写成`#default`
- 可以通过解构获取`v-slot={user}`，还可以重命名`v-slot="{user: newName}"`和定义默认值`v-slot="{user = '默认值'}"`

### 组件缓存 keep-alive

<font color=cc3355>**组件缓存**</font>

组件的缓存可以在进行动态组件切换的时候对组件内部数据进行缓存,而不是走销毁流程

使用场景: 多表单切换,对表单内数据进行保存

<font color=cc3355>**keep-alive**</font>

 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。

 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。 当组件在`<keep-alive>`内被切换，它的`activated`和 `deactivated `这两个生命周期钩子函数将会被对应执行 。

**1. keep-alive的参数**

* include: 名称匹配的组件会被缓存-->include的值为组件的name。 
* exclude: 任何名称匹配的组件都不会被缓存。 
* max - 数量   决定最多可以缓存多少组件。

**2. keep-alive的使用**

1. 搭配` <component></component>`使用

2. 搭配路由使用 ( 需配置路由meta信息的`keepAlive`属性 )

3. 清除缓存组件 

   * 在组件跳转之前使用后置路由守卫判断组件是否缓存

   * ( beforeRouteLeave( to, from, next ){ from.meta.keepAlive = false }

   

<font color=cc3355>**keep-alive的两个钩子函数**</font>

| activated                            | deactivated                      |
| ------------------------------------ | -------------------------------- |
| 在 `keep-alive` 组件激活时调用       | 在` keep-alive` 组件停用时调用   |
| 该钩子函数在服务器端渲染期间不被调用 | 该钩子在服务器端渲染期间不被调用 |

使用`keep-alive`会将数据保留在内存中，如果要在每次进入页面的时候获取最新的数据，需要在 `activated `阶段获取数据，承担原来`created`钩子函数中获取数据的任务。

**注意：** 只有组件被`keep-alive`包裹时，这两个生命周期函数才会被调用，如果作为正常组件使用，是不会被调用的

使用 exclude 排除之后，就算被包裹在 keep-alive 中，这两个钩子函数依然不会被调用！在服务端渲染时，此钩子函数也不会被调用。

设置了缓存的组件钩子调用情况：

第一次进入：beforeRouterEnter ->created->…->activated->…->deactivated> beforeRouteLeave

后续进入时：beforeRouterEnter ->activated->deactivated> beforeRouteLeave

------

### vue中计算属性computed 和watch 的区别是什么？

computed计算属性就是为了简化template里面模版字符串的计算复杂度、防止模版太过冗余。它具有缓存特性

computed用来监控自己定义的变量，该变量不在data里面声明，直接在computed里面定义，然后就可以在页面上进行双向数据绑定展示出结果或者用作其他处理；

watch主要用于监控vue实例的变化，它监控的变量当然必须在data里面声明才可以，它可以监控一个变量，也可以是一个对象，一般用于监控路由、input输入框的值特殊处理等等，它比较适合的场景是一个数据影响多个数据，它不具有缓存性

- watch：监测的是属性值， 只要属性值发生变化，其都会触发执行回调函数来执行一系列操作。
- computed：监测的是依赖值，依赖值不变的情况下其会直接读取缓存进行复用，变化的情况下才会重新计算。

除此之外，有点很重要的区别是：**计算属性不能执行异步任务，计算属性必须同步执行**。(定义的函数接收return的结果，return属于同步执行的，是没办法拿到异步请求结果的)

也就是说计算属性不能向服务器请求或者执行异步任务。如果遇到异步任务，就交给侦听属性。watch也可以检测computed属性。

| 区别     | 侦听目标              | 执行区别                           | 监听区别                     |
| :------- | :-------------------- | :--------------------------------- | :--------------------------- |
| computed | 自己定义的变量        | 不能执行异步任务                   | 监听属性值                   |
| watch    | vue实例(data里面的值) | 可以执行异步任务(可以检测computed) | 监听依赖值(依赖不变缓存复用) |

### watch 怎么深度监听

deep：代表深度监控，不仅监控对象的变化，也监控对象中属性变化。
handler：就是以前的监控处理函数。
通过v.name和v.age获取对象中具体的值。

## 相关面试题

### 组件中的data为什么要定义成一个函数, 返回值是一个对象？

对象为引用类型，当复用组件时，由于数据对象都指向同一个data对象，当在一个组件中修改data时，其他重用的组件中的data会同时被修改；而使用返回对象的函数，由于每次返回的都是一个新对象（Object的实例），引用地址不同，则不会出现这个问题。

### 动态给vue的data添加一个新的属性时会发生什么？怎样解决？

<font color=cc3355>**问题: **</font> 数据虽然更新了, 但是页面没有更新

<font color=cc3355>**原因:  **</font>

1. `vue2`是用过`Object.defineProperty`实现数据响应式 
2. 当我们访问定义的属性或者修改属性值的时候都能够触发`setter`与`getter`
3. 但是我们为`obj`添加新属性的时候，却无法触发事件属性的拦截
4. 原因是一开始`obj`的要定义的属性被设成了响应式数据，而`新增的属性`并没有通过`Object.defineProperty`设置成响应式数据

<font color=cc3355>**解决方案: **</font>

1. Vue.set()
   * 通过`Vue.set`向响应式对象中添加一个`property`，并确保这个新 `property`同样是响应式的，且触发视图更新

2. Object.assign()
   * 直接使用`Object.assign()`添加到对象的新属性不会触发更新
   * 应创建一个新的对象，合并原对象和混入对象的属性

3. $forceUpdate
   * 如果你发现你自己需要在 `Vue`中做一次强制更新，99.9% 的情况，是你在某个地方做错了事
   * `$forceUpdate`迫使`Vue` 实例重新渲染
   * PS：仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。

总结

* 如果为对象添加少量的新属性，可以直接采用`Vue.set()`

- 如果需要为新对象添加大量的新属性，则通过`Object.assign()`创建新对象
- 如果你实在不知道怎么操作时，可采取`$forceUpdate()`进行强制刷新 (不建议)

PS：`vue3`是用过`proxy`实现数据响应式的，直接动态添加新属性仍可以实现数据响应式

### 和 Vue 相关的性能优化的手段都考虑过哪些

- v-for 循环的时候加 key
- v-for 和 v-if 不要放一行（计算属性）
- v-if 和 v-show 区分使用场景
- 路由懒加载、组件动态加载
- KeepAlive
- computed 和 方法区分使用场景（优先 computed）

### 虚拟DOM

Virtual DOM 其实就是一棵以 JavaScript 对象（VNode 节点）作为基础的树，用对象属性来描述节点，相当于在js和真实dom中间加来一个缓存，利用dom diff算法避免没有必要的dom操作，从而提高性能。当然算法有时并不是最优解，因为它需要兼容很多实际中可能发生的情况，比如后续会讲到两个节点的dom树移动。

在vue中一般都是通过修改元素的state,订阅者根据state的变化进行编译渲染，底层的实现可以简单理解为三个步骤：

- 1、用JavaScript对象结构表述dom树的结构，然后用这个树构建一个真正的dom树，插到浏览器的页面中。

- 2、当状态改变了，也就是我们的state做出修改，vue便会重新构造一棵树的对象树，然后用这个新构建出来的树和旧树进行对比（只进行同层对比），记录两棵树之间的差异。

- 3、把记录的差异再重新应用到所构建的真正的dom树，视图就更新了。

  

它的表达方式就是把每一个标签都转为一个对象，这个对象可以有三个属性：`tag`、`props`、`children`

- **tag**：必选。就是标签。也可以是组件，或者函数
- **props**：非必选。就是这个标签上的属性和方法
- **children**：非必选。就是这个标签的内容或者子节点，如果是文本节点就是字符串，如果有子节点就是数组。换句话说 如果判断 children 是字符串的话，就表示一定是文本节点，这个节点肯定没有子元素



### Dill算法

**Diff算法是一种对比算法**。对比两者是`旧虚拟DOM和新虚拟DOM`，对比出是哪个`虚拟节点`更改了，找出这个`虚拟节点`，并只更点所对应的`真实节点`，而不用更新其他数据没发生改变的节点，实现`精准`地更新真实DOM，进而`提高效率`。

`使用虚拟DOM算法的损耗计算`： 总损耗 = 虚拟DOM增删改+（与Diff算法效率有关）真实DOM差异增删改+（较少的节点）排版与重绘

`直接操作真实DOM的损耗计算`： 总损耗 = 真实DOM完全增删改+（可能较多的节点）排版与重绘

### key的作用

比如有一个列表 li1 到 li4，我们需要在中间插入一个li3，`li1` 和 `li2` 不会重新渲染，而 `li3、li4、li5` 都会重因为在不使用 `key` 或者列表的 `index` 作为 `key` 的时候，每个元素对应的位置关系都是 index，直接导致我们插入的元素到后面的全部元素，对应的位置关系都发生了变更，所以全部都会执行更新操作, 这是不可取的

而在使用唯一 `key`  的情况下，每个元素对应的位置关系就是 `key`，来看一下使用唯一 `key` 值的情况下

这样如图中的 `li3` 和 `li4` 就不会重新渲染，因为元素内容没发生改变，对应的位置关系也没有发生改变。

这也是为什么 v-for 必须要写 key，而且不建议开发中使用数组的 index 作为 key 的总结一下：

- key 的作用主要是为了更高效的更新虚拟 DOM，因为它可以非常精确的找到相同节点，因此 patch 过程会非常高效
- Vue 在 patch 过程中会判断两个节点是不是相同节点时，key 是一个必要条件。比如渲染列表时，如果不写 key，Vue 在比较的时候，就可能会导致频繁更新元素，使整个 patch 过程比较低效，影响性能
- 应该避免使用数组下标作为 key，因为 key 值不是唯一的话可能会导致上面图中表示的 bug，使 Vue 无法区分它他，还有比如在使用相同标签元素过渡切换的时候，就会导致只替换其内部属性而不会触发过渡效果
- 从源码里可以知道，Vue 判断两个节点是否相同时主要判断两者的元素类型和 key 等，如果不设置 key，就可能永远认为这两个是相同节点，只能去做更新操作，就造成大量不必要的 DOM 更新操作，明显是不可取的

### vue2和vue3的区别

1.  

   * Vue2与Vue3 `最大的`区别：Vue2使用`选项类型`API（Options API）对比Vue3`合成型`API（Composition API）
   
4. 建立数据 data

   * Vue2：这里把数据放入data属性中
   * Vue3：需要使用一个新的setup()方法，此方法在组件初始化构造的时候触发。
   * 使用以下三步来建立反应性数据:
     * 从vue`引入reactive`
     * 使用`reactive()`方法来`声明`我们的数据为`响应性数据`
     * 使用`setup()`方法来`返回`我们的响应性数据，从而我们的`template`可以`获取`这些响应性数据

5. 生命周期钩子 — `Lifecyle Hooks`

   * setup() :开始创建组件之前，在beforeCreate和created之前执行。创建的是data和method
   * onBeforeMount() : 组件挂载到节点上之前执行的函数。
   * onMounted() : 组件挂载完成后执行的函数。
   * onBeforeUpdate(): 组件更新之前执行的函数。
   * onUpdated(): 组件更新完成之后执行的函数。
   * onBeforeUnmount(): 组件卸载之前执行的函数。
   * onUnmounted(): 组件卸载完成后执行的函数

   若组件被`<keep-alive>`包含，则多出下面两个钩子函

   * onActivated(): 被包含在中的组件，会多出两个生命周期钩子函数。被激活时执行 。
   * onDeactivated(): 比如从 A组件，切换到 B 组件，A 组件消失时执行。

6. `父子传参不同`，setup() 函数特性

7. vue3 `Teleport瞬移组件`
   
   * Teleport 一般被翻译成瞬间移动组件，实际上是不好理解的.我把他理解成"独立组件"，他可以那你写的组件挂载到任何你想挂载的DOM上，所以是很自由很独立的

**总结：**

* setup 函数时，它将接受两个参数：（props、context(包含attrs、slots、emit)）
* setup 函数是处于 生命周期函数 beforeCreate 和 Created 两个钩子函数之前的函数
* 执行 setup 时，组件实例尚未被创建（在 setup() 内部，this 不会是该活跃实例的引用，即不指向vue实例，Vue 为了避免我们错误的使用，直接将 setup函数中的this修改成了 undefined）
* 与模板一起使用：需要返回一个对象 (在setup函数中定义的变量和方法最后都是需要 return 出去的 不然无法再模板中使用)
* 使用渲染函数：可以返回一个渲染函数，该函数可以直接使用在同一作用域中声明的响应式状态

### Vue3 注意事项

1. setup函数中不能使用this。Vue 为了避免我们错误的使用，直接将 setup函数中的this修改成了 undefined）

2. setup 函数中的 props 是响应式的，当传入新的 prop 时，它将被更新。但是，因为 props 是响应式的，你不能使用 ES6 解构，因为它会消除 prop 的响应性。

如果需要解构 prop，可以通过使用 setup 函数中的toRefs 来完成此操作：

**`父传子，props`**

```js
import { toRefs } from 'vue'
 
setup(props) {
	const { title } = toRefs(props)
 
	console.log(title.value)
	 onMounted(() => {
      console.log('title: ' + props.title)
    })

}
```

**`子传父，事件 - Emitting Events`**

```js
setup (props, { attrs, slots, emit }) {
    // ...
    const login = () => {
      emit('login', {
        username: state.username,
        password: state.password
      })
    }
}
```

3. setup()内使用响应式数据时，需要通过.value获取
4. 从 setup() 中返回的对象上的 property 返回并可以在模板中被访问时，它将自动展开为内部值。不需要在模板中追加 .value
5. setup函数只能是同步的不能是异步的

### **Vue 的template编译**

简而言之，就是先转化成AST树，再得到的render函数返回VNode（Vue的虚拟DOM节点），详细步骤如下：

> 首先，通过compile编译器把template编译成AST语法树（abstract syntax tree 即 源代码的抽象语法结构的树状表现形式），compile是createCompiler的返回值，createCompiler是用以创建编译器的。另外compile还负责合并option。
> 然后，AST会经过generate（将AST语法树转化成render funtion字符串的过程）得到render函数，render的返回值是VNode，VNode是Vue的虚拟DOM节点，里面有（标签名、子节点、文本等等）

### **vue如何监听对象或者数组某个属性的变化**

当在项目中直接设置数组的某一项的值，或者直接设置对象的某个属性值，这个时候，你会发现页面并没有更新。这是因为Object.defineProperty()限制，监听不到变化。

解决方式：

- this.$set(你要改变的数组/对象，你要改变的位置/key，你要改成什么value)

```java
this.$set(this.arr, 0, "OBKoro1"); // 改变数组
this.$set(this.obj, "c", "OBKoro1"); // 改变对象
```

- 调用以下几个数组的方法

```java
splice()、 push()、pop()、shift()、unshift()、sort()、reverse() 
```

vue源码里缓存了array的原型链，然后重写了这几个方法，触发这几个方法的时候会observer数据，意思是使用这些方法不用我们再进行额外的操作，视图自动进行更新。 推荐使用splice方法会比较好自定义,因为splice可以在数组的任何位置进行删除/添加操作

### **assets和static的区别**

这两个都是用来存放项目中所使用的静态资源文件。

两者的区别：

assets中的文件在运行npm run build的时候会打包，简单来说就是会被压缩体积，代码格式化之类的。打包之后也会放到static中。

static中的文件则不会被打包。

> 建议：将图片等未处理的文件放在assets中，打包减少体积。而对于第三方引入的一些资源文件如iconfont.css等可以放在static中，因为这些文件已经经过处理了。


## VueRouter

### VueRouter是什么, 有那些组件

- Vue Router 是官方的路由管理器。它和 Vue.js 的核心深度集成，路径和组件的映射关系, 让构建单页面应用变得易如反掌。
- router-link 实质上最终会渲染成a链接
- router-view 子级路由显示
- keep-alive 包裹组件缓存

### **router和route的区别**

> route相当于正在跳转的路由对象，可以从route里面获取[hash]，name ，path，query，matched等属性方法
> router 是VueRouter的实例，router是一个全局的路由对象，里面有很多的属性和方法 ，比如：router.push,route.options等等

### 路由开发的优缺点

优点：

* 整体不刷新页面，用户体验更好

* 数据传递容易, 开发效率高

缺点：

* 开发成本高(需要学习专门知识)
* 首次加载会比较慢一点。不利于seo

### VueRouter的使用方式

1. 使用Vue.use( )将VueRouter插入
2. 创建路由规则
3. 创建路由对象
4. 将路由对象挂到 Vue 实例上
5. 设置路由挂载点

### 路由跳转有那些方式

 2、this.$router.push()跳转到指定的url，并在history中添加记录，点击回退返回到上一个页面

 3、this.$router.replace()跳转到指定的url，但是history中不会添加记录，点击回退到上上个页面

 4、this.$router.go(n)向前或者后跳转n个页面，n可以是正数也可以是负数

### 编程式导航使用的方法以及常用的方法

​    路由跳转 ： this.$router.push()
​    路由替换 : this.$router.replace()
​    后退： this.$router.back()
​    前进 ：this.$router.forward()

### 路由的传参方式

#### 声明式导航传参

在 router-link 上的 to 属性传值,

1. /path?参数名=值

   * 接收传递过来的值:  $route.query.参数名

2. /path/值/值 –> 需要路由对象提前配置 path: “/path/参数名”

   * 接收传递过来的值:  $route.params.参数名

#### 编程式导航传参

this.$router.push( ) 可以不参数,根据传的值自动匹配是path还是name

因为使用path会自动忽略params ,所以会出现两种组合

<font color=cc3355>**path+params 方式传参**</font>

**A页面传参**

```js
this.$router.push({
    name: 'xxx', // 跳转的路由
    params: {
      id: id   // 发送的参数
    }
})
```

**B页面接收传参**

this.$router.params.id

<font color=cc3355>**name+query 方式传参**</font>

**A页面传参**

```js
this.$router.push({
    path: '/xxx', // 跳转的路由
    query: {
      id: id    // 发送的参数
    }
})
```

**B页面接参**

this.$route.query.id

<font color=cc3355>**params 和query 方式传参的区别**</font>

1. 写法上不同
2. 地址栏不同
3. 刷新方式不同

### 路由重定向和404

<font color=cc3355>**路由重定向**</font>

1. 匹配path后, 强制切换到另一个目标path上
2. redirect 是设置要重定向到哪个路由路径
3. 网页默认打开, 匹配路由"/", 强制切换到"/find"上
4. redirect配置项, 值为要强制切换的路由路径 
5. 强制重定向后, 还会重新来数组里匹配一次规则

<font color=cc3355>**404页面**</font>

1. 如果路由hash值, 没有和数组里规则匹配
2. path: ' * '  (任意路径) 
3. 默认给一个404页面
4. 如果路由未命中任何规则, 给出一个兜底的404页面

### 路由配置项常用的属性及作用

路由配置参数：  

​     path : 跳转路径
​     component : 路径相对于的组件
​     name:命名路由
​     children:子路由的配置参数(路由嵌套)
​     props:路由解耦
​     redirect : 重定向路由

### 前端路由原理

前端路由的核心，就在于改变视图的同时不会向后端发出请求；而是加载路由对应的组件

vue-router就是将组件映射到路由, 然后渲染出来的。并实现了三种模式

Hash模式、History模式以及Abstract模式。默认Hash模式

### hash模式和history模式和Abstract模式？

<font color=cc3355>**hash模式**</font>

是指 url 尾巴后的 # 号以及后面的字符。hash 虽然出现在url中，但不会被包括在http请求中，对后端完全没有影响，因此改变hash不会被重新加载页面。

<font color=cc3355>**history 模式**</font>

URL 就像正常的 url, 不过这种模式要玩好，还需要后台配置支持。因为我们的应用是个单页客户端应用，如果后台没有正确的配置，当用户在浏览器直接访问 `http://oursite.com/user/id` 就会返回 404，这就不好看了

<font color=cc3355>**Abstract模式**</font>

支持所有javascript运行模式。vue-router 自身会对环境做校验，如果发现没有浏览器的 API，路由会自动强制进入 abstract 模式。在移动端原生环境中也是使用 abstract 模式。

**修改路由模式:** 在实例化路由对象时, 传入mode选项和值修改

------



### Hash模式

<font color=cc3355>**原理**</font>
基于浏览器的hashchange事件，地址变化时，通过window.location.hash 获取地址上的hash值；并通过构造Router类，配置routes对象设置hash值与对应的组件内容。

<font color=cc3355>**优点**</font>

1. hash值会出现在URL中, 但是不会被包含在Http请求中, 因此hash值改变不会重新加载页面
2. hash改变会触发hashchange事件, 能控制浏览器的前进后退
3. 兼容性好

<font color=cc3355>**缺点**</font>

1. 地址栏中携带#，不美观
2. 只可修改 # 后面的部分，因此只能设置与当前 URL 同文档的 URL
3. hash有体积限制，故只可添加短字符串
4. 设置的新值必须与原来不一样才会触发hashchange事件，并将记录添加到栈中
5. 每次URL的改变不属于一次http请求，所以不利于SEO优化

### History模式

<font color=cc3355>**原理**</font>

基于HTML5新增的pushState()和replaceState()两个api，以及浏览器的popstate事件，地址变化时，通过window.location.pathname找到对应的组件。并通过构造Router类，配置routes对象设置pathname值与对应的组件内容。

<font color=cc3355>**优点**</font>

1. 没有#，更加美观
2. pushState() 设置的新 URL 可以是与当前 URL 同源的任意 URL
3. pushState() 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中
4. pushState() 通过 stateObject 参数可以添加任意类型的数据到记录中
5. pushState() 可额外设置 title 属性供后续使用
6. 浏览器的进后退能触发浏览器的popstate事件，获取window.location.pathname来控制页面的变化

<font color=cc3355>**缺点**</font>

1. URL的改变属于http请求，借助history.pushState实现页面的无刷新跳转，因此会重新请求服务器。所以前端的 URL 必须和实际向后端发起请求的 URL 一致。如果用户输入的URL回车或者浏览器刷新或者分享出去某个页面路径，用户点击后，URL与后端配置的页面请求URL不一致，则匹配不到任何静态资源，就会返回404页面。所以需要后台配置支持，覆盖所有情况的候选资源，如果 URL 匹配不到任何静态资源，则应该返回app 依赖的页面或者应用首页。
2. 兼容性差，特定浏览器支持

------

### 哈希路由和history路由的区别和原理

路由模块的本质就是建立起 `url` 和`页面`之间的`映射关系`。 

`“更新视图但不重新请求页面”`是前端路由原理的核心之一，目前在浏览器环境中这一功能的实现主要有两种方式： 

利用 URL 中的 hash（“#”）和利用 History 在 HTML5 中新增的方法

1）hash 模式：在浏览器中符号“#”，#以及#后面的字符称之为 hash， 用window.location.hash 读取。使用 `hashchange 事件`来`监听 hash 值的变化`，从而对页面进行跳转（渲染）。 

2） history 模式：history 采用 HTML5 的新特性；且提供了两个新方法： `pushState()， replaceState()`可以`对浏览器历史记录栈进行修改`，以及 `popState 事件`可以`监听状态变更`

### 应用场景

### 为什么history模式下路由跳转会报404

1. URL的改变属于http请求，借助history.pushState实现页面的无刷新跳转，因此会重新请求服务器
2. 所以前端的 URL 必须和实际向后端发起请求的 URL 一致

------

### 路由守卫

通过路由来进行一些操作，比如最常见的登录权限验证，当用户满足条件时，才让其进入导航，否则就取消跳转，并跳到登录页面让其登录

全局守卫

​	vue-router全局有三个守卫

1. router.beforeEach 全局前置守卫 进入路由之前 ( to,from,next 这三个参数 )
2. router.beforeResolve 全局解析守卫 在beforeRouteEnter调用之后调用 ( to,from,next 这三个参数 )
3. router.afterEach 全局后置钩子 进入路由之后 ( to,from,两个参数 ) 

to，from，next 三个守卫参数

* to 将要离开的路由对象
* from 将要进入的路由对象
* next 是否放行 这个参数是个函数， 且必须调用， 否则不能进入路由（页面空白）
  * next（）进入该路由
  * next（false）取消进入路由， url地址重定向为from路由地址（也就是将要离开的路由地址）
  * next 跳转新路由 ， 当前导航被中断，重新开始一个新的导航

## Vuex

### 什么vuex ,谈谈你对它的理解？

1. 首先vuex的出现是为了解决web组件化开发的过程中，各组件之间传值的复杂和混乱的问题
2. 将我们在多个组件中需要共享的数据放到start中，
3. 要获取或格式化数据需要使用getters，
4. 改变start中的数据，可以使用mutation，但是只能包含同步的操作，在具体组件里面调用的方式`this.$store.commit('xxxx')`
5. Action也是改变store中的数据，不过是提交的mutation，并且可以包含异步操作，在组件中的调用方式`this.$store.dispatch('xxx')`； 在actions里面使用的commit('调用mutation')

Vuex 是一个专为 Vue.js应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。

### Vuex工作流程

1. 组件内可以通过dispatch触发Actions, Actions里面经常处理异步数据, 
2. 数据返回后可以通过Commit 来触发Mutations, 每次触发都可以通过Devtools观测到它的类型和传参,
3. Mutations一般用来修改state里面的值, state里面的值变化了, 所有组件内的vuex的数据都变化了
4. 如果没有异步请求的话可以直接在组件里面通过 Commit 触发 Mutations 修改state里面的值

### **vuex中有几个核心属性，分别是什么？**

一共有5个核心属性，分别是:

- state 唯一数据源,Vue 实例中的 data 遵循相同的规则
- mutation 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation,非常类似于事件,通过store.commit 方法触发

- action Action 类似于 mutation，不同在于Action 提交的是 mutation，而不是直接变更状态，Action 可以包含任意异步操作

- module 由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。

```java
const moduleA = {
  state: () => ({ ... }),
  mutations: { ... },
  actions: { ... },
  getters: { ... }
}

const moduleB = {
  state: () => ({ ... }),
  mutations: { ... },
  actions: { ... }
}

const store = new Vuex.Store({
  modules: {
    a: moduleA,
    b: moduleB
  }
})

store.state.a // -> moduleA 的状态
store.state.b // -> moduleB 的状态
```
- getters 可以认为是 store 的计算属性,就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。Getter 会暴露为 store.getters 对象，你可以以属性的形式访问这些值.

```java
const store = new Vuex.Store({
  state: {
    todos: [
      { id: 1, text: '...', done: true },
      { id: 2, text: '...', done: false }
    ]
  },
  getters: {
    doneTodos: state => {
      return state.todos.filter(todo => todo.done)
    }
  }
})

store.getters.doneTodos // -> [{ id: 1, text: '...', done: true }]
```

### vuex的getter的作用

getter 有点类似 Vue.js 的计算属性，当我们需要从 store 的 state 中派生出一些状态，那么我们就需要使用 getter，getter 会接收 state 作为第 一个参数，而且 getter 的返回值会根据它的依赖被缓存起来，只有 getter 中的依赖值（state 中的某个需要派生状态的值）发生改变的时候才会被重新计算。

### mutation 里面可以放异步吗？

非严格模式确实是可以放异步，代码也可以正常执行！严格模式下不能这样操作（写异步），会有警告。

不建议放异步代码，目的是为了形成数据快照（拿到当时的那个数据状态）便于溯源，为了配合 DevTools 调试。

### **vuex中的数据在页面刷新后数据消失**

用sessionstorage 或者 localstorage 存储数据

```java
存储： sessionStorage.setItem( '名', JSON.stringify(值) )
使用： sessionStorage.getItem('名') ---得到的值为字符串类型，用JSON.parse()去引号；
```


## ES6有哪些新特性？ 

ES6是2015年推出的一个新的版本、这个版本相对于ES5的语法做了很多的优化

### let和const是什么
<font color=cc3355>**let:  **</font>

* 声明变量
* 没有变量提升
* 不可重复声明
* 具有块级作用域
* 声明变量后可以在使用时赋值

<font color=cc3355>**const:  **</font>

* 只读常量
* 没有变量提升
* 不可重复声明
* 具有块级作用域
* 声明变量后必须立马赋值


### 箭头函数

使用 "箭头" ( => ) 来定义函数. 箭头函数相当于匿名函数, 并且简化了函数定义

<font color=cc3355>**箭头函数的特征:  **</font>

* 箭头函数没有this, this指向定义箭头函数所处的外部环境
* 箭头函数的this永远不会变，call、apply、bind也无法改变
* 箭头函数只能声明成**匿名函数**，但可以通过表达式的方式让箭头函数具名
* 箭头函数没有原型prototype
* 箭头函数不能当做一个构造函数 因为 this 的指向问题
* 箭头函数没有 arguments 在箭头函数内部访问这个变量访问的是外部环境的arguments, 可以使用 ...代替

### 解构赋值

<font color=cc3355>**常用对象解构:  **</font>

对象解构的语法形式是在一个赋值操作符左边放置一个对象字面量

<font color=cc3355>**常用数组解构:  **</font>

它使用的是数组字面量，且解构操作全部在数组内完成，而不是像对象字面量语法一样使用对象的命名属性

<font color=cc3355>**字符串解构**：</font>`const [a, b, c, d, e] = "hello"`

<font color=cc3355>**数值解构**：</font>`const { toString: s } = 123`

<font color=cc3355>**布尔解构**：</font>`const { toString: b } = true`

<font color=cc3355>**对象解构**</font>

- 形式：`const { x, y } = { x: 1, y: 2 }`
- 默认：`const { x, y = 2 } = { x: 1 }`
- 改名：`const { x, y: z } = { x: 1, y: 2 }`

<font color=cc3355>**数组解构**</font>

- 规则：数据结构具有`Iterator接口`可采用数组形式的解构赋值
- 形式：`const [x, y] = [1, 2]`
- 默认：`const [x, y = 2] = [1]`

<font color=cc3355>**函数参数解构**</font>

- 数组解构：`function Func([x = 0, y = 1]) {}`
- 对象解构：`function Func({ x = 0, y = 1 } = {}) {}`

<font color=cc3355>**应用场景:  **</font>

* 交换变量值：`[x, y] = [y, x]`
* 返回函数多个值：`const [x, y, z] = Func()`
* 定义函数参数：`Func([1, 2])`
* 提取JSON数据：`const { name, version } = packageJson`
* 定义函数参数默认值：`function Func({ x = 1, y = 2 } = {}) {}`
* 遍历Map结构：`for (let [k, v] of Map) {}`
* 输入模块指定属性和方法：`const { readFile, writeFile } = require("fs")`

<font color=cc3355>**注意点**</font>

* 匹配模式：只要等号两边的模式相同，左边的变量就会被赋予对应的值

* 解构赋值规则：只要等号右边的值不是对象或数组，就先将其转为对象

* 解构默认值生效条件：属性值严格等于`undefined`

* 解构遵循匹配模式

* 解构不成功时变量的值等于`undefined`

* `undefined`和`null`无法转为对象，因此无法进行解构

### promise

1. 是js中进行异步编程的新的解决方案( 解决回调地狱 )

### class类



### 新增了模块化、利用import 、export来实现导入、导出

按需导入是怎么实现的

剩余运算符

## promise

### promise 是什么

   **坤哥结语 ： promise本质 不是控制异步代码的执行顺序（无法控制） ， 而是控制异步代码结果处理的顺序**

1. 是ES6新增的语法
2. 是js中进行异步编程的新的解决方案( 解决回调地狱 )
3. 语法上说 promise 是一个构造函数
4. 从功能上说 promise 对象用来封装一个异步操作并以获取到成功或失败后的值

### promise 的状态改变

1. pending 变为 resolved
2. pending 变为 rejected
3. 只有这两种 且一个 promise 对象只能改变一次无论成功还是失败,都会有个结果

### promise 的API(静态方法)

1. 构造函数 Promise( excutor ){ }

   * executor 函数: 执行器 ( resolve, reject ) =>{ }
   * resolve 函数: 内部定义成功时我们调用的函数 value => { }
   * reject 函数: 内部定义失败时我们调用的函数 reason => { }
   * 说明: executor 会在 Promise 内部立即同步调用,异步操作在执行器中执行

2. Promise.prototype.then 方法: (onResolved, onRejected) => {}

   * onResolved 函数: 成功的回调函数 (value) => {}

   * onRejected 函数: 失败的回调函数 (reason) => {}

   * 指定用于得到成功 value 的成功回调和用于得到失败 reason 的失败回调

     返回一个新的 promise 对象

3. Promise.prototype.catch 方法: (onRejected) => {}

   * onRejected 函数: 失败的回调函数 (reason) => {}

4. Promise.resolve 方法: (value) => {}

   * value: 成功的数据或 promise 对象
   * 说明: 返回一个成功/失败的 promise 对象

5. Promise.reject 方法: (reason) => {}

   * reason: 失败的原因
   * 说明: 返回一个失败的 promise 对象

6. Promise.all 方法: (promises) => {}

   * promises: 包含 n 个 promise 的数组
   * 说明: 返回一个新的 promise, 只有所有的 promise 都成功才成功, 只要有一个失败了就直接失败

7. Promise.race 方法: (promises) => {}

   * promises: 包含 n 个 promise 的数组
   * 说明: 返回一个新的 promise, 第一个完成的 promise 的结果状态就是最终的结果状态

### 如何改变 promise 的状态

* resolve(value): 如果当前是 pending 就会变为 resolved
* eject(reason): 如果当前是 pending 就会变为 rejected
* 抛出异常: 如果当前是 pending 就会变为 rejected

<font color=cc3355>**一个promise指定多个成功 / 失败回调函数, 都会调用吗?**</font>

* 当 promise 改变为对应状态时都会调用

<font color=cc3355>**改变 promise 状态和指定回调函数谁先谁后?**</font>

1. 都有可能, 正常情况下是先指定回调再改变状态, 但也可以先改状态再指定回调

2. 如何先改状态再指定回调? 
   * 在执行器中直接调用 resolve()/reject()
   * 延迟更长时间才调用 then()

3. 什么时候才能得到数据? 
   * 如果先指定的回调, 那当状态发生改变时, 回调函数就会调用, 得到数据
   * 如果先改变的状态, 那当指定回调时, 回调函数就会调用, 得到数据

<font color=cc3355>**promise.then()返回的新 promise 的结果状态由什么决定?**</font>

1. 简单表达: 由 then()指定的回调函数执行的结果决定

2. 详细表达: 
   * 如果抛出异常, 新 promise 变为 rejected, reason 为抛出的异常
   * 如果返回的是非 promise 的任意值, 新 promise 变为 resolved, value 为返回的值
   * 如果返回的是另一个新 promise, 此 promise 的结果就会成为新 promise 的结果

<font color=cc3355>**promise 如何串连多个操作任务?  **</font>

* promise 的 then()返回一个新的 promise, 可以开成 then()的链式调用

* 通过 then 的链式调用串连多个同步/异步任务

<font color=cc3355>**promise 异常传透?  **</font>

* 当使用 promise 的 then 链式调用时, 可以在最后指定失败的回调, 

* 前面任何操作出了异常, 都会传到最后失败的回调中处理

<font color=cc3355>**中断 promise 链?  **</font>

* 当使用 promise 的 then 链式调用时, 在中间中断, 不再调用后面的回调函数

* 办法: 在回调函数中返回一个 pendding 状态的 promise 对象

### 自定义 / 手写 promise

1. 写个自调用函数
2. 在自调用函数里面写一个具名函数 Promise
3. 在这个函数的原型上用 prototype.then 上面挂一个函数, 指定promise 成功 / 失败的回调函数, 函数的返回值是一个新的 promise 对象

### 链式调用: promises/A+规范

基于规范的描述，我们得到以下几点：

* `then`方法本身会返回一个新的`Promise`对象，返回一个新的Promise以后它就有自己的`then`方法，这样就能实现无限的链式
* 不论 `promise1` 被 `resolve()`  还是被 `reject()` 时 `promise2` 都会执行 **`Promise 解决过程：[[Resolve]](promise2, x)`**

在手写这里我们把这个 **`Promise 解决过程：[[Resolve]](promise2, x)`** 命名为 `resolvePromise()` 方法，参数为 `(promise2, x, resolve, reject)` 即：

### async与await

<font color=cc3355>**async**</font>

1. 函数的返回值为 promise 对象

2. promise 对象的结果由 async 函数执行的返回值决定

<font color=cc3355>**await **</font>

1. await 右侧的表达式一般为 promise 对象, 但也可以是其它的值

2. 如果表达式是 promise 对象, await 返回的是 promise 成功的值

3. 如果表达式是其它值, 直接将此值作为 await 的返回值

<font color=cc3355>**注意点**</font>

1. await 必须写在 async 函数中, 但 async 函数中可以没有 await

2. 如果 await 的 promise 失败了, 就会抛出异常, 需要通过 try...catch 捕获处理

### js的执行机制 / 事件循环机制 / event loop

js是一个单线程的, 如果有一些高耗时操作就会带来进程阻塞问题, 为了解决这个问题, js有两种任务执行模式

同步模式和异步模式 

同步模式下创建的同步任务是立即执行的

异步模式下创建的异步任务分为宏任务与微任务两种



所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务。异步任务指的是，不进入主线程、而进入"任务队列"（task queue）的任务，只有"任务队列"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。

ES6 规范中 宏任务(macro-task)是由宿主浏览器或node发起的, 而微任务 (Jobs) 由JS自身发起的

宏任务: 包括整体代码 script，setTimeout，setInterval

微任务：Promise.then(非 new Promise)，process.nextTick(node 中

# https

### 为什么需要HTTPS？

HTTP协议是网络通信的基石, 基于HTTP协议, 完成了很多的网页应用功能, 但是HTTP协议是明文传输数据的! 太不安全了!

HTTPS 是安全版的 HTTP。

HTTP 协议在传输数据时采用的是明⽂方式传递，因此，⼀些敏感信息的传输就变得很不安全。

而 HTTPS 就是为了解决 HTTP 的不安全⽽产⽣的。

### HTTPS是如何保证安全的？

HTTPS 在传输数据的过程中会对数据进行加密处理，保证安全性。

那HTTPS采用的什么样的加密方式呢？我们来了解下一些加密的基本概念。

目前常见的加密算法可以分成三类，`对称加密算法`，`非对称加密算法` 和 `Hash算法`。

1. 对称加密算法: 相同密钥加密解密,  可逆的! 可以用于加密解密传输数据

   想使用对称加密算法, 一定要保证密钥不被泄漏  (且进行密钥的传输约定时, 一定要保证安全)

2. 非对称加密算法: 有两把钥匙, 公钥, 私钥,  可逆的, 可以用于 https 的初步交换密钥

3. Hash算法: 不可逆的,  根据一段内容, 生成一段唯一标识, 一般用于验证数据是否被修改!   (md5)

**什么是对称加密？**

对称加密的特点是文件加密和解密使用相同的密钥，即加密密钥也可以用作解密密钥，

这种方法在密码学中叫做对称加密算法，对称加密算法使用起来简单快捷，密钥较短，且破译困难

**通信的双⽅都使⽤同⼀个秘钥进⾏加密, 解密。**⽐如，两个人事先约定的暗号，就属于对称加密。 

对称加密的特点是：

- 优点:

  计算量小、加密速度快、加密效率高。

- 缺点: 

  **在数据传送前，发送方和接收方必须商定好秘钥，然后双方保存好秘钥。**

  **如果一方的秘钥被泄露，那么加密信息也就不安全了**

  最不安全的地方, 就在于第一开始, 互相约定密钥的时候!!! 传递密钥!

使用场景：本地数据加密、https通信、网络传输等

常见算法：AES、DES、3DES、DESX、Blowfish、IDEA、RC4、RC5、RC6  (全球公开, 通过了层层筛选, 层层检验)  没有被破解

全球有专门做算法设计的加密算法设计师, 但经过公开检验的算法才是安全的 (很多公开的算法, 虽然可以用撞库的方式破解, 但是尝试破解的成本会非常高 (甚至几百年))

**什么是⾮对称加密？**

而加密和解密其实可以使用不同的规则，只要这两种规则之间存在某种对应关系即可，

这样就避免了直接传递之前的相同的密钥。这种新的加密模式被称为"非对称加密算法"。

通信的双方使用不同的秘钥进行加密解密，即秘钥对（私钥 + 公钥）。

特征: 私钥可以解密公钥加密的内容,  公钥可以解密私钥加密的内容

非对称加密的特点是：

- 优点：非对称加密与对称加密相比其安全性更好

- **缺点：加密和解密花费时间长、速度慢，只适合对少量数据进行加密。**

使用场景：https会话前期、CA数字证书、信息加密、登录认证等

常见算法：RSA、ECC（移动设备用）、Diffie-Hellman、El Gamal、DSA（数字签名用）

**HTTPS 加密解决⽅案** 

结合了两种加密⽅式：

- 将 `对称加密的密钥(一串约定的字符串)` ⽤非对称加密的公钥, 进⾏加密并发送出去，接收⽅使⽤私钥解密得到 `对称加密密钥`

- 双⽅沟通时使⽤ `对称加密密钥` 进⾏

**可以看到，只有在发送秘钥阶段才使用非对称加密，而后续的通信都使用对称加密，这样解决了性能问题。**

HTTPS 目前所使用的 TLS或SSL协议,  就是目前采用的加密通道的规范协议 

它利用对称加密、(公私钥)非对称加密, 以及其密钥交换算法，可完成可信任的信息传输

1. 利用 非对称加密 加密传输 对称加密所约定的密钥  (保证了密钥传输的安全)
2. 后续, 利用对称加密, 有效便捷的进行数据传输!!

**数字证书**

为了安全性, 一般还需要签发数字证书! 

客户端 和 服务器端要初步互通消息时,  客户端发送请求可以拿到公开的公钥信息

进而进行非对称加密, 使用公钥, 加密`对称加密密钥`, 传递给服务器, 后续通信都使用对称加密! 

**问题是: 初步互通消息时, 如果请求拿到的公钥信息, 就是假的, 或者不安全的! 那么后续的所有操作, 都将是不安全的!**

如何保证公钥的安全性呢??  说白了, 需要证明公钥是安全可靠的!!! 要证明网站是安全可靠的!!!



所以, 就需要有数字证书(CA证书),  一般是CA机构(互联网的机构,  登记网站和公钥的)颁发的, 证明这个公钥是安全可靠的!

**CA证书中心会对你网站的公钥, 网站的域名地址,  证书到期时间, 等一些相关信息一起加密签发数字证书, 保证你网站的安全性**




当公司申请了 CA 证书后, 就应该在响应时, 将数字证书一起发送给客户端

而客户端, 接收到消息后, 就可以查看证书 , 权威CA机构都可以

1. 如果正在访问的网站 和 证书记载的网址 不一致, 说明不安全,  可能被冒用, 浏览器就会发出警告!!! 

2. 如果签发证书的机构, 不权威, 发出警告 


3. 如果证书过期了, 浏览器也会发出警告

   因为一旦证书过期了, CA机构, 不会继续实时检测网站的安全有效性!

**数字签名**

但这还是有问题：如果证书被篡改了怎么办?

这时就需要用⼀个技术：**数字签名**。 (根据证书内容, 生成的一个唯一标识) 

数字签名就是先⽤ **CA ⾃带的 Hash 算法来计算出证书内容的⼀个摘要**，然后使⽤ CA 私钥进行加密，组成数字签名。

当别⼈把他的证书发过来时，**接收方⽤同样的算法再次⽣成摘要**，⽤ CA 公钥解密后得到CA生成的摘要，两者进行对⽐后,

就能确定中间是否被⼈篡改。这样就能最⼤程度的保证通信的安全了。

[博客参考](https://blog.csdn.net/u014044812/article/details/80723009)

---

简要小结:

1. 为什么需要 HTTPS ? 因为HTTP是明文传输数据的, 不安全, 而 HTTPS 是会对内容加密的

2. HTTPS 的加密策略是什么 ?

   先用 `非对称加密`, 传递对称加密的密钥   (保证了密钥传输的安全)

   后续 使用`对称加密`, 进行交流  (保证了传输数据安全)

3. 问题: 就算是第一次交流用非对称加密,  公钥也是要在网络中传输的!

   如何证明公钥是可靠的? 如何证明网站是可靠的 ?    (CA机构认证, 网站需要申请  **`数字证书`**  )

   请求时, 网站就会将数字证书给到浏览器, 浏览器默认就会检测证书的可靠性!

   (1) 是否是权威机构发布的!

   (2) 看证书中记录的地址 和 当前访问的网站的地址, 是否一致, 只有一致, 才可靠!

   (3) 看证书是否过期

   ...

4. 如何保证证书不被篡改 => **`数字签名`**,  可以根据证书的所有的内容, 生成一个唯一标识!!! (`Hash加密算法`)

   一旦内容如果被修改了, 再次生成唯一标识时,  和之前生成的唯一标识就不一样!  检测是否被修改!

## JS相关面试题

### **什么是JavaScript？**

javascript通常缩写为JS，是一种符合ECMAScript规范的高级解释脚本语言。JavaScript一种直译式脚本语言，是一种动态类型、弱类型、基于原型的语言。

它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML网页上使用，用来给HTML网页增加动态功能。

JavaScript是万维网的核心技术之一，它支持交互式web页面，是web应用程序的重要组成部分。绝大多数网站都使用它，主要的网络浏览器都有专门的JavaScript引擎来执行它。

### js的数据类型有哪些？

js的数据类型分为基本数据类型（string、number、boolean、null、undefined、symbol，BigInt）

复杂数据类型(object)

基本数据类型的特点：直接存储在栈中的数据

复杂数据类型的特点：存储的是该对象在栈中引用，真实的数据存放在堆内存里

symbol

* 符号是原始值，且符号实例是唯一、不可变的
* 符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险

BigInt 数据类型的目的是比`Number`数据类型支持的范围更大的整数值。在对大整数执行数学运算时，以任意精度表示整数的能力尤为重要。使用`BigInt`，整数溢出将不再是问题。

### 数据类型的检测

然后判断数据类型的方法一般可以通过：typeof、instanceof、constructor、Object.prototype.toString.call()四种常用方法

| 不同类型的优缺点 | typeof             | instanceof                         | constructor                                 | Object.prototype.toString.call   |
| ---------------- | ------------------ | ---------------------------------- | ------------------------------------------- | -------------------------------- |
| 优点             | 使用简单           | 能检测出引用类型                   | 基本能检测所有的类型（除了null和undefined） | 检测出所有的类型                 |
| 缺点             | 只能检测出基本类型 | 不能检测出基本类型，且不能跨iframe | constructor易被修改，也不能跨iframe         | IE6下，undefined和null均为Object |

使用方法 

1. typeof         typeof 数据  返回值是数据类型
2. instanceof    数据 instanceof 引用数据类型  返回值是true/false
3. constructor   数据.constructor   返回值是数据类型
4. Object.prototype.toString.call   在call( 数据 )   返回值是数据类型

### new操作符的工作流程?

1. 首先创建一个新的空对象
2. 将新对象的原型对象指向构造函数的原型对象
3. 将新对象的this指向构造函数
4. 判断如果当前的构造函数是否是对象，如果是对象则返回构造函数，如果不是则返回新创建的对象

### 防抖和节流

防抖和节流都是性能优化的一种手段。

1. 防抖：持续触发不执行，不触发的一段时间后才执行。
2. 节流：持续触发也执行，只不过，执行的频率变低了。

应用场景？

* 根据输入的内容请求接口？防抖
* 获取窗口缩放的大小，滚动位置？节流

<font color=cc3355>**防抖 **</font>

当事件被触发 n 秒后再执行回调, 如果在n秒内有被触发, 则重新计时

使用场景: 频繁触发按钮点击事件, input框搜索等

<font color=cc3355>**节流**</font>

规定在一个单位时间内只能触发一次函数,  如果在单位时间内触发多次, 只执行一次

使用场景: 下拉加载更多 ( 无线滚动事件 ) , 浏览器的resize , scroll 事件, 鼠标持续触发事件

### 浏览器 / html页面渲染过程

浏览器获取到 html 资源后开始解析 html (dom tree) -> 构建 DOM 树

解析到 css 后根据 css 生成 css 规则树 (style rules) -> 产生 CSS 规则树

在 dom 树和 css 规则树都生成完后，

通过 dom 树和 css 规则树生成渲染树( render tree ) -> 构建 render 树

渲染树构建完成后，浏览器开始计算元素的大小和位置( layout ) -> 布局 render 树

根据计算好的节点信息将内容绘制到屏幕上( painting ) -> 绘制 render 树

<font color=cc3355>**详细过程**</font>

1. dom 树和 css 规则树的先后顺序

   浏览器获取的 html 资源后自上而下开始解析，生成 dom 树；如果遇到 style 的内联样式和 link 会将 css 交由 css 渲染器构建 css 规则树； 其中加载 link 引入的外部样式文件是异步加载的，并且整个 css 规则树也是与 dom 树的构建是并行的；

2. Javascript脚本的加载

   由于 js 可以操作 dom，所以在 html 解析到 Javascript 脚本时会停止对 dom 的解析；而 css 的解析会阻塞 js 的执行，所以在某些情况下 css 的解析会导致 dom 的解析；

   **script的defer 属性**

   * 给 script 标签添加 defer 属性，适用于 js 中涉及到 dom 的操作，或者与其他的 js 有相互引用的关系 添加 defer 属性会将 Javascript 脚本延迟执行，但是 html 解析过程中遇到 script 标签仍然会进行下载 
   * defer 脚本会在 dom 解析完成后，DOMContentLoaded事件调用前执行，而且 defer 属性的 js 脚本会按照顺序执行，即在 dom 解析完成后会依次执行 script标签

   **script的async属性**

   * 给 script 标签添加 async 属性，适用于 js 与 dom 和其他 js 文件无关的情况 
   * 添加 defer 属性会将 Javascript 脚本异步执行，html 解析过程中遇到 script 标签会进行下载，且下载完成后立即进行异步执行
   * 由于是异步执行，所以当有多个异步的 js 脚本时无法控制先后执行的顺序，所以有多个异步 js 时，这些 js 不要互相有引用
   * 由于添加 async 属性，使 js 在下载完成后立即执行，所以为了在该 js 中不要进行 dom 的相关操作

3. 渲染树( render tree )的构建过程

	1. 从 dom 树的根节点开始遍历每一个可见的节点；例如引用 css 文件的 link 标签、引入js 文件的 script 标签和 css 属性设置了 display: none; 的节点
	2. 从 css 规则树 (style rules) 中找到对应的节点，然后根据节点信息和样式组合成渲染树( render tree )

### 重绘和回流 如何避免?

什么是重绘 Repaint 和重排（回流 reflow）

<font color=cc3355>**重绘**</font>

重绘: 当元素需要更新样式，但是这些样式属性只是改变元素的外观, 风格, 而不会引起布局变化的，只需要浏览器

根据元素的新属性重新绘制，使元素呈现新的外观叫做重绘。

<font color=cc3355>**回流**</font>

回流: 当 render 树中的一部分或者全部因为元素的规模尺寸, 布局, 隐藏等改变而需要重新构建, 这就称之为回流,

<font color=cc3355>**首次加载触发重绘与回流**</font>

每个页面至少一次回流, 就是在页面第一次加载的时候, 这时候是一定会发生回流, 因为要构建 render 树, 在回流的时候, 浏览器会使渲染树中受到影响的部分失效, 并重新构造这部分渲染树, 完成回流后, 浏览器会重新绘制受影响的部分到屏幕中, 该过程称为重绘

重绘不一定需要回流（比如颜色的改变），回流必然导致重绘（比如改变网页位置）

<font color=cc3355>**导致重绘与回流的操作**</font>

重绘

* 修改文本颜色
* 修改文本样式

回流

* 首次加载
* 浏览器窗口大小发生改变
* 元素的尺寸,位置发生改变 ( 边距, 宽高 )
* 元素的内容发生改变
* 删除添加可见元素

<font color=cc3355>**减少重绘与回流**</font>

1. 需要要对元素进行复杂的操作时，可以先隐藏(display:"none")，操作完成后再显示

2. 尽量避免用 table 布局（table 元素一旦触发回流就会导致 table 里所有的其它元素回流）

3. 避免使用 css 表达式(expression)，因为每次调用都会重新计算值（包括加载页面）

4. 尽量使用 css 属性简写，如：用 border 代替 border-width, border-style, border-color

5. 批量修改元素样式：elem.className 和 elem.style.cssText 代替 elem.style.xxx

### 常用的数组方法有哪些？

<font color=cc3355>**reverse( )**</font>方法将数组中元素的位置颠倒，并返回该数组。该方法会改变原数组。

<font color=cc3355>**sort( )**</font>方法用[原地算法]对数组的元素进行排序，并返回数组。默认排序顺序是在将元素转换为字符串，然后比较它们的UTF-16代码单元值序列时构建的

<font color=cc3355>**concat( )**</font> 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。

<font color=cc3355>**find( )**</font>方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 [`undefined`]

<font color=cc3355>**findIndex**</font>方法返回数组中满足提供的测试函数的第一个元素的**索引**。否则返回-1。

<font color=cc3355>**includes**</font>方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。

<font color=cc3355>**indexOf**</font>方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。 （通常用它判断数组中有没有这个元素）

<font color=cc3355>**join**</font> 方法将一个数组（或一个[类数组对象]）的所有元素连接成一个字符串并返回这个字符串。如果数组只有一个项目，那么将返回该项目而不使用分隔符。

<font color=cc3355>**pop**</font>方法从数组中删除最后一个元素，并返回该元素的值。此方法更改数组的长度。

<font color=cc3355>**push**</font>方法将一个或多个元素添加到数组的末尾，并返回该数组的新长度。

<font color=cc3355>**shift**</font>方法从数组中删除**第一个**元素，并返回该元素的值。此方法更改数组的长度。

<font color=cc3355>**unshift( )**</font>方法将一个或多个元素添加到数组的**开头**，并返回该数组的**新长度(该**方法修改原有数组**)**。

<font color=cc3355>**splice( )**</font>方法通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。此方法会改变原数组。由被删除的元素组成的一个数组。如果只删除了一个元素，则返回只包含一个元素的数组。如果没有删除元素，则返回空数组。

### 数组有哪几种循环方式？分别有什么作用？
<font color=cc3355>**map( )**</font>方法 映射数组。 对数组每一个元素进行映射处理，得到一个全新数组

<font color=cc3355>**filter( )**</font>方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。

<font color=cc3355>**forEach( )**</font>方法对数组的每个元素执行一次提供的函数。

<font color=cc3355>**some( )**</font>方法测试是否至少有一个元素可以通过被提供的函数方法。该方法返回一个Boolean类型的值。

<font color=cc3355>**every( )**</font>方法测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。

<font color=cc3355>**findIndex( )**</font>方法获取某个元素下标 可以深度查找, findIndex一般用于对象数组

<font color=cc3355>**reduce( )**</font>方法 逐个遍历数组元素，每一步都将当前元素的值与上一步的计算结果相加  参数1上次返回的结果, 参数2当前元素, 参数3当前元素的下标


### 常用的字符串方法有哪些？

<font color=cc3355>**trim( )**</font>方法会从一个字符串的两端删除空白字符。在这个上下文中的空白字符是所有的空白字符 (space, tab, no-break space 等) 以及所有行终止符字符（如 LF，CR）。

<font color=cc3355>**charAt( )**</font>方法从一个字符串中返回指定位置的字符。

<font color=cc3355>**concat( )**</font>方法将一个或多个字符串与原字符串连接合并，形成一个新的字符串并返回。

<font color=cc3355>**includes( )**</font>方法用于判断一个字符串是否包含在另一个字符串中，根据情况返回 true 或 false。

<font color=cc3355>**indexOf( ) **</font>方法返回调用它的 [`String`] 对象中第一次出现的指定值的索引，从 `fromIndex` 处进行搜索。如果未找到该值，则返回 -1。

<font color=cc3355>**match( )**</font>方法检索返回一个字符串匹配正则表达式的的结果。

<font color=cc3355>**padStart( )**</font>方法用另一个字符串填充当前字符串(重复，如果需要的话)，以便产生的字符串达到给定的长度。填充从当前字符串的开始(左侧)应用的。 (常用于时间补0)

<font color=cc3355>**replace( )**</font>方法返回一个由替换值（`replacement`）替换一些或所有匹配的模式（`pattern`）后的新字符串。模式可以是一个字符串或者一个[正则表达式]，替换值可以是一个字符串或者一个每次匹配都要调用的回调函数。

原字符串不会改变。

<font color=cc3355>**slice( )**</font>方法提取某个字符串的一部分，并返回一个新的字符串，且不会改动原字符串。

<font color=cc3355>**split( )**</font>方法使用指定的分隔符字符串将一个[`String`]对象分割成字符串数组，以将字符串分隔为子字符串，以确定每个拆分的位置。 

<font color=cc3355>**substr( )**</font>方法返回一个字符串中从指定位置开始到指定字符数的字符。

### 什么是原型链？

原型链是一种查找规则

为对象成员查找机制提供一个方向

因为构造函数的 prototype 和其实例的 __ proto __ 都是指向原型对象的

所以可以通过`__proto__` 查找当前的原型对象有没有该属性,

没有就找原型的原型, 依次类推一直找到Object( null ) 为止

这种链式查找过程称之为原型链 

### 什么是闭包？手写一个闭包函数？ 闭包有哪些优缺点？

闭包（closure）指有权访问另一个函数作用域中变量的函数。简单理解就是 ，一个作用 

域可以访问另外一个函数内部的局部变量。

```javascript
function fn() {
    var num = 10;
    function fun() {
        console.log(num); 
    }
    return fun;
}
var f = fn(); 
f();
```

优点: 延长变量作用域、在函数的外部可以访问函数内部的局部变量，

缺点: 容易造成内层泄露，因为闭包中的局部变量永远不会被回收 解决方法: 需要手动清除 把变量变为null

### 继承

Call 式继承继承的是属性，原型继承继承的是方法。

> // #1 Call 式继承 / 构造函数继承：继承的是属性
> Person.call(this, name, age)
> // #2 原型继承：继承的是方法
> Star.prototype = new Person()
> Star.prototype.constructor = Star

<font color=cc3355>**原型链继承**</font>

将需要继承的对象挂到当前对象的原型对象上面, 通过原型链访问

子类的原型对象 = 父类的构造函数创建出的对象

特点：1、实例可继承的属性有：实例的构造函数的属性，父类构造函数属性，父类原型的属性。（新实例不会继承父类实例的属性！

缺点：1、新实例无法向父类构造函数传参。

　　　2、继承单一。

　　　3、所有新实例都会共享父类实例的属性。（原型上的属性是共享的，一个实例修改了原型属性，另一个实例的原   型属性也会被修改！）

混合式继承

1. 遍历父对象成员, 添加给子对象构造函数的原型
   * 特点: 多个对象继承, 不会覆盖原来的默认原型
   * 缺点: 代码量增多

<font color=cc3355>**ES6 class类实现继承**</font>

```js
// 创建一个父类
    class father {
      // 在 constructor 里面定义实例
      constructor(house, car) {
        this.house = house
        this.car = car
      }
      // 在外面定义方法
      sayHi() {
        console.log('你好啊')
      }
    }

    // 实例化 father
    const f = new father('汤臣一品', '劳斯莱斯')
    console.log(f)

    // 子类继承父类
    class son extends father {
      // 如果没有提供构造函数, 在继承时, 会默认自动借调父构造函数	
      constructor(house, car, study) {
        // 你写的构造函数中, 没有借调父构造函数
        super(house, car) // 触发调用父构造函数, 进行实例的属性初始化
        this.study = 'study'
      }
      work() {
        console.log('找乐子')
      }
    }
    // 实例化 son
    const s = new son('乐高一号', '跑跑卡丁车', '做美食')
    console.log(s)
```



通过`class`声明一个类，`constructor()`作为构造函数，属性在`constructor()`中初始化

可以在`class`内定义非静态方法，静态方法绑定在构造器上

类的所有方法都是不可枚举的，也符合内部方法

实例化一个`class`必须要`new`关键字

`extends`实现继承，子类中调用`super()`访问父类构造函数

### 请描述一下ES6中的class类? 

es6中的class可以把它看成是es5中构造函数的语法糖，它简化了构造函数的写法， 类的共有属性放到 constructor 里面 

1. 通过class 关键字创建类, 类名我们还是习惯性定义首字母大写 

2. 类里面有个constructor 函数,可以接受传递过来的参数,同时返回实例对象 

3. constructor 函数 只要 new 生成实例时,就会自动调用这个函数, 如果我们不写这个函数,类也会自动生成这个函数 

4. 多个函数方法之间不需要添加逗号分隔 

5. 生成实例 new 不能省略 

6. 语法规范, 创建类 类名后面不要加小括号,生成实例 类名后面加小括号, 构造函数不需要加function 

   1. 继承中,如果实例化子类输出一个方法,先看子类有没有这个方法,如果有就先执行子类的 

   2. 继承中,如果子类里面没有,就去查找父类有没有这个方法,如果有,就执行父类的这个方法(就近原则) 

   3. 如果子类想要继承父类的方法,同时在自己内部扩展自己的方法,利用super 调用 父类的构造函数,super 必须在子类this之前调用 

7. 时刻注意this的指向问题,类里面的共有的属性和方法一定要加this使用. 

   1. constructor中的this指向的是new出来的实例对象 

   2. 自定义的方法,一般也指向的new出来的实例对象 

   3. 绑定事件之后this指向的就是触发事件的事件源 

   4. 在 ES6 中类没有变量提升，所以必须先定义类，才能通过类实例化对象

### cookie 、localstorage 、 sessionstrorage 之间有什么区别？

- 与服务器交互：
  - cookie 是网站为了标示用户身份而储存在用户本地终端上的数据（通常经过加密）
  - cookie 始终会在同源 http 请求头中携带（即使不需要），在浏览器和服务器间来回传递
  - sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存
- 存储大小：

- cookie 数据根据不同浏览器限制，大小一般不能超过 4k
- sessionStorage 和 localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大

- 有期时间：
  - localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据
  - sessionStorage 数据在当前浏览器窗口关闭后自动删除
  - cookie 设置的cookie过期时间之前一直有效，与浏览器是否关闭无关

### this 的指向有哪些？

1、普通函数中的this指向window

2、定时器中的this指向window

3、箭头函数没有this,它的this指向取决于外部环境、

4、事件中的this指向事件的调用者

5、 构造函数中this和原型对象中的this,都是指向构造函数new 出来实例对象

6、类 class中的this  指向由constructor构造器new出来的实例对象

7、自调用函数中的this  指向window



### 什么是递归，递归有哪些优点或缺点？

递归：如果一个函数在内部可以调用其本身，那么这个函数就是递归函数。简单理解:函 

数内部自己调用自己, 这个函数就是递归函数 

优点：结构清晰、可读性强

缺点：效率低、调用栈可能会溢出，其实每一次函数调用会在内存栈中分配空间，而每个进程的栈的容量是有限的，当调用的层次太多时，就会超出栈的容量，从而导致栈溢出。->性能

### 谈谈你平时都用了哪些方法进行性能优化？

减少http请求次数、打包压缩上线代码、使用懒加载、使用雪碧图、动态渲染组件、CDN加载包。

### 什么是深拷贝、什么是浅拷贝？

浅拷贝：创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。

深拷贝会拷贝所有的属性，并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。拷贝前后两个对象互不影响。



### 请写至少三种数组去重的方法？（原生js）

```javascript
//利用filter
function unique(arr) {
  return arr.filter(function(item, index, arr) {
    //当前元素，在原始数组中的第一个索引==当前索引值，否则返回当前元素
    return arr.indexOf(item, 0) === index;
  });
}
    var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
        console.log(unique(arr))
```

```javascript
//利用ES6 Set去重（ES6中最常用）
function unique (arr) {
  return Array.from(new Set(arr))
}
var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
console.log(unique(arr))
 //[1, "true", true, 15, false, undefined, null, NaN, "NaN", 0, "a", {}, {}]
```

```javascript
//利用for嵌套for，然后splice去重（ES5中最常用）
function unique(arr){            
        for(var i=0; i<arr.length; i++){
            for(var j=i+1; j<arr.length; j++){
                if(arr[i]==arr[j]){         //第一个等同于第二个，splice方法删除第二个
                    arr.splice(j,1);
                    j--;
                }
            }
        }
return arr;
}
var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
    console.log(unique(arr))
    //[1, "true", 15, false, undefined, NaN, NaN, "NaN", "a", {…}, {…}]     //NaN和{}没有去重，两个null直接消失了
```

### 请写出至少两种常见的数组排序的方法（原生js）

```javascript
//快速排序
function quickSort(elements){
    if(elements.length <=1){
      return elements;  
    }
  var pivotIndex=Math.floor(elements.length / 2);
  var pivot=elements.splice(pivotIndex,1)[0];
  var left=[];
  var right=[];
  for(var i=0;i<elements.length;i++){
    if(elements[i] < pivot){
        left.push(elements[i]);
    }else{
       right.push(elements[i]);
    }
  } 
return  quickSort(left).concat([pivot],quickSort(right));
//concat()方法用于连接两个或者多个数组；该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。
};
var elements=[3,5,6,8,2,4,7,9,1,10];
document.write(quickSort(elements)); 

```

```javascript
//插入排序
function sort(elements){
    // 假设第0个元素是一个有序数列，第1个以后的是无序数列，
    // 所以从第1个元素开始将无序数列的元素插入到有序数列中去
    for (var i =1; i<=elements.length; i++) {
        // 升序
        if(elements[i] < elements[i-1]){
            // 取出无序数列中的第i个作为被插入元素
            var guard=elements[i];
            //记住有序数列的最后一个位置，并且将有序数列的位置扩大一个
            var j=i-1;
            elements[i]=elements[j];
            // 比大小;找到被插入元素所在位置
            while (j>=0 && guard <elements[j]) {
                elements[j+1]=elements[j];
                j--;
            }
            elements[j+1]=guard; //插入
        }
    }
}
var elements=[3,5,6,8,2,4,7,9,1,10];
document.write('没调用之前：'+elements);
document.write('<br>');
sort(elements);
document.write('被调用之后：'+elements);
```

```javascript
//冒泡排序
function sort(elements){
    for(var i=0;i<elements.length-1;i++){
       for(var j=0;j<elements.length-1-i;j++){
          if(elements[j] > elements[j+1]){
               var  swap=elements[j];
               elements[j]=elements[j+1];
               elements[j+1]=swap;
          }
       }
    }
}
var elements=[3,5,6,8,2,4,7,9,1,10];
console.log('before'+elements);
sort(elements);
console.log('after'+elements);
```



### 知道lodash吗？它有哪些常见的API   ？

Lodash是一个一致性、模块化、高性能的 JavaScript 实用工具库。

_.cloneDeep     深度拷贝

_.reject    根据条件去除某个元素。

_.drop(array, [n=1] )   作用：将 `array` 中的前 `n` 个元素去掉，然后返回剩余的部分.

### 平时都是用那些工具进行打包的？babel是什么？

WebPack 是一个模块打包工具，你可以使用WebPack管理你的模块依赖，并编绎输出模块们所需的静态文件。它能够很好地管理、打包Web开发中所用到的HTML、Javascript、CSS以及各种静态文件（图片、字体等），让开发过程更加高效。对于不同类型的资源，webpack有对应的模块加载器。webpack模块打包器会分析模块间的依赖关系，最后 生成了优化且合并后的静态资源

babel可以帮助我们转换一些当前浏览器不支持的语法，它会把这些语法转换为低版本的语法以便浏览器识别。

### 谈谈set 、 map 是什么？ 

set 是es6 提供的一种新的数据结构，它类似于数组，但是成员的值都是唯一的。

map 是es6 提供的一种新的数据结构,它类似于对象，也是键值对的集合，但是键的范围不仅限于字符串，各种类型的值都可以当做键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。



### 图片懒加载是怎么实现的？

就是我们先设置图片的data-set属性（当然也可以是其他任意的，只要不会发送http请求就行了，作用就是为了存取值）值为其图片路径，由于不是src，所以不会发送http请求。 然后我们计算出页面scrollTop的高度和浏览器的高度之和， 如果图片距离页面顶端的坐标Y（相对于整个页面，而不是浏览器窗口）小于前两者之和，就说明图片就要显示出来了（合适的时机，当然也可以是其他情况），这时候我们再将 data-set 属性替换为 src 属性即可。

### call、apply、bind三者的异同

共同点 : 都可以改变this指向;
不同点:
call,apply会直接调用函数,bind会返回一个新的函数
call,bind可以传递任意多个参数,而apply只能传递两个参数,并且第二个参数只能是数组或伪数组
应用场景

1. call 经常做继承.
2. apply经常跟数组有关系. 比如借助于数学对象实现数组最大值最小值
3. bind 不调用函数,但是还想改变this指向. 比如改变定时器内部的this指向



### for in 和 for of 的区别

`for in`遍历的是数组的索引（即键名），而`for of`遍历的是数组元素值

`for in`可以得到对象的`key`或数组、字符串的下标

`for of`不能直接遍历对象, 可以先通过 `Object.keys` 得到对象的键再获取值

## HTTP

### post和get 请求有哪些区别？

GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符

POST：一般用于修改服务器上的资源，对所发送的信息没有限制。

GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值，也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。

然而，在以下情况中，请使用 POST 请求：

无法使用缓存文件（更新服务器上的文件或数据库）

向服务器发送大量数据（POST 没有数据量限制）

发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠

### http状态码分别代表什么意思？

1xx	表示HTTP请求已经接受，继续处理请求
2xx	表示HTTP请求已经处理完成(200)
3xx	表示把请求访问的URL重定向到其他目录(304资源没有发生变化，会重定向到本地资源)
4xx	表示客户端出现错误(403禁止访问、404资源不存在)
5xx	表示服务端出现错误

301 => 永久重定向/永久转移

302 => 临时重定向/临时转移（一般用来做服务器负载均衡）

304 => 本次获取的内容是读取缓存中的数据，会每次去服务器校验

401 => 未认证，没有登录网站

403 => 禁止访问，没有权限

502 => 充当网关或代理的服务器，从远端服务器接收到了一个无效的请求

503 => 服务器超负荷（假设一台服务器只能承受 10000 人，当第 10001 人访问的时候，

如果服务器没有做负载均衡，那么这个人的网络状态码就是 503）

505 => 服务器不支持请求的 HTTP 协议的版本，无法完成处理。

### http缓存 **缓存分为两种：强缓存和协商缓存**

**1.强缓存：**不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的Network选项中可以看到该请求返回200的状态码，并且size显示from disk cache或from memory cache两种（灰色表示缓存）。

**2.协商缓存：**向服务器发送请求，服务器会根据这个请求的request header的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的response header通知浏览器从缓存中读取资源；

> 共同点：都是从客户端缓存中读取资源；
> 区别是强缓存不会发请求，协商缓存会发请求。

### token是什么？（加密）

1. token也可以称做令牌，一般由 `uid+time+sign(签名)+[固定参数]` 组成

   ```
   uid: 用户唯一身份标识
   time: 当前时间的时间戳
   sign: 签名, 使用 hash/encrypt 压缩成定长的十六进制字符串，以防止第三方恶意拼接
   固定参数(可选): 将一些常用的固定参数加入到 token 中是为了避免重复查库
   ```

2. token在客户端一般存放于localStorage，cookie，或sessionStorage中。在服务器一般存于数据库中

3. token 的认证流程

   ```
   用户登录，成功后服务器返回Token给客户端。
   客户端收到数据后保存在客户端
   客户端再次访问服务器，将token放入headers中 或者每次的请求 参数中
   服务器端采用filter过滤器校验。校验成功则返回请求数据，校验失败则返回错误码
   ```

4. token可以抵抗csrf，cookie+session不行

5. session时有状态的，一般存于服务器内存或硬盘中，当服务器采用分布式或集群时，session就会面对负载均衡问题。负载均衡多服务器的情况，不好确认当前用户是否登录，因为多服务器不共享session

6. 客户端登陆传递信息给服务端，服务端收到后把用户信息加密（token）传给客户端，客户端将token存放于localStroage等容器中。客户端每次访问都传递token，服务端解密token，就知道这个用户是谁了。通过cpu加解密，服务端就不需要存储session占用存储空间，就很好的解决负载均衡多服务器的问题了。这个方法叫做JWT(Json Web Token)

### **一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？**

01.浏览器查找域名对应的IP地址(DNS 查询：浏览器缓存->系统缓存->路由器缓存->ISP DNS 缓存->根域名服务器)

02.浏览器向 Web 服务器发送一个 HTTP 请求（TCP三次握手）

03.服务器 301 重定向（从 [http://example.com](http://example.com/) 重定向到 [http://www.example.com）](http://www.example.com%29/)

04.浏览器跟踪重定向地址，请求另一个带 www 的网址

05.服务器处理请求（通过路由读取资源）

06.服务器返回一个 HTTP 响应（报头中把 Content-type 设置为 'text/html'）

07.浏览器进 DOM 树构建

08.浏览器发送请求获取嵌在 HTML 中的资源（如图片、音频、视频、CSS、JS等）

09.浏览器显示完成页面

10.浏览器发送异步请求

### 什么是同源策略？

所谓同源策略是浏览器的一种安全机制，来限制不同源的网站不能通信。同源就是域名、协议、端口一致。

### 解决跨域问题的方法?

跨域的手段有很多, 主要了解3种解决方案

* JSONP
* CORS
* 服务器代理( webpack代理, Nginx反向代理 )

<font color=cc3355>**JSONP**</font>

经典跨域解决方案, 利用 <script> 标签不受同源策略限制的特性, 网页可以得到从其他来源动态产生的 JSON 数据, 实现跨域效果, JSONP请求一定需要对方的服务器做支持才可以。

<font color=ff9911>**优点**</font>

* 实现简单
* 兼容性好, 可用于解决主流浏览器的跨域数据访问的问题。

<font color=ff9911>**缺点**</font>

* 只支持 GET 请求 ( 因为 <script> 标签只能发送 GET 请求 )
* 存在被 XSS 攻击的可能, 缺乏安全性保证
* 需要服务端配合改造

<font color=ff9911>**实现**</font>

是通过动态创建 script 标签，然后通过标签的 src 属性获取 js 文件中的 js 脚本，该脚本的内容是一个函数调用，参数就是服务器返回的数据，为了处理这些返回的数据，需要事先在页面定义好回调函数，

<font color=ff9911>**注意**</font>

axios中不支持JSONP, 如果在开发过程中, 需要发送 JSONP 请求, 可以使用 jsonp 插件

<font color=cc3355>**CORS**</font>

跨域资源共享 ( CORS ) , 这是目前比较主流的跨域解决方案

CORS：跨域资源共享（CORS）是一种机制；当一个资源访问到另外一个资源(这个资源放在

不同的域名或者不同的协议或者端口)，资源就会发起一个跨域的HTTP请求需要浏览器和服务器同时支持；

1. 整个CORS通信，都是浏览器自动完成。浏览器发现了AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉；
2. 实现CORS的关键是服务器，只要服务器实现了CORS接口，就可以跨源通信
3. 服务器对于不同的请求，处理方式不一样； 有简单请求和非简单请求

<font color=ff9911>**注意**</font>

如果在开发或者上线中遇到了跨域问题, 在不考虑兼容性的问题下 ( IE10+ ) , 优先让后台配置个 CORS解决即可

<font color=cc3355>**代理服务器**</font>

同源策略是浏览器的安全策略, 服务器与浏览器之间, 没有跨域问题! 所以可以利用代理服务器转发请求! 

1. 开发环境的跨域问题 ( 使用 webpack 代理服务器解决 )
   * 配置 devServer 的 proxy 配置项
   * 配置请求地址, 如果请求地址中有这个地址, 就触发代理机制
   * `target`配置要代理的请求地址
   * pathRewrite 路径重写
2. 生产环境的跨域问题( 使用 nginx 服务器代理 )
   * 找到 nginx 文件夹的 conf文件夹, 编译其中的 nginx.conf 文件
   * 找到 server
   * 在server中配置默认跳转路由

### 安全问题 ：CSRF 和 XSS攻击？

`CSRF`（`Cross-site request forgery`）：**跨站请求伪造**。

**方法一、Token 验证：**（用的最多）

1. 服务器发送给客户端一个`token`；
2. 客户端提交的表单中带着这个`token`。
3. 如果这个 `token` 不合法，那么服务器拒绝这个请求。

**方法二：隐藏令牌：**

把 `token` 隐藏在 `http` 的 `head`头中。

方法二和方法一有点像，本质上没有太大区别，只是使用方式上有区别。

> **方法三、Referer 验证：**

`Referer` 指的是页面请求来源。意思是，**只接受本站的请求，服务器才做响应**；如果不是，就拦截



XSS（Cross Site Scripting）`：**跨域脚本攻击**。

**1. 编码**：

对用户输入的数据进行`HTML Entity`编码。

如上图所示，把字符转换成 转义字符。

Encode`的作用是将`$var`等一些字符进行转化，使得浏览器在最终输出结果上是一样的。

比如说这段代码：

```javascript
<script>alert(1)</script>
```

> 若不进行任何处理，则浏览器会执行alert的js操作，实现XSS注入。进行编码处理之后，L在浏览器中的显示结果就是`<script>alert(1)</script>`，实现了将``$var`作为纯文本进行输出，且不引起J`avaScript`的执行。

**2、过滤：**

- 移除用户输入的和事件相关的属性。如`onerror`可以自动触发攻击，还有`onclick`等。（总而言是，过滤掉一些不安全的内容）
- 移除用户输入的`Style`节点、`Script`节点、`Iframe`节点。（尤其是`Script`节点，它可是支持跨域的呀，一定要移除）。

**3、校正**

- 避免直接对`HTML Entity`进行解码。
- 使用`DOM Parse`转换，校正不配对的`DOM`标签。

备注：我们应该去了解一下`DOM Parse`这个概念，它的作用是把文本解析成`DOM`结构。

比较常用的做法是，通过第一步的编码转成文本，然后第三步转成`DOM`对象，然后经过第二步的过滤。

### CSRF 和 XSS 的区别

**区别一：**

- `CSRF`：需要用户先登录网站`A`，获取 `cookie`
- `XSS`：不需要登录。

**区别二：（原理的区别）**

- `CSRF`：是利用网站`A`本身的漏洞，去请求网站`A`的`api`。
- `XSS`：是向网站 `A` 注入 `JS`代码，然后执行 `JS` 里的代码，篡改网站`A`的内容。

### cookie和session 的区别

- 1、cookie数据存放在客户的浏览器上，session数据放在服务器上。
- 2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
  - 考虑到安全应当使用session。
- 3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
  - 考虑到减轻服务器性能方面，应当使用COOKIE。
- 4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。
- 5、所以个人建议：
  - 将登陆信息等重要信息存放为SESSION
  - 其他信息如果需要保留，可以放在COOKIE中

## HTML+CSS

### 移动端适配

1. flax布局 自适应布局

2. rem 适配方案

>rem 是一个相对单位，rem 就是 html 根文字的大小
>
>通过媒体查询可以检测视口宽度 然后根据不同视口宽度, 设置不同的根字号完成适配
>
>手淘方案, 
>
>* 拿到设计稿除以10, 得到 font-size 基础值, 
>* 引入flexible
>* 设计稿 px/font-size 基准值, 即可换算为rem
>* 需要通过设计稿进行基准值换算 

3. vw/vh 适配方案

> vw就是视口的宽度，vw 是个相对单位。  
>
> 不管在什么屏幕下， 我们把屏幕分为平均的 100等份。 

### less 和 sass 区别

1. `Sass` (Syntactically Awesome Stylesheets)是一种`动态样式语言`，Sass语法属于缩排语法，比css比多出好些功能(如变量、嵌套、运算,混入(Mixin)、继承、颜色处理，函数等)，更容易阅读。

   Sass与Scss是什么关系?

   Sass的缩排语法，对于写惯css前端的web开发者来说很不直观，也不能将css代码加入到Sass里面，因此sass语法进行了改良，Sass 3就变成了Scss(sassy css)。与原来的语法兼容，只是用{}取代了原来的缩进。

2. `Less`也是一种`动态样式语言`. 对CSS赋予了动态语言的特性，如**变量**，**继承**，**运算**， **函数**.  Less 既可以在**客户端**上运行 (支持IE 6+, Webkit, Firefox)，也可在**服务端**运行 (借助 Node.js)。

### 谈谈盒子模型？

在**标准盒子模型**中，**width 和 height 指的是内容区域**的宽度和高度。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。

**IE盒子模型**中，**width 和 height 指的是内容区域+border+padding**的宽度和高度。

### BFC是什么？

BFC（会计格式化上下文），一个创建了新的BFC的盒子是独立布局的，盒子内元素的布局不会影响盒子外面的元素。在同一个BFC中的两个相邻的盒子在垂直方向发生margin重叠的问题。

BFC是值浏览器中创建了一个独立的渲染区域，该区域内所有元素的布局不会影响到区域外元素的布局，这个渲染区域只对块级元素起作用

### 常见的盒子垂直居中的方法有哪些请举例3种？

利用子绝父相定位的方式来实现

```css
#container{
    width:500px;
    height:500px;
    position:relative;
}
#center{
    width:100px;
    hight:100px;
     position: absolute;
     top: 50%;
     left: 50%;
    margin-top:-50px;
    margin-left:-50px;
    
}
```

利用Css3的transform，可以轻松的在未知元素的高宽的情况下实现元素的垂直居中。

```css
#container{
    position:relative;
}
#center{
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}
```



flex

```css
#container{
    display:flex;
    justify-content:center;
    align-items: center;
}

#center{

}
```

### 清除浮动的方法有哪些？

为什么要清除浮动，因为浮动的盒子脱离标准流，如果父盒子没有设置高度的话，下面的盒子就会撑上来。

1.额外标签法（在最后一个浮动标签后，新加一个标签，给其设置clear：both；）（不推荐）

2.父级添加overflow属性（父元素添加overflow:hidden）（不推荐）

3.使用after伪元素清除浮动（推荐使用）

```css
    .clearfix:after{/*伪元素是行内元素 正常浏览器清除浮动方法*/
        content: "";
        display: block;
        height: 0;
        clear:both;
        visibility: hidden;
    }
    .clearfix{
        *zoom: 1;/*ie6清除浮动的方式 *号只有IE6-IE7执行，其他浏览器不执行*/
｝
```

4.使用before和after双伪元素清除浮动

```css
 .clearfix:after,.clearfix:before{
        content: "";
        display: table;
    }
    .clearfix:after{
        clear: both;
    }
    .clearfix{
        *zoom: 1;
    }

```



### 常见的布局方法有哪些？他们的优缺点是什么？

页面布局常用的方法有浮动、定位、flex、grid网格布局、栅格系统布局

浮动：

- 优点：兼容性好。
- 缺点：浮动会脱离标准文档流，因此要清除浮动。我们解决好这个问题即可。

绝对定位

- 优点：快捷。
- 缺点：导致子元素也脱离了标准文档流，可实用性差。

flex 布局（CSS3中出现的）

- 优点：解决上面两个方法的不足，flex布局比较完美。移动端基本用 flex布局。

网格布局（grid）

- CSS3中引入的布局，很好用。代码量简化了很多。

利用网格布局实现的一个左右300px中间自适应的布局

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <style>
        html * {
            padding: 0;
            margin: 0;
        }
        /* 重要：设置容器为网格布局，宽度为100% */
        .layout.grid .left-center-right {
            display: grid;
            width: 100%;
            grid-template-rows: 100px;
            grid-template-columns: 300px auto 300px;  /* 重要：设置网格为三列，并设置每列的宽度。即可。*/
        }
        .layout.grid .left {
            background: red;
        }
        .layout.grid .center {
            background: green;
        }
        .layout.grid .right {
            background: blue;
        }
    </style>
</head>
<body>
    <section class="layout grid">
        <article class="left-center-right">
            <div class="left">
                我是 left
            </div>
            <div class="center">
                <h1>网格布局解决方案</h1>
                我是 center
            </div>
            <div class="right">
                我是 right
            </div>
        </article>
    </section>
</body>
</html>
```

栅格系统布局

​    优点：可以适用于多端设备

### 移动端有哪些常见的问题，都是怎么解决的？

点击事件300MS延迟问题  解决方案：下载fastclick的包

 **H5页面窗口自动调整到设备宽度，并禁止用户缩放页面**

```html
<meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"> 
```

**忽略Android平台中对邮箱地址的识别**

```html
<meta name="format-detection" content="email=no"> 
```

**当网站添加到主屏幕快速启动方式，可隐藏地址栏，仅针对ios的safari**

```html
<!-- ios7.0版本以后，safari上已看不到效果 -->

<meta name="apple-mobile-web-app-capable" content="yes">
```

### 

## 项目问题

### 遇到哪些技术问题 是怎么解决的

### 在上一家公司的收获

1. 刚进公司的时候也不是很懂, 就会三剑客+jq, vue使用的也不熟练, 公司肯定也不会让我进项目啊, 老大让我把vue给熟练使用起来, 于是就开始看官方文档啊, 看技术博客啊, 请教公司前辈啊, 又写了一个多月的demo吧, 之后老大给我个模块让我试着做一下, 老大看我做的不错才让我进项目组, 开始接需求做
2. 刚开始只会三剑客慢慢转变到使用框架开发
3. 从写demo到实际项目开发

### 未来的职业规划

1. 三年的职业规划 
   * 现在当前岗位沉淀下来继续巩固技术争取能达到中高级工程师水平
2. 五年的职业规划
   * 学学后端语言吧, 想把前后端跑通
3. 那些可能性会影响你的发展
   * 家庭吧, 三年后也二十五六了要考虑考虑这些事了, 当然现在不考虑这些

### 离职原因是什么

由于上一家公司是在济南吗, 感觉济南的互联网环境不是特别好, 技术更新的也不是很快, 加上朋友们都在这边, 也推荐我来,自己也想努力一下,看看能不能在大城市生存下去

### 后台管理系统中的权限管理是怎么实现的？

登录：当用户填写完账号和密码后向服务端验证是否正确，验证通过之后，服务端会返回一个**token**，拿到token之后（我会将这个token存贮到cookie中，保证刷新页面后能记住用户登录状态），前端会根据token再去拉取一个 **user_info** 的接口来获取用户的详细信息（如用户权限，用户名等等信息）。

权限验证：通过token获取用户对应的 权限，动态根据用户的 权限算出其对应有权限的路由，通过 **router.addRoutes** 动态挂载这些路由。

具体思路：

登录成功后，服务端会返回一个 **token**（该token的是一个能唯一标示用户身份的一个key），之后我们将token存储在本地cookie之中，这样下次打开页面或者刷新页面的时候能记住用户的登录状态，不用再去登录页面重新登录了。

ps:为了保证安全性，我司现在后台所有token有效期(Expires/Max-Age)都是Session，就是当浏览器关闭了就丢失了。重新打开游览器都需要重新登录验证，后端也会在每周固定一个时间点重新刷新token，让后台用户全部重新登录一次，确保后台用户不会因为电脑遗失或者其它原因被人随意使用账号。

用户登录成功之后，我们会在全局钩子`router.beforeEach`中拦截路由，判断是否已获得token，在获得token之后我们就要去获取用户的基本信息了

页面会先从 cookie 中查看是否存有 token，没有，就走一遍上一部分的流程重新登录，如果有token,就会把这个 token 返给后端去拉取user_info，保证用户信息是最新的。 当然如果是做了单点登录得功能的话，用户信息存储在本地也是可以的。当你一台电脑登录时，另一台会被提下线，所以总会重新登录获取最新的内容。

先说一说我权限控制的主体思路，前端会有一份路由表，它表示了每一个路由可访问的权限。当用户登录之后，通过 **token** 获取用户的 **role** ，动态根据用户的 **role** 算出其对应有权限的路由，再通过`router.addRoutes`动态挂载路由。但这些控制都只是页面级的，说白了前端再怎么做权限控制都不是绝对安全的，后端的权限验证是逃不掉的。

我司现在就是前端来控制页面级的权限，不同权限的用户显示不同的侧边栏和限制其所能进入的页面(也做了少许按钮级别的权限控制)，后端则会验证每一个涉及请求的操作，验证其是否有该操作的权限，每一个后台的请求不管是 get 还是 post 都会让前端在请求 `header`里面携带用户的 **token**，后端会根据该 **token** 来验证用户是否有权限执行该操作。若没有权限则抛出一个对应的状态码，前端检测到该状态码，做出相对应的操作。

使用vuex管理路由表，根据vuex中可访问的路由渲染侧边栏组件。

具体实现：

创建vue实例的时候将vue-router挂载，但这个时候vue-router挂载一些登录或者不用权限的公用的页面。

当用户登录后，获取用role，将role和路由表每个页面的需要的权限作比较，生成最终用户可访问的路由表。

调用router.addRoutes(store.getters.addRouters)添加用户可访问的路由。

使用vuex管理路由表，根据vuex中可访问的路由渲染侧边栏组件。

### 前端怎么做SEO优化

<font color=cc3355>**什么是SEO**</font>

SEO(Search Engine Optimization)，即搜索引擎优化。SEO是随着搜索引擎的出现而来的，两者是相互促进，互利共生的关系。SEO的存在就是为了提升网页在搜索引擎自然搜索结果中的收录数量以及排序位置而做的优化行为。而优化的目的就是为了提升网站在搜索引擎中的权重，增加对搜索引擎的友好度，使得用户在访问网站时能排在前面。

<font color=cc3355>**为什么要做SEO**</font>

提高网站的权重，增强搜索引擎友好度，以达到提高排名，增加流量，改善（潜在）用户体验，促进销售的作用。

<font color=cc3355>**前端怎么做SEO优化**</font>

1. 网站结构布局优化: 尽量简单
   * 控制首页链接数量
   * 网页层级不要太深
   * 控制页面大小, 减少HTTP请求, 提高网站的加载速度
   * 尽量使用语义化标签
   * 利用浏览器缓存

## YQD

## HTML5 & CSS3

### css 的盒子模型

css的盒子模型有两种,一种是W3C标准的标准盒子模型,一种是IE标准的怪异盒子模型

标准盒子模型由:margin padding border width 组成,其宽度为内容的宽度

怪异盒子模型同样也是由:margin padding border width 组成,但是它的宽度为 padding+border+width

在实际开发中我们不想盒子被撑大,可以给其设置 box-sizing = border-box

[参考文章：深入理解盒模型](https://www.cnblogs.com/xiaohuochai/p/5202597.html)

### 浮动带来的影响及如何清除浮动

浮动的出现是为了让块级元素在一行显示且无缝隙.

浮动会使元素脱离标准流,使元素浮在标准流之上,不占位置,使父元素的高度无法撑开,从而影响布局.

清除浮动常用的方法有 5 种:

(1)给父元素设置高度

(2)overflow:hidden;

(3)额外标签法: 在父元素的最后面添加一个块级标签,并使用 clear:both;

(4)单伪元素法

```css
.clearfix::after {
	content: '';
	display: block;
	clear: both;
	height: 0;
	visibility: hidden;
}
/*兼容ie6 ie7*/
.clearfix {
	*zoom: 1
}
```

(5)双伪元素法

```css
.clearfix::before,
.clearfix::after {
	content: '';
	display: table;
}
.clearfix::after {
	clear: both;
}
/*兼容ie6 ie7*/
.clearfix {
	*zoom: 1
}
```

### 常见的布局方法有哪些？他们的优缺点是什么？

页面布局常用的方法有浮动、定位、flex、`grid网格布局`、`栅格系统布局`

浮动：

- 优点：兼容性好。
- 缺点：浮动会脱离标准文档流，因此要清除浮动。我们解决好这个问题即可。

绝对定位

- 优点：快捷。
- 缺点：导致子元素也脱离了标准文档流，可实用性差。

flex 布局（CSS3中出现的）

- 优点：解决上面两个方法的不足，flex布局比较完美。移动端基本用 flex布局。

网格布局（grid）

- CSS3中引入的布局，很好用。代码量简化了很多。

利用网格布局实现的一个左右300px中间自适应的布局

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <style>
        html * {
            padding: 0;
            margin: 0;
        }
        /* 重要：设置容器为网格布局，宽度为100% */
        .layout.grid .left-center-right {
            display: grid;
            width: 100%;
            grid-template-rows: 100px;
            grid-template-columns: 300px auto 300px;  /* 重要：设置网格为三列，并设置每列的宽度。即可。*/
        }
        .layout.grid .left {
            background: red;
        }
        .layout.grid .center {
            background: green;
        }
        .layout.grid .right {
            background: blue;
        }
    </style>
</head>
<body>
    <section class="layout grid">
        <article class="left-center-right">
            <div class="left">
                我是 left
            </div>
            <div class="center">
                <h1>网格布局解决方案</h1>
                我是 center
            </div>
            <div class="right">
                我是 right
            </div>
        </article>
    </section>
</body>
</html>
```

栅格系统布局

​    优点：可以适用于多端设备

### flex布局

flex布局极大的提高了我们布局的效率,更简单、灵活.

在flex布局中,没有块级元素,行内元素,行内块元素之分,任何元素都可以直接设置宽高和在一行显示.

同时,flex布局中也不存在脱标的情况,这样一来可以很好的迭代掉 float 不用去考虑脱标和清除浮动的问题.

当然flex也存在一些兼容性问题,再不考率问题的时候可以优先考虑 flex 布局.



在真实的应用场景中，通常会遇到各种各样不同尺⼨和分辨率的设备，为了能在所有这些设备上正常的布局我们的应用界面，就需要响应式的界⾯设计方式来满⾜这种复杂的布局需求。

flex 弹性盒模型的优势在于开发⼈员只需要声明布局应该具有的⾏为，⽽不需要给出具体的实现⽅式，浏览器负责完成实际布局，当布局涉及到不定宽度，分布对⻬的场景时，就要优先考虑弹性盒布局。 

你能联想到的flex语法有哪些呢?

flex-direction: 调整主轴方向

```txt
row：主轴方向为水平向右
column：主轴方向为竖直向下
row-reverse:主轴方向为水平向左
column-reverse:主轴方向是竖直向上。
```

justify-content主要用来设置**主轴方向的对齐方式**

```
flex-start: 弹性盒子元素将向起始位置对齐
flex-end: 弹性盒子元素将向结束位置对齐。
center: 弹性盒子元素将向行中间位置对齐
space-around: 弹性盒子元素会平均地分布在行里
space-between:第一个贴左边，最后一个贴右边，其他盒子均分，保证每个盒子之间的空隙是相等的。
```

align-items用于调整**侧轴的对齐方式**

```txt
flex-start： 元素在侧轴的起始位置对齐。 
flex-end： 元素在侧轴的结束位置对齐。
center： 元素在侧轴上居中对齐。
stretch： 元素的高度会被拉伸到最大（不给高度时, 才拉伸）。
```

flex-wrap属性控制flex容器是单行或者多行,默认不换行

```txt
nowrap： 不换行（默认），如果宽度溢出，会压缩子盒子的宽度。
wrap： 当宽度不够的时候，会换行。
```

align-content用来设置多行的flex容器的排列方式

```txt
flex-start： 各行向侧轴的起始位置堆叠。 
flex-end： 各行向弹性盒容器的结束位置堆叠。
center： 各行向弹性盒容器的中间位置堆叠。
space-around： 各行在侧轴中平均分布。 
space-between： 第一行贴上边，最后一个行贴下边,其他行在弹性盒容器中平均分布。 
stretch：拉伸，不设置高度的情况下。
```

> 可参考 [flex布局教程](http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html)

### 元素居中有哪些方式

使元素居中常见的方法有 5 种:

(1)父盒子与子盒子的距离: 这种方法比较直接但是复用性不强

(2)利用 margin:auto; 对于块级元素这种方法时适用的,但是行内元素不适用

(3)利用定位: 可以说是万金油的办法

(4)利用 transform 位移: 结合子绝父相定位,给子元素设置 top: 50%; left: 50%; transform: translate(-50%, -50%); transform和 margin的最大区别是 transform 平移的时候对其他的元素没有影响;而 margin 会把其他元素挤走

(5)flex布局: 父元素设置 display:flex; justify-content: center;  align-items: center; CSS3之后如果没有兼容性问题,首先推荐的就是 flex 布局

### 在 CSS 中有哪些定位方式？

也就是 position 样式的几个属性。

**static 正常文档流定位**

- 此时设置 top、right、bottom、left 以及 z-index 都无效

- 块级元素遵循从上往下纵向排列，行级元素遵循从左到右排列

**relative 相对定位**

这个 **“相对”** 是指相对于正常文档流的位置。

**absolute 绝对定位**

当前元素相对于 **最近的非 static 定位的祖先元素 **来确定自己的偏移位置。

例如，当前为 absolute 的元素的父元素、祖父元素都为 relative，则当前元素会相对于父元素进行偏移定位。

**fixed 固定定位**

当前元素相对于屏幕视口 viewport 来确定自己的位置。并且当屏幕滚动时，当前元素的位置也不会发生改变。

**sticky 粘性定位**

这个定位方式有点像 relative 和 fixed 的结合。当它的父元素在视口区域、并进入 top 值给定的范围内时，当前元素就以 fixed 的方式进行定位，否则就以 relative 的方式进行定位。

### 列举一些常用的C3 选择器

常用的CSS3的有 6 类

(1)基本选择器: 通配符*, 标签选择器, 类选择器, id选择器

(2)层次选择器(也叫关系选择器): 后代选择器, 子代选择器, 交集选择器, 并集选择器, 伪类选择器

(3)动态伪类选择器: 

E:link 超链接没有被访问过时的状态

E:visited 超链接访问过后的状态

E:hover 鼠标滑过(鼠标悬停在E上)时的状态

E:active 鼠标按下(E元素被激活)时的状态

E:focus 光标聚焦时触发的状态

(4)结构性伪类选择器: :first-child, last-child, :nth-child(n), :nth-last-child(n), 

:empty 匹配内容为空的元素(空格，回车换行符都不能有)

:root 匹配根元素html

(5)UI状态伪类选择器: checked, disabled, enabled

(6)目标伪类选择器: target

### 如何设计 C3 动画

CSS3动画可以不用鼠标触发,自动,反复的执行某些动画.

需要先定义动画然后再调用它.

定义动画的语法是: @keyframes 动画名称{from{}to{}}

调用动画的语法是: 动画名称 duration(动画时长) timing-function(速度曲线) delay(延迟时间) iteration-count(重复次数) direction(动画方向) fill-mode(执行完毕时状态)

其中,动画名称和动画时长必须赋.

### 如何定义使用 css 变量

css中定义变量

定义变量可分多种情况：
1、定义全局变量
:root {
  --borderColor: #ccc;
}
使用：width:var(--borderColor);

2、定义某元素下的变量
.look{
  --borderColor: #ccc;
}

3、定义媒体查询下的变量
@media screen and (min-width: 1025px) { 
    :root { 
        --borderColor: #ccc;
　　 }
}
使用：
.has-border-table > tr > td {
  border-right: 1px solid var(--borderColor);
}

less中定义变量
定义：
@bg-color : #d9d9d9;
使用：
.has-border-table > tr > td {
  border-right: 1px solid var(@bg-color);
}

sass中定义变量
定义：
$bg-color : #d9d9d9;
使用：
.has-border-table > tr > td {
  border-right: 1px solid var($bg-color);
}

### 如何左侧固定 200px 右侧自适应布局

我们可以使用 flex 布局实现目标,首先给父盒子设置 display:flex; 再给左侧的盒子固定宽度 200px, 右侧的盒子设置自适应 flex:1

### 如何调试 css 代码

Google 工具调试

### 如何在 less 中定义和使用函数

在 less 中定义的语法是: @变量名:值; 使用变量的语法是: CSS属性:@变量名;

### 哪些 css 属性不会继承,哪些会被继承

**CSS能继承的属性有 5 类:**

(1)`字体系列属性`: font、font-weight、font-size、font-style、font-family

(2)`文本系列属性`: 2.1）内联元素：color、line-height、word-spacing、letter-spacing、 text-transform（转换不同元素中的文本）;2.2）块级元素：text-indent（文本块中首行文本的缩进）、text-align

(3)`元素可见性`: visibility

(4)`表格布局属性`:caption-side（设置表格标题的位置）、border-collapse（设置表格的边框是否被合并为一个单一的边框）、border-spacing（设置相邻单元格的边框间的距离，仅用于"边框分离"模式）、empty-cells（设置是否显示表格中的空单元格,仅用于"分离边框"模式）、 table-layout（设置表格布局算法）

(5)`列表布局属性`: list-style 

继承的特殊情节: a的颜色 h系列的字体大小不能被继承,因为浏览器给了默认的样式,但是会被浏览器默认的样式覆盖.

**不能继承的属性也有 5 类:** 

(1)`display`：规定元素应该生成的框的类型

(2)文本属性：vertical-align、text-decoration

(3)盒子模型的属性：width、height、margin 、border、padding

(4)背景属性：background、background-color、background-image

(5)定位属性：float、clear、position、top、right、bottom、left、min-width、 min-height、max-width、max-height、overflow、clip

### 哪些 css 属性会有浏览器兼容性问题

# 

CSS3属性针对不同浏览器内核兼容写法:

-webkit- 针对webkit内核

-moz- 针对火狐内核

-ms- 针对IE内核

-o- 针对opera内核

### BFC是什么？

BFC（`块级格式化上下文`），一个创建了新的BFC的盒子是独立布局的，盒子内元素的布局不会影响盒子外面的元素。在同一个BFC中的两个相邻的盒子在垂直方向发生margin重叠的问题。

BFC是值浏览器中创建了一个独立的渲染区域，该区域内所有元素的布局不会影响到区域外元素的布局，这个渲染区域只对块级元素起作用

[参考文章：深入理解BFC](https://www.cnblogs.com/xiaohuochai/p/5248536.html)

### HTML 文件中的 DOCTYPE 是什么作用？

HTML超文本标记语言: 是一个标记语言, 就有对应的语法标准

DOCTYPE 即 Document Type，网页文件的文档类型标准。

主要作用是告诉浏览器的解析器要使用哪种  **HTML规范** 或 **XHTML规范** 来解析页面。

DOCTYPE 需要放置在 HTML 文件的 `<html>`标签之前，如：

```html
<!DOCTYPE html>
<html>
  ...
</html> (目前主流)
```

```html
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
  ...
</html> (早期)
```

### HTML、XML、XHTML 之间有什么区别？

它们都属于标记语言。  

| 语言  | 中文名               | 说明                                                         |
| ----- | -------------------- | ------------------------------------------------------------ |
| HTML4 | 超文本标记语言       | 主要用于做界面呈现。HTML 是先有实现，后面才慢慢制定标准的，导致HTML⾮常混乱和松散，语法非常的不严谨。 |
| XML   | 可扩展标记语言       | 主要⽤于存储数据和结构。语法严谨，可扩展性强。由于 JSON 也有类似作⽤但更轻量⾼效， XML 的市场变得越来越⼩。 |
| XHTML | 可扩展超文本标记语言 | 属于加强版 HTML，为解决 HTML 的混乱问题而生，在语法方面变得和 XML 一样严格。另外，XHTML 的出现也催生了 HTML 5，让HTML向规范化严谨化过渡。 |
| HTML5 | 超文本标记语言       | 在HTML的基础上进行拓展，用于页面呈现 (目前标准)              |

XML的要求会比较严格:

1. 有且只能有一个根元素

2. 大小写敏感

3. 正确嵌套

4. 必须双引号

5. 必须闭合标签

   ...

```jsx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <father id='box'>
    <child>小张</child>
    <child>小王</child>
  </father>
</root>
```

XHTML 和 HTML5 的历史延展: https://www.cnblogs.com/my-freedom/p/5796915.html



**番外:** 所以 HTML5 是HTML的新一代标准, 所谓的 H5 工程师这一词, 其实是国产词, 泛指新一代的web开发工程师, 

具体H5工程师, 做什么工作方向, 还是要看需求 (比如: 移动端开发, PC端网页开发, H5小游戏开发....)

### 前缀为 data- 开头的元素属性是什么？

这是一种为 HTML 元素添加额外数据信息的方式，被称为 **自定义属性**。

我们可以直接在元素标签上声明这样的数据属性：

```html
<div id="mydiv" data-message="Hello,world" data-num="123"></div>
```

也可以使用 JavaScript 来操作元素的数据属性：

```js
let mydiv = document.getElementById('mydiv')

// 读取
console.log(mydiv.dataset.message)

// 写入
mydiv.dataset.foo = "bar!!!"
```

**注意：在各种现代前端框架出现后，这种原生的自定义属性已经变得不太常用了, 以前的使用频率非常高, 所以我们知道即可。**

例如: vue实现删除功能时需要 id, 可以直接传值

```jsx
<tr v-for="item in list" :key="item.id">
  <td>张三</td>
  <td>18</td>
  <td>体育好</td>
  <td>
    <button @click="del(item.id)">删除</button>
    <button>编辑</button>
  </td>
</tr>
```

### 谈谈你对 HTML 语义化的理解？

考察核心点: 语义化的好处 (利于SEO, 可阅读性更好)

**语义化之前：**

在提倡语义化之前，你可能会使用各种各样的标签去实现同样的功能，比如：

- 使用 span、div、p、a 等做文字, 做按钮
- 使用 div 做一切

从功能方面来说，这确实是不存在什么问题的，完全可以达到功能效果。但这不符合直觉，非常不友好：

- 对人不友好：阅读代码的人不能一眼看出代码的功能
- 对机器不友好：解析代码的程序不能很好的对这些元素进行分类处理



**语义化之后：**

为了解决上面说的问题，HTML5 规范提倡语义化标签，即使⽤恰当语义的 HTML 标签让⻚⾯具有良好的结构与含义，⽐如：

- `<p>` 标签就代表段落
- `<article>` 代表正⽂内容
- `<button> `代表按钮
- `<header>` 代表头部
- 等等...

语义化的好处：

| 对开发者的好处                                               | 对机器/程序的好处                                            |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 使⽤了语义化标签的程序，可读性明显增强，开发者可以比容易和清晰地看出⽹⻚的结构；这也更利于整个开发团队的协作开发和后续维护工作 | 带有语义的网页代码在⽂字类应用上的表现⼒丰富，利于搜索引擎爬⾍程序来爬取和提取出有效的信息；语义化标签还⽀持读屏软件，根据⽂章可以⾃动⽣成⽬录等，方便特殊人群无障碍的使用这些网页程序。 |

**语义化的适用性：**

语义化适合内容型的网站来使用（如简书、知乎），对其⽹站内容的传播有很⼤帮助。

### HTML5 对比 HTML4 有哪些不同之处？

**考察点: 是否了解 html5 新增的一些新特性**

| 不同点                                  | 备注说明                                                     |
| --------------------------------------- | ------------------------------------------------------------ |
| 只有一种 DOCTYPE ⽂件类型声明(统一标准) | `<!DOCTYPE html>`                                            |
| 增加了一些新的标签元素(功能, 语义化)    | **section**, **video**, progress, **nav**, meter, time, **aside**, <br/>**canvas**, command, datalist, details, embed, figcaption, <br/>figure, **footer**, **header**, hgroup... |
| input 支持了几个新的类型值              | `date, email, url` 等等                                      |
| 新增了一些标签属性                      | charset（⽤于 meta 标签）；async（⽤于 script 标签）         |
| 新增的全域属性                          | contenteditable, draggable... <br/>hidden...                 |
| 新增API                                 | 本地存储, 地理定位, Canvas绘图, 拖拽API, 即时通信WebSocket... |

获取地理定位: navigator.geolocation.getCurrentPosition(successCallback, errorCallback) (为了安全, 需要在 https 网站使用)

记忆角度: 更标准, 新增标签, 新增type表单属性, 新增全域属性, 新增API...

### meta 标签有哪些常用用法？

`<meta>` 标签的具体功能一般由 name/http-equiv 和 content 两部分属性来定义。

- 如果设置 name 属性，则它描述的是网页文档的信息（例如：作者、⽇期和时间、⽹⻚描述、 关键词）
- 如果设置 http-equiv 属性，则它描述的相当于是 HTTP 响应头信息（例如：网页内容信息, 网页缓存等）

**一些常用的功能及写法：**

1. 设置网页关键词 (SEO)

```html
<meta name="keywords" content="电商,好货,便宜">
```

2. 设置网页视口（viewport）控制视⼝的⼤⼩、缩放和⽐例等 (移动端开发)

```html
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
```

3. 设置 http 响应头：Content-Type 网页内容类型  (字符集)

```html
<meta http-equiv="content-type" content="text/html;charset=utf-8">

<!-- 设置字符集可简写为 -->
<meta charset="utf-8">
```

### img 标签的 srcset 的作用是什么？

**考察点: 处理响应式图片的方式** (css媒体查询换的是背景图片, 而不是 img 标签的 src)

开发者和设计师们竞相寻求 **处理响应式图片** 的方法。这的确是一个[棘手的问题](https://css-tricks.com/responsive-images-hard/) ，因为我们对同一个网站在众多设备宽度下，

使用同一图像源。你愿意在一个大显示屏上显示模糊地、马赛克状的图像？

你愿意在你的手机上加载一个巨大的（虽然更漂亮的）图像？这个问题令人左右为难。 [博客链接](https://www.jiangweishan.com/article/response-srcset-sizes.html)

其实通过使用 img 标签的 srcset 属性，可定义一组额外的图片集合，让浏览器根据不同的屏幕状况选取合适的图片来显示。

> 也就是图片的响应式处理能力。

如果你的响应式需求比较简单，只需要针对屏幕的不同 dpr （device pixel ratio，设备像素比）来决定图片的显示的话，

dpr 设备像素比, 越高, 能够显示的越清晰  (dpr: 2, dpr: 3)

那么就只要这么写：

```html
<img srcset="320.png 1x, 640.png 2x, 960.png 3x" />
```

对于可变宽度的图像，我们使用`srcset`搭配`w`描述符以及`sizes`属性 。

- `w`描述符告诉浏览器列表中的每个图象的宽度。

- `sizes`属性需要至少包含两个值，是由逗号分隔的列表。

根据最新规范，如果`srcset`中任何图像使用了`w`描述符，那么必须要设置`sizes`属性。

`sizes`属性有两个值：

1. 第一个是媒体查询条件；

2. 第二个是图片对应的尺寸值，

   在特定媒体条件下，此值决定了图片的宽度。

   需要注意是，源图尺寸值不能使用百分比，如果要用100%,  `vw`是唯一可用的CSS单位。

```html
<img alt="img元素srcset属性浅析"
  srcset="
    320.png 320w, 
    480.png 480w, 
    640.png 640w"
  sizes="
    (max-width: 320px) 100vw, 
    (max-width: 360px) 320px,
    (max-width: 480px) 360px,
    (max-width: 640px) 480px,
    640px"
  src="640.png"
/>
```

为 img 定义以上属性后，浏览器的工作流程如下：

1. 检查设备的实际宽度
2. 检查 img 标签的 sizes 属性中定义的媒体查询条件列表，并计算哪个条件最先匹配到
3. 得到图片此时的响应式宽度
4. 加载 srcset 中最接近, 最适合媒体查询匹配到的宽度的图片

注意: 测试时, 清除缓存测试, 因为一旦加载了高清图, 就不会也没有必要, 回过去再用小图替换了

且我们无法确定究竟显示哪张图像，因为每个浏览器根据我们提供的信息挑选适当图像的算法是有差异的。

(译者注：srcset和size列表是对浏览器的一个建议(hint)，而非指令。由浏览器根据其能力、网络等因素来决定。)

### 响应式图片处理优化: Picture 标签

**考察点: 响应式图片处理**

`picture`元素就像是图像和其源的容器。浏览器仍然需要`img`元素，用来表明需要加载的图片

在 `<picture>` 下可放置零个或多个`<source>`标签、以及一个`<img>`标签，为不同的屏幕设备和场景显示不同的图片。

如果source匹配到了, 就会优先用匹配到的, 如果没有匹配到会往下继续找

使用`picture`元素选择图像，不会有歧义。

浏览器的工作流程如下：

- 浏览器会先根据当前的情况，去匹配和使用`<source>`提供的图片

- 如果未匹配到合适的`<source>`，就使用`<img>`标签提供的图片

```html
<picture>
  <source srcset="640.png" media="(min-width: 640px)">
  <source srcset="480.png" media="(min-width: 480px)">
  <img src="320.png" alt="">
</picture>
```

### 在 script 标签上使用 defer 和 async 的区别是什么？

**明确: defer 和 async 的使用, 可以用于提升网页性能**

script标签存在两个属性，defer和async，因此 script标签 的使用分为三种情况：

1. `<script src="example.js"></script>`

   没有defer或async属性，浏览器会立即加载并执行相应的脚本。

   不等待后续加载的文档元素，读到就开始加载和执行，此举会阻塞后续文档的加载

2. `<script async src="example.js"></script>`

   有了async属性，表示后续文档的加载和渲染与js脚本的加载和执行是并行进行的，即异步执行；

3. `<script defer src="example.js"></script>`

   有了defer属性，加载后续文档的过程和js脚本的加载是并行进行的(异步)，此时的js脚本仅加载不执行, js脚本的执行需要等到文档所有元素解析完成之后，DOMContentLoaded事件触发执行之前。

下图是使用了 defer、async、和未使用时的运行情况对比：


> 【上图的图例说明】
>
> 绿线：HTML 的解析时间
>
> 蓝线：JS 脚本的加载时间
>
> 红色：JS 脚本的执行时间

从图中我们可以明确一下几点：

　　1.defer和async在网络加载过程是一致的，都是异步执行的；(放在页面顶部, 也不会阻塞页面的加载, 与页面加载同时进行)

　　2.两者的区别, 脚本加载完成之后, async是立刻执行, defer会等一等 (等前面的defer脚本执行, 等dom的加载)

所以, js脚本加上 async 或 defer, 放在头部可以减少网页的下载加载时间, 如果不考虑兼容性, 可以用于优化页面加载的性能

```jsx
<script src="https://cdn.bootcdn.net/ajax/libs/vue/2.6.12/vue.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/element-ui/2.15.0/index.js"></script>
```

### 前端做本地数据存储的方式有哪些

1. Cookies
2. localStorage
3. sessionStorage
4. Web SQL
5. IndexedDB

### localStorage、sessionStorage、cookie 存储的区别（必会）

**共同点：**都是保存在浏览器端、且同源的

**区别：**

1、cookie 数据始终在同源的 http 请求中携带（即使不需要），即 cookie 在浏览器和服务器间

来回传递，而 sessionStorage 和 localStorage 不会自动把数据发送给服务器，仅在本地保

存。cookie 数据还有路径（path）的概念，可以限制 cookie 只属于某个路径下

2、存储大小限制也不同，cookie 数据不能超过 4K，同时因为每次 http 请求都会携带

cookie、所以 cookie 只适合保存很小的数据，如会话标识。sessionStorage 和 localStorage

虽然也有存储大小的限制，但比 cookie 大得多，可以达到 5M 或更大

3、数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭之前有效；localStorage：始

终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie：只在设置的 cookie 过期

时间之前有效，即使窗口关闭或浏览器关闭 

4、作用域不同，sessionStorage 不在不同的浏览器窗口中共享，即使是同一个页面；

localstorage 在所有同源窗口中都是共享的；cookie 也是在所有同源窗口中都是共享的

5、web Storage 支持事件通知机制，可以将数据更新的通知发送给监听者

6、web Storage 的 api 接口使用更方便

### 以上几种前端存储的区别是什么？

| 方式名称       | 标准说明     | 功能说明                                                     |
| -------------- | ------------ | ------------------------------------------------------------ |
| Cookies        | HTML5 前加入 | 1.会为每个请求自动携带所有的Cookies数据，比较方便，但是也是缺点，浪费流量；<br>2.每个domain(站点)限制存储20个cookie；<br/>3.容量只有4K<br/>4.浏览器API比较原始，需要自行封装操作。 (js-cookie) |
| localStorage   | HTML5 加入   | 1.兼容IE8+，操作方便；<br/>2.永久存储，除非手动删除；<br/>3.容量为5M |
| sessionStorage | HTML5 加入   | 1.功能基本与 localStorage 相似，但当前页面关闭后即被自动清理；<br/>2.与Cookies、localStorage 不同点是不能在所有同源窗口间共享，属于会话级别的存储 |
| Web SQL        | 非标准功能   | 1.2010年已被废弃，但一些主流浏览器中都有相关的实现；<br/>2.类似于 SQLite 数据库，是一种真正意义上的关系型数据库，⽤SQL进⾏操作； |
| IndexedDB      | HTML5 加入   | 1.是一种 NoSQL 数据库，⽤键值对进⾏储存，可进⾏快速读取操作；<br/>2.适合复杂 Web存储场景，⽤JS操作⽅便 (前端大量存数据的场景较少, 如果有, 可以用) <br />3.存储空间容量, 大于等于 250MB，甚至没有上限 |

### CSS选择器的优先级是怎么样的？

**CSS选择器的优先级顺序：**

`内联样式` > `ID选择器` > `类选择器` > `标签选择器`

**优先级的计算：**

优先级是由 A、B、C、D 四个值来决定的，具体计算规则如下

- A={如果存在内联样式则为1，否则为0}
- B={ID选择器出现的次数}
- C={类选择器、属性选择器、伪类选择器出现的总次数}
- D={标签选择器、伪元素选择器出现的总次数}

**计算示例：**

样式一：

```css
/*
  A=0   不存在内联样式
  B=0   不存在ID选择器
  C=1   有一个类选择器
  D=3   有三个标签选择器

  最终计算结果：{0,0,1,3}
*/
div ul li .red { ... }
```

样式二：

```css
/*
  A=0   不存在内联样式
  B=1   有一个ID选择器
  C=0   不存在类选择器
  D=0   不存在标签选择器

  最终计算结果：{0,1,0,0}
*/
#mydiv { ... }
```

计算完成后，我们通过从A到D的顺序进行值的大小比较，权重由A到D从高到低，只要比较出最大值即可。例如上面的两个样式：

```md
1. 样式一的A=0，样式二的A=0  【相等，继续往下比较】
2. 样式一的B=0 < 样式二的B=1 【样式二的大，不继续往下比了，即认为样式二的优先级更高】
```

### 通过 CSS 的哪些方式可以实现隐藏页面上的元素？

| 方式                  | 说明                                                         |
| --------------------- | ------------------------------------------------------------ |
| opacity: 0            | 通过将元素的透明度设置为0，实现看起来隐藏的效果；但是依然会占用空间并可以进行交互 |
| visibility: hidden    | 与透明度为0的方案非常类似，会占据空间，但不可以进行交互      |
| overflow: hidden      | 只会隐藏元素溢出的部分；占据空间且不可交互                   |
| display: none         | 可以彻底隐藏元素并从文档流中消失，不占据空间也不能交互，且不影响布局 |
| z-index: -9999        | 通过将元素的层级置于最底层，让其他元素覆盖住它，达到看起来隐藏的效果 |
| transform: scale(0,0) | 通过将元素进行缩放，缩小为0；依然会占据空间，但不可交互      |
| left: -9999px         | 通过将元素定位到屏幕外面，达到看起来看不到的效果             |

###  px、em、rem之间有什么区别？

| 单位名称 | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| px       | 绝对单位。代表像素数量，页面会按照给出的精确像素进行展示     |
| em       | 相对单位。默认的基准点为父元素的字体大小，而如果自身定义了字体大小则按自身的来算。所以即使在同一个页面内，1em可能不是一个固定的值。 |
| rem      | 相对单位。可以理解为 `root em`，即基准点为根元素`<html>`的字体大小。rem是CSS3中新增单位，Chrome/FireFox/IE9+都支持, 一般用于做移动端适配 |

正常开发 px 使用率较高, 如果要做 rem 适配, 会用到 rem 单位!

rem布局的原理:

1. 使用 rem 为单位
2. 动态的设置 html font-size (媒体查询, js设置, 插件设置都可以)

webpack有工具, 可以写 px, 自动转 rem  https://youzan.github.io/vant/#/zh-CN/advanced-usage

### 如何理解 z-index？

可以将它看做三维坐标系中的z轴方向上的图层层叠顺序。

元素默认的 z-index 为 0，可通过修改 z-index 来控制设置了postion 值的元素的图层位置。





可以将这种关系想象成一摞书本，通过 z-index 可以改变一本书在这摞书中的上下位置。

z-index的小坑, 如果父辈元素有定位, 且配置了z-index, 优先按照父辈元素的定位的z-index进行比较层级

```html
<style>
  .father {
    width: 100%;
    height: 200px;
    position: relative;
    background-color: skyblue;
    z-index: 1;
  }
  .son {
    position: absolute;
    width: 100px;
    height: 100px;
    background-color: red;
    left: 0;
    top: 0;
    z-index: 999;
  }
  .box2 {
    position: absolute;
    width: 100px;
    height: 100px;
    background-color: blue;
    left: 0;
    top: 0;
    z-index: 100;
  }
</style>

<div class="father">
  <div class="son"></div>
</div>

<div class="box2"></div>
```

### 什么是CSS Sprites以及它的好处？

**考察: 性能优化的方案**

CSS Sprites，俗称雪碧图、精灵图。这是一种CSS图片合并技术，就是将CSS中原先引用的一些较小的图片，合并成一张稍大的图片后再引用的技术方案。它可以减少请求多张小图片带来的网络消耗（因为发起的HTTP请求数变少了），并实现提前加载资源的效果。

**操作方式：**

可以手工使用图片编辑软件（如Photoshop），将多张小图片合并编辑变成一张大图片，并针对这张大图片，编写CSS样式来引用这张大图片中对应位置的小图片（涉及到的样式：background-image、background-position、background-size）。然后在HTML元素中使用这些样式即可。

https://img.alicdn.com/tfs/TB1eiXTXlTH8KJjy0FiXXcRsXXa-24-595.png

**缺点：**

- CSS Sprites中任意一张小图的改动，都需要重新生成大图；并且用户端需要重新下载整张大图，这就降低了浏览器缓存的优势
- 随着HTTP2的逐渐普及，HTTP2的多路复用机制可以解决请求多个小图片所创建多个HTTP请求的消耗，让CSS Sprites存在的价值降低了
- 图片如果放大, 是会失真

目前其他主流的处理图片的方案:  iconfont 字体图标, svg矢量图...

### 你对媒体查询的理解是什么样的？

**考察点: 响应式适配**, 根据不同的屏幕尺寸, 显示不同的效果 (设置盒子的样式)

媒体查询是自 CSS3 开始加入的一个功能。它可以进行响应式适配展示。

媒体查询由两部分组成：

- 一个可选的媒体类型（如 screen、print 等）
- 零个或多个媒体功能限定表达式（如 max-width: 500px、orientation: landscape 等）

这两部分最终都会被解析为 true 或 false 值，然后整个媒体查询值为 true，则和该媒体查询关联的样式就生效，否则就不生效。

**使用示例：**

```css
/* 在css样式表的定义中直接使用媒体查询 */ 
.container {
  width: 600px;
  height: 200px;
  background-color: pink;
  margin: 0 auto;
}
@media screen and (max-width: 767px) {
  .container {
    width: 100%;
  }
}
@media screen and (min-width: 768px) and (max-width: 991px) {
  .container {
    width: 750px;
  }
}
@media screen and (min-width: 992px) and (max-width: 1199px) {
  .container {
    width: 980px;
  }
}
@media screen and (min-width: 1200px) {
  .container {
    width: 1170px;
  }
}
@media screen and (width: 1200px) {
  .container {
    background-color: skyblue;
  }
}
```

[参考文章：深入理解CSS媒体查询](https://www.cnblogs.com/xiaohuochai/p/5848612.html)

### 说说伪类和伪元素的区别？

**什么是伪类？**

伪类（pseudo-class）是以冒号`:`为前缀，可被添加到⼀个选择器的末尾的关键字。

它用于让样式在元素的特定状态下才被应用到实际的元素上。比如：`:checked`、`:hover`、`:disabled`、 `:first-child`等。

:hover

:nth-child(1)

:nth-child(2)

:checked

注意: 伪类, 虽然是写法比较特殊, css选择器的权重, 和类一致的



**什么是伪元素？**

:before / :after

伪元素⽤于创建⼀些并不在 DOM 树中的元素，并为其添加样式。伪元素的语法和伪类类似，可以一个冒号或两个冒号为前缀。

⽐如，可以通过 `:before` 、`:after` 来在⼀个元素前、后增加⼀些额外的⽂本并为它们添加样式；

并且，虽然⽤户可以看到这些⽂本，但其实它们并不在 DOM 树中。(**坑: 伪元素是无法注册事件的, 所以不要通过js控制伪元素**)



**两者的区别**

虽然它们在语法上是一致的，但是它们的功能区别还是非常明显的。

- 伪类是用来匹配元素的特殊状态的
- 伪元素是用来匹配元素的隶属元素的，这些隶属元素可以在界面中展示，但在 DOM 中不体现

[参考文章：伪类与伪元素](http://www.alloyteam.com/2016/05/summary-of-pseudo-classes-and-pseudo-elements/)

### em 和 rem 的区别是什么

em:是相对单位，相对于当前对象内文本的字体尺寸。

rem: [css3](https://so.csdn.net/so/search?q=css3&spm=1001.2101.3001.7020)中新增的一个单位，是相对单位，相对于HTML 根元素的字体尺寸。

### rem 适配的原理是什么

利用`媒体查询`或者`js` 动态检测设备的宽度，不同设备宽度下给根元素设置对应的字体大小，设备宽度变化时，根元素的字体大小改变，所有使用 rem 做单位的那些元素的大小也随之改变。

引入 flexible.js，默认划分了10份，750宽度下根元素的字体大小就是75，实际做的时候，我只需要把量取到的宽度除以75就好了！

### HTML 的语义化你是怎么理解的

是什么?好处是什么?

所谓的html语义化无非就是合适的内容使用合适的标签。

好处：见名知意；利于SEO。

### margin-top 的百分比相对谁，例如 margin-top: 50% 是什么意思

margin的百分比是相对于父元素的宽度

```html
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    .wrap {
      width: 800px;
      height: 600px;
      background-color: pink;
      position: relative;
    }

    .box {
      width: 100px;
      height: 70px;
      background-color: black;
      position: absolute;
      top: 50%;
      left: 50%;
      /* 使用 margin 必须要明确的知道自身的宽高！ */
      /* margin-top: -35px;
      margin-left: -50px; */
      /* margin 的百分比是相对于父元素的宽度 */
      /* margin-top: -50%;
      margin-left: -50%; */
      transform: translate(-50%, -50%);
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="box"></div>
  </div>
</body>

</html>
```

### 说一下 Less 你用过哪些特性（除了变量、嵌套、计算，再找几条）

（1）变量：使用`@`来定义变量，变量名自定义。

```js
// 定义变量
@color: #00f;
// 使用变量
h1 {
    color: @color;
}
```

字符串插值

```js
// 语法
@variable: "xxx";
将变量放入到{}中 
@{variable}
```

```js
// 使用
@url: "/images/";
div {
  width: 200px;
  height: 200px;
  background-image: url("@{url}1.jpg"); // 结果为/images/1.jpg
}
```

媒体查询定义变量的方式

```js
// 由于“~”后面的值是不被编译的，所以可以用作媒体查询的参数。
@mediaQuery: ~"(max-width: 600px)";

@media screen and @mediaQuery {
  div {
    width: 200px;
    height: 200px;
    background-color: #898900;
  }
}
```

（2）嵌套

Less提供了使用嵌套代替层叠或与层叠结合使用的能力。使用Less书写可以模仿HTML的组织结构。

（3）计算

（4）命名空间

定义一个命名空间，可以使用任何的类/ID选择器，作为命名空间，**此时命名空间的性质类似于函数**。

这里定义了一个命名空间（例如：.my()），使其在编译之后的文件中不输出。可以在这个命名空间中书写混合。使用命名空间中的混合，类似于后代选择器（`>` 或 ` `）一样选择指定的选择器进行使用。

（5）实现一个左侧固定，右侧自适应的布局。

```html
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    .box {
      display: flex;
      height: 300px;
    }

    .left {
      width: 200px;
      background-color: green;
    }

    .right {
      flex: 1;
      background-color: pink;
    }
  </style>
</head>

<body>
  <div class="box">
    <div class="left"></div>
    <div class="right"></div>
  </div>
</body>

</html>
```

### H5的新特性有哪些?C3的新特性有哪些?

H5 新特性 :

1、拖拽释放(drap and drop) API ondrop

2、自定义属性 data-id

3、语义化更好的内容标签(header,nav,footer ,aside, article, section)

4、音频 ,视频(audio, video) 如果浏览器不支持自动播放怎么办? 在属性中添加 autoplay(谷歌浏览器不支持音频自动播放，但是视频支持静音自动播放)

5、画布 Canvas

​	5.1）getContext() 方法返回一个用于在画布上绘图的环境

​	5.2）cxt.stroke() 绘制线条

​	5.3）canvas 和 image 在处理图片的时候有什么区别?

​			image 是通过`对象`的形式描述图片的,canvas 通过专门的 `API` 将图片绘制在画布 上.

6、 地理(Geolocation) API 其实 Geolocation 就是用来获取到当前设备的经纬度（位置）

7、 硬盘存储 localStorage 用于`长久保存` `整个网站的数据`，`保存的数据没有过期时间，直到手动去删除`。

8、 内存存储 sessionStorage 该数据对象`临时保存` `同一窗口(或标签页)的数据`，`在关闭窗口或标签页之后将会删除这些数据`。

9、 表单控件 calendar , date , time , email , url , search , tel , file , number

10、新的技术 webworker, websocket , Geolocation

C3 新特性:

1、颜色: 新增 RGBA , HSLA 模式 

>hsla指定是：色调、饱和度、亮色、Alpha透明度（Hue-Saturation-Light-Alpha）

2、文字阴影(text-shadow) 

3、边框: 圆角(border-radius) 边框阴影 : box-shadow 

4、盒子模型: box-sizing 

5、背景:background-size background-origin background-clip 

>定义背景坐标原点—background-origin属性
>
>定义背景裁剪区域—background-clip属性

6、渐变: linear-gradient , radial-gradient 

>radial-gradient 径向渐变

7、过渡 : transition 可实现属性的渐变 

8、自定义动画 animate @keyfrom 

9、媒体查询 多栏布局 @media screen and (width:800px) {…} 

10、border-image 图片边框 

11、2D 转换/3D 转换;transform: translate(x,y) rotate(x,y) skew(x,y) scale(x,y) 

12、字体图标 iconfont/icomoon 

13、弹性布局 flex

### 如何使一个盒子水平垂直居中？

1、利用定位

2、计算父盒子与子盒子的空间距离

3、利用 margin:auto;

4、利用 display：flex;设置垂直水平都居中

5、利用 transform 

6、利用 display:table-cell

```html
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    .parent {
      width: 500px;
      height: 500px;
      border: 1px solid #000;
      display: table-cell;
      vertical-align: middle;
      text-align: center;
    }

    .child {
      width: 100px;
      height: 100px;
      border: 1px solid #999;
      display: inline-block;
    }
  </style>
</head>

<body>
  <div class="parent">
    <div class="child">我是子元素</div>
  </div>
</body>

</html>
```

### 如何实现双飞翼（圣杯）布局？

1、利用`定位`实现两侧固定中间自适应 

1.1）父盒子设置左右 padding 值 

1.2）给左右盒子的 width 设置父盒子的 padding 值,然后分别定位到 padding 处. 

1.3）中间盒子自适应

2、利用 `flex 布局`实现两侧固定中间自适应 

2.1）父盒子设置 display:flex; 

2.2）左右盒子设置固定宽高 

2.3）中间盒子设置 flex:1 ;

3、利用 `bfc 块级格式化上下文`, 实现两侧固定中间自适应 

3.1）左右固定宽高，进行浮动 

3.2）中间 overflow: hidden;

### CSS 的盒模型？

盒子模型分为两种: 

​	第一种是 W3C 标准的盒子模型（标准盒模型） 

​	第二种 IE 标准的盒子模型（怪异盒模型） 

标准盒模型与怪异盒模型的表现效果的区别之处： 

​	1、标准盒模型中 width 指的是内容区域 content 的宽度 height 指的是内容区域 content 的高度 标准盒模型下盒子的大小 = content + border + padding + margin


​	2、怪异盒模型中的 width 指的是内容、边框、内边距总的宽度（content + border + padding）；height 指的是内容、边框、内边距总的高度 怪异盒模型下盒子的大小=width（content + border + padding） + margin



>可以通过属性 box-sizing 来设置盒子模型的解析模式可以为 box-sizing 赋两个值:
>
>content-box：默认值，border 和 padding 不算到 width 范围内，可以理解为是 W3c 的 标准模型(default)。总宽=width+padding+border+margin 
>
>border-box：border 和 padding 划归到 width 范围内，可以理解为是 IE 的怪异盒 模型，总宽=width+margin

### CSS 中选择器的优先级以及 CSS 权重如何计算？

！Important>行内样式>ID 选择器>类选择器>标签>通配符>继承>浏览器默认属性的权重 

CSS 权重选择器优先级计算表格：

>优先级注意点: 
>
>1. 权重是有 4 组数字组成,但是不会有进位。 
>2. 可以理解为类选择器永远大于元素选择器, id 选择器永远大于类选择器,以此类推。 
>3. 等级判断从左向右，如果某一位数值相同，则判断下一位数值。
>4. 可以简单记忆法: 通配符和继承权重为 0, 标签选择器为 1,类(伪类)选择器为 10, id 选择器 100, 行内样式表为 1000, !important 无穷大。
>5. 继承的权重是 0， 如果该元素没有直接选中，不管父元素权重多高，子元素得到的权 重都是 0。 
>
>权重叠加：如果是复合选择器，则会有权重叠加，需要计算权重。

### 列举 5 个以上的 H5 input 元素 type 属性值？

| 值       | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| text     | 默认。定义单行输入字段，用户可在其中输入文本。默认是 20 个字符 |
| password | 定义密码字段。字段中的字符会被遮蔽                           |
| radio    | 定义单选按钮                                                 |
| checkbox | 定义复选框                                                   |
| submit   | 定义提交按钮。提交按钮向服务器发送数据                       |
| button   | 定义可点击的按钮（大多与 JavaScript 使用来启动脚本）         |
| email    | 定义用于 e-mail 地址的文本字段                               |
| search   | 定义用于搜索的文本字段                                       |
| file     | 定义输入字段和 "浏览..." 按钮，供文件上传                    |
| hidden   | 定义隐藏输入字段                                             |
| image    | 定义图像作为提交按钮                                         |
| url      | 定义用于 URL 的文本字段                                      |
| number   | 定义带有 spinner 控件的数字字段                              |
| color    | 定义拾色器                                                   |
| date     | 定义日期字段（带有 calendar 控件）                           |
| month    | 定义日期字段的月（带有 calendar 控件）                       |
| time     | 定义日期字段的时、分、秒（带有 time 控件）                   |

### CSS 单位中 px、em 和 rem 的区别？

1、px 像素（Pixel）。`绝对单位`。像素 px 是相对于显示器屏幕分辨率而言的，是一 个虚拟长度单位，是计算机系统的数字化图像长度单位 

2、em 是`相对长度单位`，相对于`当前对象内文本的字体尺寸`。如当前对象行内文本的字体尺寸未被人为设置，则相对于`浏览器的默认字体尺寸`。它会继承父级元素的字体大小因此并`不是一 个固定的值 `

3、rem 是 CSS3 新增的一个`相对单位`（root em，根 em），使用 rem 为元素设定字体大小 时，仍然是相对大小，但相对的只是 `HTML 根元素` 

>区别： 
>
>IE 无法调整那些使用 px 作为单位的字体大小，而 em 和 rem 可以缩放，rem相对的只是 HTML 根元素。这个单位可谓集相对大小和绝对大小的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐 层复合的连锁反应。目前，除了 IE8 及更早版本外，所有浏览器均已支持 rem

### rem 适配方法如何计算 HTML 根字号及适配方案？

通用方案 

1. 设置根 font-size：625%（或其它自定的值，但换算规则 1rem 不能小于 12px） 

2. 通过媒体查询分别设置每个屏幕的根 font-size 

3. CSS 直接除以 2 再除以 100 即可换算为 rem 

优：有一定适用性，换算也较为简单 

劣：有兼容性的坑，对不同手机适配不是非常精准；需要设置多个媒体查询来适应不同 手机，单某款手机尺寸不在设置范围之内，会导致无法适配 

网易方案 

1. 拿到设计稿除以 100，得到宽度 rem 值 

2. 通过给 html 的 style 设置 font-size，把 1 里面得到的宽度 rem 值代入 x document.documentElement.style.fontSize = document.documentElement.clientWidth / x + ‘px’; 

3. 设计稿 px/100 即可换算为 rem 

优：通过动态根 font-size 来做适配，基本无兼容性问题，适配较为精准，换算简便 

劣：无 viewport 缩放，且针对 iPhone 的 Retina 屏没有做适配，导致对一些手机的适配不是很到位 

手淘方案 

1. 拿到设计稿除以 10，得到 font-size 基准值 

2. 引入 flexible 

3. 不要设置 meta 的 viewport 缩放值 

4. 设计稿 px/ font-size 基准值，即可换算为 rem 

优：通过动态根 font-size、viewport、dpr 来做适配，无兼容性问题，适配精准。 

劣：需要根据设计稿进行基准值换算，在不使用 sublime text 编辑器插件开发时， 单位计算复杂

### display：none 与 visibility：hidden 的区别？

元素隐藏和显示最常用的为 display:none 和 visibility:hidden 

dispaly:none 设置该属性后，该元素下的元素都会隐藏，占据的空间消失 

visibility:hidden 设置该元素后，元素虽然不可见了，但是依然占据空间的位置 

>区别：
>
>1.visibility 具有继承性，其子元素也会继承此属性，若设置 visibility:visible; 则子元素会显示 
>
>2.visibility 不会影响计数器的计算，虽然隐藏掉了，但是计数器依然继续运行着。 
>
>3.在 CSS3 的 transition 中支持 visibility 属性，但是不支持 display，因为 transition 可以延迟执行，因此配合 visibility 使用纯 CSS 实现 hover 延时显示效果可以提高用户体验 
>
>4.display:none; 会引起回流(重排)和重绘  visibility:hidden; 会引起重绘

### position 的值有哪些，分别有哪些作用？

静态定位：static 默认值不脱离文档流，top，right，bottom，left 等属性不生效 

绝对定位：absolute 绝对定位的关键是找对参照物，找到最近的一级带有带定位的父级元素进行位置移动如果找不到，那么相对于浏览器窗口进行定位 

>注：
>
>设置了 position:absolute;属性后，元素会脱离正常文档流，不在占据空间；
>
>左右 margin 为 auto 将会失效；
>
>通过 left、top、bottom、right 来决定元素位置。  

相对定位：relative 参照物：元素偏移前位置 

>注：
>
>设置了相对定位，左右 margin 为 auto 仍然有效、并且不会脱离文档流。 

固定定位：fixed 参照物：浏览器窗口； 

>注：
>
>固定定位会脱离文档流； 
>
>当绝对定位和固定定位参照物都是浏览器窗口时的区别： 当出现滚动条时，固定定位的元素不会跟随滚动条滚动，绝对定位会跟随滚动条滚动

### 为什么会出现浮动？浮动元素会引起什么问题？如何清除浮动？

为什么会出现浮动？

​		让块级元素在一行显示并且无缝隙，让块级盒子一左一右进行显示。 

浮动元素会引起什么问题？

1. 子元素浮动后，不占位置，父元素的高度无法被撑开，影响与父元素同级的元素； 

2. 与浮动元素同级的非浮动元素（内联元素）会跟随其后； 

3. 若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构解决方法 

清除浮动的方式 

1. 给父亲设置高度

2. 额外标签法（clear:both;标签添加在父元素内容的最后面,但是标签一定是块级元素）

3. 给父级元素设置单伪元素；

   ```css
   	.clearfix::after {
                       content: '';
                       display: block;
                       clear: both;
                        height: 0;
                       visibility: hidden;
               }
   	/*兼容ie6 ie7*/
    		.clearfix {
                       *zoom: 1
                   }
   ```

4. 给父级元素设置双伪元素；

   ```css
    .clearfix::before,
               .clearfix::after {
                   content: '';
                   display: table;
               }
   
               .clearfix::after {
                   clear: both;
               }
   	/*兼容ie6 ie7*/
    			.clearfix {
                       *zoom: 1
                   }
   ```

5. 给父级元素设置 overflow：hidden；或 overflow：auto（本质是构建一个 BFC）

### 简述弹性盒子 flex 布局及 rem 布局？

### 如何解决 margin“塌陷”？

外边距塌陷共有两种情况： 

第一种情况：两个同级元素，垂直排列，上面的盒子给 margin-bottom 下面的盒子给 margin-top，那么他们两个的间距会重叠，以大的那个计算。解决这种情况的方法为：两个外边距不同时出现

第二种情况：两个父子元素，内部的盒子给 margin-top，其父级也会受到影响，同时产生上边距，父子元素会进行粘连。 

解决方案： 

1、为父盒子设置 border，添加 border 后父子盒子就不是真正意义上的贴合（可以设置成 透明：border：1px solid transparent）； 

2、为父盒子添加 overflow：hidden； 

3、为父盒子设定 padding 值； 

4、为父盒子添加 position：fixed； 

5、为父盒子添加 display：table； 

6、利用伪元素给父元素的前面添加一个空元素 

```css
.father::before {
 content:'';
 display:table;
}
```

### ::before 和 ::after 中双冒号和单冒号有什么区别、作用？

**区别: **

单冒号（:）用于 CSS3 的伪类 

双冒号（::）用于 CSS3 的伪元素 

想让插入的内容出现在其它内容前，使用::before，否则，使用::after； 

在代码顺序上，::after 生成的内容也比 ::before 生成的内容靠后 

**作用：**  

::before 和 ::after 的主要作用是在元素内容前后加上指定内容伪类与伪元素都是用于向选择器加特殊效果 

伪类与伪元素的本质区别就是`是否抽象创造了新元素 `

`伪类只要不是互斥可以叠加使用` 

`伪元素在一个选择器中只能出现一次，并且只能出现在开始和末尾` 

`伪类、伪元素优先级分别与类、标签优先级相同`

### CSS3 新增伪类，以及伪元素？

**CSS3 新增伪类** 

p:first-of-type 选择属于其父元素的首个<p>元素 

p:last-of-type 选择属于其父元素的最后<p>元素 

p:nth-child(n) 选择属于其父元素的第 n 个子元素并且必须是<p>元素 

p:nth-last-child(n) 选择属于其父元素的倒数第 n 个子元素并且必须是<p>元素 

p:nth-of-type(n) 选择属于其父元素第 n 个<p>元素 

p:nth-last-of-type(n) 选择属于其父元素倒数第 n 个<p>元素 

p:last-child 选择属于其父元素最后一个子元素的并且必须是<p>元素 

p:target 和锚点链接一起使用 

​		URL 带有后面跟有锚名称 #，指向文档内某个具体的元素。这个被链接的元素就是目标元素 (target element)。 

​		:target 选择器可用于选取当前活动的目标元素。 

:not(p) 选择非<p>元素 

:enabled 选中不在禁用状态下的表单控件 

:disabled 选中禁用状态下的表单控件 

:checked 选中 单选框或复选框被选中的元素 

**伪元素** 

::first-letter 将样式添加到文本的首字母 

::first-line 将样式添加到文本的首行 

::before 在某元素之前插入某些内容 

::after 在某元素之后插入某些内容

### Bootstrap 栅格系统的工作原理？

**原理:**

1、行（row）必须包含在 .container (固定宽度)或 .container-fluid (100%宽度)中，以便为其赋予合适的排列（aligment）和内补（padding） 

2、通过行（row）在水平方向创建一组列（column） 

3、自己内容应当放置于列（column）内，并且只有列可以作为行（row）的直接子元素 

4、类似.row 和.col-xs-4 这种预定义的类，可以用来快速创建栅格布局。Bootstrap 源码 中定义的 mixin 也可以用来创建语义化布局 

5、通过为列设置 padding 属性，从而创建列与列之间的间隔（gutter）。通过为.row 元 素设置负值 margin 从而抵消为.container 元素设置的 padding，也就间接为行（row） 所包含的列（column）抵消掉了 padding 

6、栅格系统的列是通过指定 1 到 12 的值来表示其跨越范围。例如三个等宽的列可以使用 三个.col-xs-4 来创建 

7、如果一行（row）中包含了的列（column）大于 12，多余的列所在的元素将作为一个 整体另起一行排列 

8、栅格类适用于与屏幕宽度大于或等于分界点大小的设备，并且针对小屏幕覆盖栅格类

使用 Bootstrap 响应式布局: 

​		首先需要在 head 中引入 meta 标签，添加 viewport 属性，content 中宽度等于设备宽 度， initial-scale:页面首次被显示可见区域的缩放级别，取值 1 则页面按实际尺寸显示，无任何缩放；maximum-scale:允许用户缩放到的最小比例；user-scalable:用户是否可以手动缩放。代码如下： 

 ```html
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1,
user-scalable=no">
<link rel="stylesheet" type="text/css" href="/stylesheets/bootstrap.min.css">
 ```

下面为使用 Bootstrap 布局的页面（登录表单界面），针对的是手机超小屏幕（iphone5s）和 PC 屏幕（>=1200px)。col-xs-12:小屏幕占 12 列大小，col-lg-5：大屏幕占 5 列大小， col-lgoffset-3:大屏幕缩进 3 列大小。这是一个比较简单的实例，想要适应其他屏幕如平板可添加 col-md- * 属性，大屏手机可添加 col-sm-*属性。具体的屏幕使用哪个属性，可参考文档中的针对不同屏幕 Bootstrap 栅格系统的不同使用。

```html
<div class="container-fluid login">
  <div class="row">
    <div class="col-xs-12 col-sm-12 col-md-8 col-lg-5 col-lg-offset-3">
      <form class="form-horizontal loginForm">
        <h3 class="form-signin-heading">用户登录</h3>
        <div class="form-group">
          <label for="email" class="col-sm-2 col-xs-3 control-label">邮箱</label>
          <div class="col-sm-8 col-xs-8">
            <input type="text" class="form-control" name="email" placeholder="请输
 入邮箱">
            <span class="glyphicon glyphicon-ok form-control-feedback" ariahidden="true"></span>
          </div>
        </div>
        <div class="form-group">
          <label for="password" class="col-sm-2 col-xs-3 control-label">密码</label>
          <div class="col-sm-8 col-xs-8">
            <input type="password" class="form-control" name="password" placeholder="请输入密码">
            <span class="glyphicon glyphicon-ok form-control-feedback" ariahidden="true"></span>
          </div>
        </div>
        <div class="form-group">
          <div class="col-sm-offset-2 col-sm-4 col-xs-4 ">
            <div class="checkbox">
              <label>
                <input type="checkbox">记住我 </label>
            </div>
          </div>
          <div class="col-sm-4 col-xs-4 control-label">
            <a href="resetPwd.html" id="forget">忘记密码？</a>
          </div>
        </div>
        <div class="form-group">
          <div class="col-sm-12 col-lg-12">
            <button type="button" class="btn btn-primary btn-block" id="submit">登
              录</button>
          </div>
        </div>
      </form>
    </div>
  </div>
```

### `BFC 是什么？`

**定义:**

BFC(Block formatting context)直译为"`块级格式化上下文`"。

它是一个独立的渲染区域， 只有 Block-level box 参与，它规定了内部的 Block-level Box 如何布局，并且与这个区域外部毫不相干

**布局规则:** 

1. 内部的 Box 会在垂直方向，一个接一个地放置 

2. Box 垂直方向的距离由 margin 决定。属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠 

3. 每个元素的 margin box 的左边， 与包含块 border box 的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此 

4. BFC 的区域不会与 float box 重叠 

5. BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此 

6. 计算 BFC 的高度时，浮动元素也参与计算 

**哪些元素会生成 BFC：** 

1. 根元素 
2. float 属性不为 none 
3. position 为 absolute 或 fixed 
4. display 为 inline-block， 

### 什么是渐进增强和优雅降级?它们有什么不同？

优雅降级和渐进增强关键的区别是他们`所侧重的内容`，以及这种不同造成的`工作流程的差异`。

“`优雅降级`”观点认为应该针对那些最高级、最完善的浏览器来设计网站 `往下兼容`

“`渐进增强`”观点则认为应关注于内容本身 `优先考虑低版本的`

### iframe 有哪些优缺点？

iframe 的优点： 

1. 重载页面时不需要重载整个页面，只需要重载页面中的一个框架页(减少了数据的传输，加快了网页下载速度) 
2. 技术易于掌握，使用方便，使用者众多，可主要应用于不需搜索引擎来搜索的页面 

iframe 的缺点： 

1. iframe 会阻塞主页面的 Onload 事件；
2. 会产生很多页面，不容易管理 
3. 不容易打印（目前只能实现分框架页面的打印，不能实现对 frameset 的打印） 
4. 浏览器的后退按钮无效（只能针对实现当前光标所在页面的前进与后退，无法实现 frameset 整个页面的前进与后退） 
5. 代码复杂,无法被一些搜索引擎索引到（有些搜索引擎对框架结构的页面不能正确 处理，会影响到搜索结果的排列名次） 
6. 多数小型的移动设备（手机）无法完全显示框架 
7. 多框架的页面会增加服务器的 http 请求，影响页面的并行加载。 （并行加载：同一时间针对同一域名下的请求。一般情况，iframe 和所在页面在同一 个域下面，而浏览器的并加载的数量是有限制的。

### 使用 CSS 怎么让 Chrome 支持小于 12px 的文字比如 10px？

针对谷歌浏览器内核，加 webkit 前缀，用 transform:scale()这个属性进行缩放。

```html
  <style>
    p span {
      font-size: 10px;
      -webkit-transform: scale(0.8);
      display: block;
    }
  </style>
<body>
  <p>
    <span>使用 CSS 怎么让 Chrome 支持小于 12px 的文字</span>
  </p>
</body>
```

## js基础

### js的数据类型有哪些？

js的数据类型分为基本数据类型（string、number、boolean、null、undefined、symbol）和复杂数据类型

`基本数据`类型的特点：`直接存储在栈中的数据`

`复杂数据`类型的特点：存储的是该`对象在栈中引用`，`真实的数据存放在堆内存里`

### 数据类型的判断有哪些方法？他们的优缺点及区别是什么？

然后判断数据类型的方法一般可以通过：typeof、instanceof、constructor、toString四种常用方法

| 不同类型的优缺点 | typeof                                                     | instanceof                         | constructor                                 | Object.prototype.toString.call   |
| ---------------- | ---------------------------------------------------------- | ---------------------------------- | :------------------------------------------ | -------------------------------- |
| 优点             | 使用简单                                                   | 能检测出`引用类型`                 | 基本能检测所有的类型（除了null和undefined） | 检测出所有的类型                 |
| 缺点             | 只能检测出除null外的基本数据类型和引用数据类型中的function | 不能检测出基本类型，且不能跨iframe | constructor易被修改，也不能跨iframe         | IE6下，undefined和null均为Object |

### 如何判断数据类型

数据类型可以分为两大类：基本数据类型和引用数据类型。

其中基本数据类型有：Number、String、Boolean、undefined 、null，以及 ES6 新引入的 Symbol ，表示独一无二的值，最大的用法是用来定义对象的唯一属性名。

而引用数据类型有：Function、Object、Array 

我所知道的判断数据类型的方法有 2 种：

（1）typeof 可以判断除 null 以外的基本数据类型，和引用数据类型中的 function，而 null，array，object 返回的都是 object。其使用方法是直接在 typeof 后面跟要判断的数据类型即可。

（2）而运算符 instanceof 可以用来判断某个对象是否被另一个函数构造，从而确定对象的类型，但是 instanceof 不能用于判断基本数据类型的数据。

### 知道symbol 吗？

ES6 引入新的原始数据类型Symbol，表示`独一无二的值`

### js 中的继承

**一、原型链继承**

特点：1、实例可继承的属性有：实例的构造函数的属性，父类构造函数属性，父类原型的属性。（新实例不会继承父类实例的属性！）

缺点：1、新实例无法向父类构造函数传参。

　　　2、继承单一。

　　　3、所有新实例都会共享父类实例的属性。（原型上的属性是共享的，一个实例修改了原型属性，另一个实例的原型属性也会被修改！）

**二、借用构造函数继承**

重点：用 .call() 和 .apply() 将父类构造函数引入子类函数（在子类函数中做了父类函数的自执行（复制））

特点：1、只继承了父类构造函数的属性，没有继承父类原型的属性。

　　　2、解决了原型链继承缺点1、2、3。

　　　3、可以继承多个构造函数属性（call多个）。

　　　4、在子实例中可向父实例传参。

缺点：1、只能继承父类构造函数的属性。

　　　2、无法实现构造函数的复用。（每次用每次都要重新调用）

　　　3、每个新实例都有父类构造函数的副本，臃肿。

**三、组合继承（组合原型链继承和借用构造函数继承）（常用）**

重点：**结合了两种模式的优点，传参和复用**

特点：1、可以继承父类原型上的属性，可以传参，可复用。

　　　2、每个新实例引入的构造函数属性是私有的。

缺点：调用了两次父类构造函数（耗内存），子类的构造函数会代替原型上的那个父类构造函数。

**四、原型式继承**

重点：用一个函数包装一个对象，然后返回这个函数的调用，这个函数就变成了个可以随意增添属性的实例或对象。object.create() 就是这个原理。

特点：类似于复制一个对象，用函数来包装。

缺点：1、所有实例都会继承原型上的属性。

　　　2、无法实现复用。（新实例属性都是后面添加的）

**五、寄生式继承**

重点：就是给原型式继承外面套了个壳子。

优点：没有创建自定义类型，因为只是套了个壳子返回对象（这个），这个函数顺理成章就成了创建的新对象。

缺点：没用到原型，无法复用。

**六、class类实现继承**

ES6 用过 class 关键字定义类，里面有构造方法，类之间通过 extends 关键字实现，子类必 须 在 constructor 方法中调用 super 方法

### 原型链

**答案一：**

首先介绍一下原型：

JavaScript 中所有都是对象，JavaScript 的函数对象中都包含了一个 “prototype” 内部属性，这个属性所对应的就是该函数对象的原型。在 JavaScript 中，原型也是一个对象，通过原型可以实现对象的属性继承。

而原型链：

当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会去它的`__proto__`隐式原型上查找，即它的构造函数的 prototype。如果还没有找到就会再在构造函数的 prototype 的`__proto__`中查找，这样一层一层向上查找就会形成一个链式结构，我们称为原型链。

**答案二：**

每一个实例对象上有一个`__proto__`属性，指向的构造函数的原型对象，构造函数的原型对象也是一个对象，也有`__proto__`属性，这样一层一层往上找的过程就形成了原型链。

要讲清楚这个问题，主要着重这几个方面：

- 什么是原型对象
- 构造函数, 原型对象, 实例的三角关系图
- 原型链如何形成


**原型对象**

在 JavaScript 中，除去一部分内建函数，绝大多数的函数都会包含有一个叫做 `prototype` 的属性，指向原型对象，

基于构造函数创建出来的实例, 都可以共享访问原型对象的属性。

例如我们的 `hasOwnProperty`, `toString` ⽅法等其实是 Obejct 原型对象的方法，它可以被任何对象当做⾃⼰的⽅法来使⽤。

`hasOwnProperty` 用于判断, 某个属性, 是不是自己的  (还是原型链上的)

来看一段代码：

```js
let person = { 
  name: "Tom", 
  age: 18, 
  job: "student"
}

console.log(person.hasOwnProperty("name")) // true 
console.log(person.hasOwnProperty("hasOwnProperty")) // false 
console.log(Object.prototype.hasOwnProperty("hasOwnProperty")) // true
```

可以看到，`hasOwnProperty` 并不是 `person` 对象的属性，但是 `person` 却能调用它。

那么 `person` 对象是如何找到 Object 原型中的 `hasOwnProperty` 的呢？这就要靠原型链的能力了。

需求: 简单绘制原型三角关系图!



**原型链**

在 JavaScript 中，每个对象中都有一个 `__proto__` 属性，这个属性指向了当前对象的构造函数的原型。

对象可以通过自身的 `__proto__`属性与它的构造函数的原型对象连接起来，

而因为它的原型对象也有 `__proto__`，因此这样就串联形成一个链式结构，也就是我们称为的原型链。

### 作用域链

JavaScript 在执⾏过程中会创建一个个的**可执⾏上下⽂**。 (每个函数执行都会创建这么一个可执行上下文)

每个可执⾏上下⽂的词法环境中包含了对外部词法环境的引⽤，可通过该引⽤来获取外部词法环境中的变量和声明等。

这些引⽤串联起来，⼀直指向全局的词法环境，形成一个链式结构，被称为作⽤域链。

简而言之: 函数内部 可以访问到 函数外部作用域的变量,  而外部函数还可以访问到全局作用域的变量,

这样的变量作用域访问的链式结构, 被称之为作用域链

```js
let num = 1

function fn () {
  let a = 100
  function inner () {
    console.log(a)
    console.log(num)
  }
  inner()
}
fn()
```

下图为由多个可执行上下文组成的调用栈：

- 栈最底部为`全局可执行上下文`
- `全局可执行上下文` 之上有多个 `函数可执行上下文`
- 每个可执行上下文中包含了指向外部其他可执行上下文的引用，直到 `全局可执行上下文` 时它指向 `null`

js全局有全局可执行上下文, 每个函数调用时, 有着函数的可执行上下文, 会入js调用栈

每个可执行上下文, 都有者对于外部上下文词法作用域的引用, 外部上下文也有着对于再外部的上下文词法作用域的引用 

**=> 就形成了作用域链**

### 闭包

我将从一下 4 个方面展开讲一下闭包，分别是：闭包的定义，闭包的作用，闭包的优缺点，如何解决闭包带来的问题。

（1）闭包的定义

在 JavaScript 高级程序设计（第四版）中是这样解释的，闭包指的是一个引用了另一个函数作用域中变量的函数。所以说闭包的本质也是一个函数。
在 MDN 中的解释是，一个函数和上下文引用捆绑在一起，这样的组合就是闭包。简单理解就是函数 + 上下文引用。

（2）闭包的作用

闭包的作用就是为了解决变量污染

（3）闭包的优缺点

闭包延伸了变量的作用范围，可以解决一些变量污染问题。

也因为闭包延伸了变量的作用范围，闭包函数中的局部变量不会等着闭包函数执行完就销毁，而是等着所有的函数都调用完了它才会销毁，这样会导致内存泄漏。

（4）如何解决闭包带来的问题

解决闭包带来的内存泄漏问题的方法是：使用完闭包函数后手动释放。

### 递归及应用场景

递归：`递归函数`是一个`在函数内部调用自己`的`函数`

优点：结构清晰、可读性强

缺点：效率低、调用栈可能会溢出，其实每一次函数调用会在内存栈中分配空间，而每个进程的栈的容量是有限的，当调用的层次太多时，就会超出栈的容量，从而导致栈溢出，影响性能。

应用场景：浅拷贝转成深拷贝；遍历dom树

### 如何判断 this 的指向

1、`普通函数`中的this指向`window`

2、`定时器`中的this指向`window`

3、`箭头函数`没有this,它的this指向取决于`外部环境`、

4、`事件`中的this指向事件的`调用者`

5、 `构造函数`中this和原型对象中的this,都是指向构造函数`new 出来实例对象`

6、`类 class`中的this  指向由`constructor构造器new出来的实例对象`

7、`自调用函数`中的this  指向`window`

### call apply bind 的使用

共同点：都可以改变this指向;

不同点：

​			传参方式不同: call是一一传参; apply是数组/伪数组,自动遍历后逐一传参

​			执行机制不同: call和apply会立即调用函数; bind不会立即调用,而是得到一个修改this之后的新函数

应用场景:

​			call：数据类型检测

​			apply：伪数组转成真数组, 求数组最大值

​			bind：主要是修改`不需要立即执行的函数`，事件处理函数，定时器函数

### 数组常用 api 有哪些

concat()  方法用于合并两个或多个数组。**此方法不会更改现有数组**，而是返回一个新数组。

`find()` 方法返回数组中满足提供的测试函数的`第一个元素的值`。否则返回 [`undefined`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined)。

`findIndex()`方法返回数组中满足提供的测试函数的`第一个元素的索引`。否则返回-1。

`includes()` 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。

`indexOf()`方法返回在数组中可以找到一个`给定元素的第一个索引`，如果不存在，则返回-1。 （通常用它判断数组中有没有这个元素）

`join()` 方法将一个`数组`（或一个类数组对象）的所有元素`连接成`一个`字符串`并返回这个字符串。如果数组只有一个项目，那么将返回该项目而不使用分隔符。

`pop()`方法从数组中`删除最后一个元素`，并返回该元素的值。此方法更改数组的长度。

`push()` 方法将`一个或多个元素添加到数组的末尾`，并返回该数组的新长度。该方法修改原有数组。

`shift()` 方法从数组中`删除第一个元素`，并返回该元素的值。此方法更改数组的长度。

`unshift()`方法将`一个或多个元素添加到数组的开头`，并返回该数组的新长度。该方法修改原有数组。

`splice()`方法通过`删除或替换`现有元素或者原地添加新的元素来修改数组，并以数组形式返回被修改的内容。**此方法会改变原数组**。

由被删除的元素组成的一个数组。如果只删除了一个元素，则返回只包含一个元素的数组。如果没有删除元素，则返回空数组。

`reverse()` 方法将数组中元素的`位置颠倒`，并返回该数组。**该方法会改变原数组**。

`sort()` 方法用原地算法对数组的元素进行`排序`，并返回数组。默认排序顺序是在将元素转换为字符串，然后比较它们的UTF-16代码单元值序列时构建的

### reduce 的使用格式

概念：给每一个元素执行一次回调

语法：

```js
//  sum初始值: 一般给0,否则空数组reduce报错
let sum = 0
// sum:上一次的返回值 value:当前元素值 index:当前下标
arr.reduce((sum,value,index)=>{ 
  // return: 最后一次回调的结果
return
}, 0)
```

应用场景：数组求和，求数组最大值

```js
// 数组求和
arr.reduce((sum, value) => {
      return sum += value
    }, 0)
```

```js
// 数组最大值
arr.reduce((sum, value) => {
      if (sum > value) {
        return sum
      } else {
        return value
      }
    }, 0)
```

### 什么是回调地狱, 如何解决

介绍回调地狱之前介绍一下异步操作：

由于操作系统`分片工作机制`，文件的输出顺序是不确定的，后执行的可能会先输出。若要保证输出顺序，就要在前一个异步操作的回调函数中调用后一个异步操作。

当异步操作越多，这种嵌套的层级也就越复杂，就形成了回调地狱，这样`不利于代码的维护`。

如何解决回调地狱呢？在 ES6 中新增了 Promise 对象来解决这个问题。

### promise 的使用

Promise 是异步编程的一种解决方案，是为了解决异步处理回调地狱而产生的。

**Promise 有 3 种状态：**

`Fulfilled` 为成功的状态，`Rejected` 为失败的状态，`Pending` 等待。

**Promise 对象**

我们使用new来构建一个Promise，Promise的构造函数接收一个参数，是函数，并且传入两个参数： resolve，reject， 分别表示异步操作执行成功后的回调函数和异步操作执行失败后的回调函数。

**Promise 实例对象**

.then() 方法，指定 resolved 状态和 reject 状态的回调函数 

.catch() 方法，获取异常信息

.finally() 方法，成功与否都会执行（不是正式标准） 

 **Promise 的静态方法**（将 函数 挂载到 函数上）

.all()方法，所有的异步 promise 调用完毕时，才执行 function

.race()方法，竞速,谁先回来结果就是谁

.resolve()方法，成功操作

.reject()方法，失败操作

###  async await 的使用方法

async await 是 ES7 里面的新语法、它的作用就是 async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。它可以很好的替代 promise 中的 then。

`async`函数返回一个 Promise 对象，可以使用`then`方法添加回调函数。当函数执行的时候，一旦遇到`await`就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。

### 相较于 Promise，async/await有何优势？

1. 同步化代码的阅读体验（Promise 虽然摆脱了回调地狱，但 then 链式调⽤的阅读负担还是存在的）
2. 和同步代码更一致的错误处理方式（ async/await 可以⽤成熟的 try/catch 做处理，比 Promise 的错误捕获更简洁直观） 
3. 调试时的阅读性, 也相对更友好

### new背后做了哪些事情

1、`创建一个空对象` 并且 this 变量引入该对象,同时还继承了函数的原型

2、`设置原型链` 空对象指向构造函数的原型对象

3、`执行函数体` 修改构造函数 this 指针指向空对象,并执行函数体

4、`判断返回值` 返回对象就用该对象,没有的话就创建一个对象

### 防抖和节流

防抖（debounce）指的是：`频繁触发`某个操作时，`只执行最后一次`。

防抖的应用场景：搜索框只在输入完后，才执行查询的请求。

好处：这样可以有效减少请求的次数，节省网络资源。

节流（throttle）指的是：`单位时间内`，`频繁`触发同一个操作，`只会触发 1 次`。

应用场景：射击游戏中，单位时间内只能发射一颗子弹。

### 高阶函数

高阶函数是指使用其他函数作为参数、或者返回一个函数作为结果的函数。

### 函数柯里化

柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数且返回结果的新函数的技术。

函数柯里化的好处：

（1）参数复用：需要输入多个参数，最终只需输入一个，其余通过 arguments 来获取

（2）提前确认：避免重复去判断某一条件是否符合，不符合则 return 不再继续执行下面的操作

（3）延迟运行：避免重复的去执行程序，等真正需要结果的时候再执行 

### for in 和 for of 的区别

1、推荐在循环`对象属性`的时候使用 for...in，在`遍历数组`的时候使用 for...of 

2、for...in 循环出的是 key，for...of 循环出的是 value

3、注意，for...of 是 ES6 新引入的特性。修复了 ES5 引入的 for...in 的不足

4、for...of 不能循环普通的对象，需要通过和 Object.keys()搭配使用



### 深拷贝和浅拷贝

浅拷贝：创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是`基本类型`，拷贝的就是`基本类型的值`，如果属性是`引用类型`，拷贝的就是`内存地址` ，所以`如果其中一个对象改变了这个地址，就会影响到另一个对象`。

深拷贝会拷贝所有的属性，并拷贝属性指向的动态分配的内存。当`对象和它所引用的对象一起拷贝`时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且`花销较大`。`拷贝前后两个对象互不影响`。

### 宏任务 微任务 是什么

宏任务: 主线程代码, setTimeout 等属于宏任务,  上一个宏任务执行完, 才会考虑执行下一个宏任务

微任务: promise .then .catch的需要执行的内容, 属于微任务, 满足条件的微任务, 会被添加到当前宏任务的最后去执行

### js的执行机制是怎么样的？

js是一个`单线程`、`异步`、`非阻塞I/O模型`、 `event loop事件循环`的执行机制,所有任务可以分成两种，一种是`同步任务`（synchronous），另一种是`异步任务`（asynchronous）。

`同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务`。

`异步任务指的是，不进入主线程、而进入"任务队列"（task queue）的任务，只有"任务队列"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行`。

### 垃圾回收机制

JS 的垃圾回收机制是为了以`防止内存泄漏`，内存泄漏的含义就是当已经不需要某块内存时这块内存还存在着，垃圾回收机制就是间歇的不定期的寻找到不再使用的变量，并释放掉它们所指向的内存。

JS 中最常见的垃圾回收方式是`标记清除`。

工作原理：是当变量进入环境时，将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。

### JavaScript垃圾回收是怎么做的？

JS中内存的分配和回收都是自动完成的，内存在不使用的时候会被垃圾回收器自动回收。

正因为垃圾回收器的存在，许多人认为JS不用太关心内存管理的问题，

但如果不了解JS的内存管理机制，我们同样非常容易成内存泄漏（内存无法被回收）的情况。

**内存的生命周期**

JS环境中分配的内存, 一般有如下生命周期：

1. 内存分配：当我们声明变量、函数、对象的时候，系统会自动为他们分配内存

2. 内存使用：即读写内存，也就是使用变量、函数等

3. 内存回收：使用完毕，由垃圾回收自动回收不再使用的内存

   全局变量一般不会回收, 一般局部变量的的值, 不用了, 会被自动回收掉

内存分配:

```jsx
// 为变量分配内存
let i = 11
let s = "ifcode"

// 为对象分配内存
let person = {
    age: 22,
    name: 'ifcode'
}

// 为函数分配内存
function sum(a, b) {
    return a + b;
}
```

**垃圾回收算法说明**

所谓垃圾回收, 核心思想就是如何判断内存是否已经不再会被使用了, 如果是, 就视为垃圾, 释放掉

下面介绍两种常见的浏览器垃圾回收算法: 引用计数 和 标记清除法

**引用计数**

IE采用的引用计数算法, 定义“内存不再使用”的标准很简单，就是看一个对象是否有指向它的引用。

如果没有任何变量指向它了，说明该对象已经不再需要了。

```jsx
// 创建一个对象person, person指向一块内存空间, 该内存空间的引用数 +1
let person = {
    age: 22,
    name: 'ifcode'
}

let p = person   // 两个变量指向一块内存空间, 该内存空间的引用数为 2
person = 1       // 原来的person对象被赋值为1，对象内存空间的引用数-1,
                 // 但因为p指向原person对象，还剩一个对于对象空间的引用, 所以对象它不会被回收

p = null         // 原person对象已经没有引用，会被回收
```

由上面可以看出，引用计数算法是个简单有效的算法。

**但它却存在一个致命的问题：循环引用。**

如果两个对象相互引用，尽管他们已不再使用，垃圾回收器不会进行回收，导致内存泄露。

```jsx
function cycle() {
    let o1 = {}
    let o2 = {}
    o1.a = o2
    o2.a = o1 
    return "Cycle reference!"
}

cycle()
```
**标记清除算法**

现代的浏览器已经不再使用引用计数算法了。

现代浏览器通用的大多是基于标记清除算法的某些改进算法，总体思想都是一致的。

标记清除法:

- 标记清除算法将“不再使用的对象”定义为“无法达到的对象”。 

- 简单来说，就是从根部（在JS中就是全局对象）出发定时扫描内存中的对象。

- 凡是能从根部到达的对象，都是还需要使用的。那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收。

从这个概念可以看出，无法触及的对象包含了没有引用的对象这个概念（没有任何引用的对象也是无法触及的对象）。

根据这个概念，上面的例子可以正确被垃圾回收处理了。

参考文章：[JavaScript内存管理](

### ES6 新特性

ES6是2015年推出的一个新的版本、这个版本相对于ES5的语法做了很多的优化、例如：新增了let、const，箭头函数，promise，模块化，结构赋值，class类。

let和const具有块级作用域，不存在变量提升的问题。新增了箭头函数，简化了定义函数的写法，同时可以巧用箭头函数的this、（注意箭头函数本身没有this,它的this取决于外部的环境），新增了promise解决了回调地域的问题，新增了模块化、利用import 、export来实现导入、导出。新增了结构赋值，ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。新增了class类的概念，它类似于对象。

### var let const 的区别

我将从 3 个方面阐述var let const 之间的区别：

（1）变量声明

var 声明变量可以重复声明；var 可以在声明之前访问变量，存在变量提升

let表示变量：let 不能重复声明；因为 let 有暂存死区，在声明之前访问变量会报错，所以let 只能先声明再使用

const 表示常量：const 在声明的时候就必须赋值，否则会报错；如果 const 声明的是一个对象，对象所指向的地址不能改变，而变量对象成员是可以修改的；const 和 let 一样在声明之前访问变量会报错

（2）是否受作用域限制

var 是不受限于块级作用域的，而 let，const是受限于块级作用域

（3）是否会与 window 映射

var 会与 window 相映射（会挂一个属性），而 let 不与 window 相映射

### 请描述一下ES6中的class类? 

ES6中的class可以把它看成是ES5中`构造函数的语法糖`，ES6 用 `class 关键字`定义类，里面有构造方法，类之间通过 `extends 关键字`实现，子类必须在 `constructor 方法`中调用 `super 方法`



es6中的class可以把它看成是es5中`构造函数的语法糖`，它简化了构造函数的写法， 类的`共有属性`放到`constructor里面 `

1. 通过class 关键字创建类, 类名我们还是习惯性定义首字母大写 

2. 类里面有个constructor 函数,可以接受传递过来的参数,同时返回实例对象 

3. constructor 函数只要 new 生成实例时,就会自动调用这个函数, 如果我们不写这个函数,类也会自动生成这个函数 

4. 多个函数方法之间不需要添加逗号分隔 

5. 生成实例 new 不能省略 

6. 语法规范, 创建类 类名后面不要加小括号,生成实例 类名后面加小括号, 构造函数不需要加function 

   1. 继承中,如果实例化子类输出一个方法,先看子类有没有这个方法,如果有就先执行子类的 

   2. 继承中,如果子类里面没有,就去查找父类有没有这个方法,如果有,就执行父类的这个方法(就近原则) 

   3. 如果子类想要继承父类的方法,同时在自己内部扩展自己的方法,利用super 调用 父类的构造函数,super 必须在子类this之前调用 

7. 时刻注意this的指向问题,类里面的共有的属性和方法一定要加this使用. 

   1. constructor中的this指向的是new出来的实例对象 
   2. 自定义的方法,一般也指向的new出来的实例对象 
   3. 绑定事件之后this指向的就是触发事件的事件源 
   4. 在 ES6 中类没有变量提升，所以必须先定义类，才能通过类实例化对象

### 箭头函数有哪些特征，请简单描述一下它？

1. 箭头函数没有自己的this，this指向**定义**箭头函数时所处的**外部执行环境**的this

2. 即时调用call/apply/bind也无法改变箭头函数的this

3. 箭头函数本身`没有名字`

4. 箭头函数`不能new`，**会报错**

5. 箭头函数`没有arguments`，在箭头函数内访问这个变量访问的是**外部执行环境**的arguments

6. 箭头函数`没有prototype`

### 常用的数组方法有哪些？

 concat()  方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。

 `**find()**` 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 [`undefined`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined)。

`**findIndex()**`方法返回数组中满足提供的测试函数的第一个元素的**索引**。否则返回-1。

`**includes()**` 方法用来判断一个数组是否`包含`一个指定的值，根据情况，如果包含则返回 true，否则返回false。

`**indexOf()**`方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。 （通常用它判断数组中有没有这个元素）

`**join()**` 方法将一个`数组`（或一个[类数组对象](https://developer.mozilla.org/zh-CN//docs/Web/JavaScript/Guide/Indexed_collections#Working_with_array-like_objects)）的所有元素`连接成`一个`字符串`并返回这个字符串。如果数组只有一个项目，那么将返回该项目而不使用分隔符。

`**pop()**`方法从数组中删除最后一个元素，并返回该元素的值。此方法更改数组的长度。

`**push()**` 方法将一个或多个元素添加到数组的末尾，并返回该数组的新长度。

`**shift()**` 方法从数组中删除**第一个**元素，并返回该元素的值。此方法更改数组的长度。

**unshift()** 方法将一个或多个元素添加到数组的**开头**，并返回该数组的**新长度(该**方法修改原有数组**)**。

**splice()** 方法通过`删除或替换`现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。此方法会改变原数组。

由被删除的元素组成的一个数组。如果只删除了一个元素，则返回只包含一个元素的数组。如果没有删除元素，则返回空数组。

`**reverse()**` 方法将数组中元素的位置`颠倒`，并返回该数组。该方法会改变原数组。

`**sort()**` 方法用[原地算法](https://en.wikipedia.org/wiki/In-place_algorithm)对数组的元素进行`排序`，并返回数组。默认排序顺序是在将元素转换为字符串，然后比较它们的UTF-16代码单元值序列时构建的

### 数组有哪几种循环方式？分别有什么作用？

`**every()**` 方法测试一个数组内的`所有元素是否都能通过某个指定函数的测试`。它返回一个布尔值。

`**filter()**` 方法创建一个新数组, 其包含`通过所提供函数实现的测试的所有元素`。

`**forEach()**` 方法对数组的每个元素执行一次提供的函数。

`**some()**` 方法测试是否`至少有一个元素可以通过被提供的函数方法`。该方法返回一个Boolean类型的值。

### 常用的字符串方法有哪些？

**charAt()** 方法从一个字符串中返回指定的字符。

**concat()** 方法将一个或多个字符串与原字符串连接合并，形成一个新的字符串并返回。

**includes()** 方法用于判断一个字符串是否包含在另一个字符串中，根据情况返回 true 或 false。

indexOf() 方法返回调用它的 [`String`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/String) 对象中第一次出现的指定值的索引，从 `fromIndex` 处进行搜索。如果未找到该值，则返回 -1。

**match()** `方法检索`返回一个字符串匹配正则表达式的的结果。

**padStart()** 方法用另一个字符串填充当前字符串(重复，如果需要的话)，以便产生的字符串达到给定的长度。填充从当前字符串的开始(左侧)应用的。 (常用于时间`补0`)

**replace()** 方法返回一个由替换值（`replacement`）`替换`一些或所有匹配的模式（`pattern`）后的新字符串。模式可以是一个字符串或者一个[正则表达式](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/RegExp)，替换值可以是一个字符串或者一个每次匹配都要调用的回调函数。

原字符串不会改变。

**slice()** 方法`提取某个字符串的一部分`，并返回一个新的字符串，且不会改动原字符串。

`**split()** `方法`使用指定的分隔符字符串`将一个[`String`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/String)对象`分割成字符串数组`，以将字符串分隔为子字符串，以确定每个拆分的位置。 

`**substr()**` 方法返回一个字符串中从指定位置开始到指定字符数的字符。

**trim()** 方法会从一个字符串的`两端删除空白字符`。在这个上下文中的空白字符是所有的空白字符 (space, tab, no-break space 等) 以及所有行终止符字符（如 LF，CR）。

### 请写至少三种数组去重的方法？（原生js）

filter、ES6 Set去重、双for循环然后利用splice去重

```javascript
//利用filter
function unique(arr) {
  return arr.filter(function(item, index, arr) {
    //当前元素，在原始数组中的第一个索引==当前索引值，否则返回当前元素
    return arr.indexOf(item, 0) === index;
  });
}
    var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
        console.log(unique(arr))
```

```javascript
//利用ES6 Set去重（ES6中最常用）
function unique (arr) {
  return Array.from(new Set(arr))
}
var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
console.log(unique(arr))
 //[1, "true", true, 15, false, undefined, null, NaN, "NaN", 0, "a", {}, {}]
```

```javascript
//利用for嵌套for，然后splice去重（ES5中最常用）
function unique(arr){            
        for(var i=0; i<arr.length; i++){
            for(var j=i+1; j<arr.length; j++){
                if(arr[i]==arr[j]){         //第一个等同于第二个，splice方法删除第二个
                    arr.splice(j,1);
                    j--;
                }
            }
        }
return arr;
}
var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
    console.log(unique(arr))
    //[1, "true", 15, false, undefined, NaN, NaN, "NaN", "a", {…}, {…}]     //NaN和{}没有去重，两个null直接消失了
```

### 请写出至少两种常见的数组排序的方法（原生js）

快速排序、插入排序、冒泡排序

```javascript
//快速排序
function quickSort(elements){
    if(elements.length <=1){
      return elements;  
    }
  var pivotIndex=Math.floor(elements.length / 2);
  var pivot=elements.splice(pivotIndex,1)[0];
  var left=[];
  var right=[];
  for(var i=0;i<elements.length;i++){
    if(elements[i] < pivot){
        left.push(elements[i]);
    }else{
       right.push(elements[i]);
    }
  } 
return  quickSort(left).concat([pivot],quickSort(right));
//concat()方法用于连接两个或者多个数组；该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。
};
var elements=[3,5,6,8,2,4,7,9,1,10];
document.write(quickSort(elements)); 

```

```javascript
//插入排序
function sort(elements){
    // 假设第0个元素是一个有序数列，第1个以后的是无序数列，
    // 所以从第1个元素开始将无序数列的元素插入到有序数列中去
    for (var i =1; i<=elements.length; i++) {
        // 升序
        if(elements[i] < elements[i-1]){
            // 取出无序数列中的第i个作为被插入元素
            var guard=elements[i];
            //记住有序数列的最后一个位置，并且将有序数列的位置扩大一个
            var j=i-1;
            elements[i]=elements[j];
            // 比大小;找到被插入元素所在位置
            while (j>=0 && guard <elements[j]) {
                elements[j+1]=elements[j];
                j--;
            }
            elements[j+1]=guard; //插入
        }
    }
}
var elements=[3,5,6,8,2,4,7,9,1,10];
document.write('没调用之前：'+elements);
document.write('<br>');
sort(elements);
document.write('被调用之后：'+elements);
```

```javascript
//冒泡排序
function sort(elements){
    for(var i=0;i<elements.length-1;i++){
       for(var j=0;j<elements.length-1-i;j++){
          if(elements[j] > elements[j+1]){
               var  swap=elements[j];
               elements[j]=elements[j+1];
               elements[j+1]=swap;
          }
       }
    }
}
var elements=[3,5,6,8,2,4,7,9,1,10];
console.log('before'+elements);
sort(elements);
console.log('after'+elements);
```

### 知道lodash吗？它有哪些常见的API   ？

Lodash是一个`一致性、模块化、高性能`的 JavaScript 实用`工具库`。

_.cloneDeep     深度拷贝

_.reject    根据条件去除某个元素。

_.drop(array, [n=1] )   作用：将 `array` 中的前 `n` 个元素去掉，然后返回剩余的部分.

### 谈谈set 、 map 是什么？ 

set 是es6 提供的一种新的`数据结构`，它`类似于数组`，但是`成员的值都是唯一的`。数组去重

map 是es6 提供的一种新的`数据结构`,它`类似于对象`，也是`键值对的集合`，但是键的范围不仅限于字符串，各种类型的值都可以当做键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。

### 解释下什么是变量声明提升？

变量提升（hoisting），是负责解析执行代码的 JavaScript 引擎的工作方式产生的一个特性。

JS引擎在运行一份代码的时候，会按照下面的步骤进行工作：

1. 首先，对代码进行预解析，并获取声明的所有变量

2. 然后，将这些变量的声明语句统一放到代码的最前面

3. 最后，开始一行一行运行代码

我们通过一段代码来解释这个运行过程：

```js
console.log(a) 

var a = 1 

function b() { 
  console.log(a) 
}

b() // 1
```

上⾯这段代码的实际执⾏顺序为: 

1. JS引擎将 `var a = 1` 分解为两个部分：变量声明语句 `var a = undefined` 和变量赋值语句 `a = 1` 
2. JS引擎将 `var a = undefined` 放到代码的最前面，而 `a = 1` 保留在原地 

也就是说经过了转换，代码就变成了:

```js
var a = undefined

console.log(a) // undefined 

a = 1

function b() { 
  console.log(a) 
}

b() // 1
```

变量的这一转换过程，就被称为变量的声明提升。

而这是不规范, 不合理的, 我们用的  let 就没有这个变量提升的问题

### JS 的参数是以什么方式进行传递的？

基本数据类型和复杂数据类型的数据在传递时，会有不同的表现。

**基本类型：是值传递**！

基本类型的传递方式比较简单，是按照 `值传递` 进行的。

```js
let a = 1

function test(x) { 
  x = 10  // 并不会改变实参的值
  console.log(x)
}

test(a) // 10 
console.log(a) // 1
```



**复杂类型: 传递的是地址! (变量中存的就是地址)**

来看下面的代码：

```js
let a = {
  count: 1 
}

function test(x) { 
  x.count = 10
  console.log(x)
}

test(a) // { count: 10 }
console.log(a) // { count: 10 }
```

从运行结果来看，函数内改变了参数对象内的 `count` 后，外部的实参对象 `a` 的内容也跟着改变了，所以传递的是地址。

思考题:

```js
let a = {
  count: 1 
}; 

function test(x) { 
  x = { count: 20 };
  console.log(x); 
}

test(a); // { count: 20 }
console.log(a); // { count: 1 }
```

我们会发现外部的实参对象 `a` 并没有因为在函数内对形参的重新赋值而被改变！

因为当我们直接为这个形参变量重新赋值时，其实只是让形参变量指向了别的堆内存地址，而外部实参变量的指向还是不变的。

下图展示的是复杂类型参数传递后的状态：


下图展示的是重新为形参赋值后的状态：


### JavaScript中数据类型的隐式转换规则(了解)

在if语句、逻辑语句、数学运算逻辑、== 等情况下都可能出现隐式类型转换。

下表展示了一系列原始值，通过隐式转换成数字、字符串、布尔类型后所得到的值：

坑: 判断时,  尽量不要用 `= =` , 要用 `= = =` ( 两个等号判断,  如果类型不同,  默认会进行隐式类型转换再比较)

### 如何判断是否是数组？

方法一：使用 `toString` 方法

```js
function isArray(arg) {
	return Object.prototype.toString.call(arg) === '[object Array]'
}

let arr = [1,2,3]
isArray(arr)  // true
```

方法二：使用 ES6 新增的 `Array.isArray` 方法

```js
let arr = [1,2,3]
Array.isArray(arr) // true
```

### 谈谈你对this的理解？

`this` 是一个在运行时才进行绑定的引用，在不同的情况下它可能会被绑定不同的对象。

**默认绑定** (指向window的情况)  (函数调用模式 fn() )

默认情况下，`this` 会被绑定到全局对象上，比如在浏览器环境中就为`window`对象，在node.js环境下为`global`对象。

如下代码展示了这种绑定关系：

```js
message = "Hello"; 

function test () { 
  console.log(this.message); 
}

test() // "Hello"
```

**隐式绑定** (谁调用, this指向谁) (方法调用模式 obj.fn() )

如果函数的调用是从对象上发起时，则该函数中的 `this` 会被自动隐式绑定为对象：

```js
function test() {
	console.log(this.message); 
}

let obj = {
  message: "hello,world",
  test: test
}

obj.test() // "hello,world"
```

**显式绑定** (又叫做硬绑定)  (上下文调用模式, 想让this指向谁, this就指向谁)

硬绑定 => call  apply  bind

可以显式的进行绑定：

```js
function test() {
	console.log(this.message); 
}

let obj1 = {
  message: "你好世界123"
}

let obj2 = {
  message: "你好世界456"
}

test.bind(obj1)() // "你好世界123"
test.bind(obj2)() // "你好世界456"
```

**new 绑定** (构造函数模式)

另外，在使用 `new` 创建对象时也会进行 `this` 绑定

当使用 `new` 调用构造函数时，会创建一个新的对象并将该对象绑定到构造函数的 `this` 上：

```js
function Greeting(message) {
	this.message = message;
}

var obj = new Greeting("hello,world")
obj.message // "hello,world"
```

### `undefined + 2` 和 `null + 2` 的结果是什么

 `undefined + 2` 的结果是NaN；`null + 2` 的结果是 2

里面存在隐式转换，undefined 转换成 数字类型是 NaN;null 转换成 数字类型是 0

### 说一下 DOM 事件流

**事件流**

⼜称为事件传播，是⻚⾯中接收事件的顺序。DOM2级事件规定的事件流包括了3个阶段：

- 事件捕获阶段（capture phase）
- 处于⽬标阶段（target phase）
- 事件冒泡阶段（bubbling phase）


如上图所示，事件流的触发顺序是：

1. 事件捕获阶段，为截获事件提供了机会 
2. 实际的⽬标元素接收到事件
3. 事件冒泡阶段，可在这个阶段对事件做出响应

**事件冒泡（Event Bubbling）**

事件开始由最具体的元素（⽂档中嵌套层次最深的那个节点）接收到后，开始逐级向上传播到较为不具体的节点。

```html
<html>
  
  <head> 
    <title>Document</title> 
  </head>
  
  <body> 
    <button>按钮</button> 
  </body> 
  
</html>
```

如果点击了上面页面代码中的 `<button>` 按钮，那么该 `click` 点击事件会沿着 DOM 树向上逐级传播，在途经的每个节点上都会发生，具体顺序如下：

1. button 元素
2. body 元素
3. html 元素
4. document 对象

**事件捕获（Event Capturing）**

事件开始由较为不具体的节点接收后，然后开始逐级向下传播到最具体的元素上。

事件捕获的最大作用在于：事件在到达预定⽬标之前就可以捕获到它。

如果仍以上面那段 HTML 代码为例，当点击按钮后，在事件捕获的过程中，document 对象会首先接收到这个 `click` 事件，然后再沿着 DOM 树依次向下，直到 `<button>`。具体顺序如下：

1. document 对象
2. html 元素
3. body 元素
4. button 元素

### 说一下事件委托

事件委托，就是利用了事件冒泡的机制，在较上层位置的元素上添加一个事件监听函数，来管理该元素及其所有子孙元素上的某一类的所有事件。

适用场景：在绑定大量事件的时候，可以选择事件委托

**优点**

- 事件委托可以减少事件注册数量，节省内存占⽤!
- 当新增⼦元素时，⽆需再次做事件绑定，因此非常适合动态添加元素   (vue解析模板时, 会对新创建的元素, 额外进行绑定的)

### JS 数据类型（8 种，按照 MDN 上面去说）

ES5 的时候数据类型有 6 种：number， string， boolean， null， undefined， array， function， object

ES6 新增了 symbol， 表示独一无二的值，最大的用法是用来定义对象的唯一属性名。

谷歌67版本中还出现了一种 `bigInt`。是指安全存储、操作大整数。

### 数组的 push 和 pop 方法的返回值是什么

`push()` 方法将一个或多个元素添加到数组的末尾，并`返回该数组的新长度`。

`pop()`方法从数组中删除最后一个元素，并`返回该元素的值`。此方法更改数组的长度。

### 说一下 bind、apply、call 的区别

共同点：都可以改变this指向;

不同点：

​			传参方式不同: call是一一传参; apply是数组/伪数组,自动遍历后逐一传参

​			执行机制不同: call和apply会立即调用函数; bind不会立即调用,而是得到一个修改this之后的新函数

应用场景:

​			call：数据类型检测

​			apply：伪数组转成真数组, 求数组最大值

​			bind：主要是修改`不需要立即执行的函数`，事件处理函数，定时器函数

### 假如有 10000 个元素需要添加到页面上，你觉得怎么操作性能最好（考察`文档碎片`）

```html
<script>
	 /* console.time('耗时')
    for (let i = 1; i <= 1000; i++) {
      document.body.innerHTML = document.body.innerHTML + `<div>${i}</div>`
    }
    console.timeEnd('耗时') // 1586.053955078125 ms */

    /* console.time('耗时')
    let str = ''
    for (let i = 1; i <= 1000; i++) {
      str += `<div>${i}</div>`
    }
    document.body.innerHTML = str
    console.timeEnd('耗时') // 2.5810546875 ms */

    /* console.time('耗时')
    const arr = []
    for (let i = 1; i <= 1000; i++) {
      arr.push(`<div>${i}</div>`)
    }
    document.body.innerHTML = arr.join('')
    console.timeEnd('耗时') // 2.883056640625 ms */

    /* console.time('耗时')
    for (let i = 1; i <= 1000; i++) {
      const oDiv = document.createElement('div')
      // 更灵活
      oDiv.innerHTML = i
      oDiv.onclick = function () { }
      oDiv.style.backgroundColor = 'red'
      document.body.appendChild(oDiv)
    }
    console.timeEnd('耗时') // 7.409912109375 ms */ 

    console.time('耗时')
    // 篮子，“文档碎片”
    const oFrag = document.createDocumentFragment()
    for (let i = 1; i <= 1000; i++) {
      const oDiv = document.createElement('div')
      oDiv.innerHTML = i
      oFrag.appendChild(oDiv)
    }
    document.body.appendChild(oFrag)
    console.timeEnd('耗时') // 13.442138671875 ms
</script>
```

### 什么是伪数组，伪数组怎么转真数组

ES6：Array.from()

... 展开运算符(只能处理迭代数据)

ES5：Array.prototype.slice.call(aDiv)    [].slice.call(aDiv)    [].__proto__.slice.call(aDiv)

### arguments 是什么

所有实参的集合,是一个伪数组

### 函数传参，传递复杂数据类型和简单数据类型有什么区别

传递复杂数据类型传递的是引用的地址，修改会改变

简单数据类型传递的是具体的值，不会相互影响

```js
/* let a = 8
    function fn(a) {
      a = 9
    }
    fn(a)
    console.log(a) // 8 */

    let a = { age: 8 }
    function fn(a) {
      a.age = 9
    }
    fn(a)
    console.log(a.age) // 9
```

### new 的执行过程

（1）创建一个空对象，并把 this 变量引入该对象，同时还能继承了函数的原型。

（2）设置原型链，空对象指向构造函数的原型对象

（3）执行函数体，修改构造函数 this 指针指向空对象，并执行函数体

（4）判断返回值，返回对象就用该对象,没有的话就创建一个对象

### 你平常怎么判断数据类型，你觉得怎样判断才是比较准确的

object.proptype.tostring.call() 可以判断所有数据类型

### 说一下 Promise

Promise 是 ES6 提出的解决回调嵌套问题的。

Promise 状态有三种，Fulfilled 为成功的状态，Rejected 为失败的状态，Pending 为等待加载状态。

Promise 实例对象的方法有 .then() 指定 resolved 状态和 reject 状态的回调函数; .catch() 获取异常信息; .finally() 成功与否都会执行。

Promise 静态方法有 .all() 所有的结果按顺序一起返回，如果有错误返回第一个错误结果；.race() 竞速,谁先回来结果就是谁; .resolve() 成功操作; .reject() 失败操作。

### 说一下 DOM 事件流的三个阶段

事件捕获阶段,事件目标阶段,事件冒泡阶段

### 说一下事件委托

事件委托，就是利用了事件冒泡的机制，在较上层位置的元素上添加一个事件监听函数，来管理该元素及其所有子孙元素上的某一类的所有事件。

适用场景：在绑定大量事件的时候，可以选择事件委托

**优点**

- 事件委托可以减少事件注册数量，节省内存占⽤!
- 当新增⼦元素时，⽆需再次做事件绑定，因此非常适合动态添加元素   (vue解析模板时, 会对新创建的元素, 额外进行绑定的)

### 说一下 Event Loop

JS 代码的执行分为同步代码（任务）和异步代码（任务）；

当碰到同步代码时，直接在执行栈种执行；

当碰到异步代码并且时机符合时（例如定时器的时间到了）就把异步代码添加到任务队列当中；

**当执行栈中的同步代码执行完毕后**；

就去任务队列当中把异步代码拿到执行栈中进行执行；

这种反复轮询任务队列并把代码放到执行栈种执行的操作就是 EventLoop。

### 什么是重绘和回流，如何减少重绘和回流

（1）重绘：元素的外观属性发生变化（颜色、透明度、visibility、box-shadow、outline（边框））

（2）回流：几何属性发送变化（宽高、位置、大小），回流一定会触发重绘.

（3）如何减少重绘和回流?

1. 使用 cssText 或 class 批量更新元素样式

```css
/* oDiv.style.width = '100px';
oDiv.style.height = '100px';
oDiv.style.backgroundColor = 'red'; */

oDiv.className = 'box';
```

2. 使用文档碎片批量添加元素

3. transform 使用 3d 转换，开启 GPU 加速

4. 不要频繁获取元素的尺寸，因为浏览器为了保证获取值的正确性每次都会回流

5. 尽量不要用 Table 布局

### 前端安全了解吗，说一下 XSS 和 CSRF，以及怎么规避

（1）XSS：`跨域脚本攻击`

xss漏洞从本质上是将数据注入到静态代码中（如html和js等），当浏览器渲染html时就会触发注入的脚本引发xss攻击。

xss的产生原因就是对用户的输入过滤不严格，在能够同用户实现交互的地方更容易发现xss漏洞。

xss可以做什么？

1.xss攻击能达到什么成都造成多大的影响，很大程度上受到攻击者js水平影响。

2.xss攻击可以实现客户端和服务器的攻击。客户端攻击最常见的就是窃取cookie，另外还可以实现放马、刷流量等。服务端攻击可以劫持后台、篡改页面、蠕虫等。

xss的三种分类

1.反射性xss

2.存储型xss

3.dom树xss

（2）CSRF：`跨站请求伪造`

![img](https://img-blog.csdnimg.cn/37391ca77e534670aeb19f9fbc57ab5a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBASnVuRGFvNzM=,size_20,color_FFFFFF,t_70,g_se,x_16)

（3）比较xss和CSRF

**区别一：**

- `CSRF`：需要用户先登录网站`A`，获取 `cookie`
- `XSS`：不需要登录。

**区别二：（原理的区别）**

- `CSRF`：是利用`网站`A`本身的漏洞`，去请求网站`A`的`api`。
- `XSS`：是向`网站 `A` 注入 `JS`代码，然后执行 `JS` 里的代码，篡改网站`A`的内容`。

### 说一下 localstorage/sessionStorage/cookie 之间的差异

（1）`与服务器交互`：

- cookie 是网站为了`标示用户身份`而`储存在用户本地终端上`的数据（通常经过加密）
- cookie 始终会在`同源 http 请求头`中携带（即使不需要），在浏览器和服务器间来回传递
- sessionStorage 和 localStorage `不会自动把数据发给服务器`，`仅在本地保存`

（2）`存储大小`：

- cookie 数据根据不同浏览器限制，大小一般不能超过`4k`
- sessionStorage 和 localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到`5M`或更大

（3）`有期时间`：

- localStorage `存储持久数据`，`浏览器关闭后数据不丢失除非主动删除数据`
- sessionStorage 数据在`当前浏览器窗口关闭后自动删除`
- cookie 设置的`cookie过期时间之前一直有效`，`与浏览器是否关闭无关`

### 移动端 300ms 延迟是怎么回事，你是怎么处理的？

fastclick 可以解决在手机上点击事件的 300ms 延迟

zepto 的 touch 模块，tap 事件也是为了解决在 click 的延迟问题

触摸事件的响应顺序为 touchstart --> touchmove --> touchend --> click，也可以通过绑定 ontouchstart 事件，加快对事件的响应，解决 300ms 延迟问题

### 做移动端开发时，有没有碰到过什么问题（考察移动端的兼容性，搜索一下，找几条）

（1）IOS移动端click事件300ms的延迟相应

移动设备上的web网页是有300ms延迟的，往往会造成按钮点击延迟甚至是点击失效。

[这是由于区分单机事件和双击屏幕缩放的历史原因造成的。](https://thx.github.io/mobile/300ms-click-delay)

解决方式：

- fastclick可以解决在手机上点击事件的300ms延迟
- zepto的touch模块，tap事件也是为了解决在click的延迟问题
- 触摸屏的相应顺序为touchstart–>touchmove–>touchend–>click，也可以通过绑定ontouchstart事件，加快事件的响应，解决300ms的延迟问题。

（2）一些情况下对非可点击元素（label，span）监听click事件，iso下不会触发，

解决办法：`css增加cursor：pointer就搞定了。`

（3）h5底部输入框被键盘遮挡问题

h5页面有个很蛋疼的问题就是，当输入框在最底部，点击软键盘后输入框会被遮挡。可采用如下方式解决:

```javascript
var oHeight = $(document).height(); //浏览器当前的高度
$(window).resize(function(){
   if($(document).height() < oHeight){
       $("#footer").css("position","static");
   }else{
       $("#footer").css("position","absolute");
   }
 });
12345678
```

（4）不让 Android 手机识别邮箱

```html
<meta content="email=no" name="format-detection" />   
1
```

（5）禁止 iOS 识别长串数字为电话

```html
<meta content="telephone=no" name="format-detection" />
1
```

（6）禁止 iOS 弹出各种操作窗口

```html
-webkit-touch-callout:none
1
```

（7）消除 transition 闪屏

```html
-webkit-transform-style: preserve-3d;     /*设置内嵌的元素在 3D 空间如何呈现：保留 3D*/
-webkit-backface-visibility: hidden;      /*(设置进行转换的元素的背面在面对用户时是否可见：隐藏)*/
12
```

（8）iOS 系统中文输入法输入英文时，字母之间可能会出现一个六分之一空格

```html
可以通过正则去掉      this.value = this.value.replace(/\u2006/g, '');
1
```

（9）禁止ios和android用户选中文字

```css
-webkit-user-select:none
1
```

（10）CSS动画页面闪白，动画卡顿

解决方法:
1.尽可能地使用合成属性transform和opacity来设计CSS3动画，不使用position的left和top来定位
2.开启硬件加速

```css
-webkit-transform: translate3d(0, 0, 0);
     -moz-transform: translate3d(0, 0, 0);
      -ms-transform: translate3d(0, 0, 0);
          transform: translate3d(0, 0, 0);
1234
```

（11）fixed定位缺陷

**问题：**
ios下fixed元素容易定位出错，软键盘弹出时，影响fixed元素定位
android下fixed表现要比iOS更好，软键盘弹出时，不会影响fixed元素定位
ios4下不支持position:fixed

**解决方案：**
可用iScroll插件解决这个问题

### 移动端 1px 的问题了解吗？

前言
在移动端web开发中，UI设计稿中设置边框为1像素，前端在开发过程中如果出现border:1px，测试会发现在retina屏机型中，1px会比较粗，即是较经典的移动端1px像素问题。

产生原因
设备像素比：dpr=window.devicePixelRatio，也就是设备的物理像素与逻辑像素的比值。
在retina屏的手机上, dpr为2或3，css里写的1px宽度映射到物理像素上就有2px或3px宽度。
例如：iPhone6的dpr为2，物理像素是750（x轴）,它的逻辑像素为375。也就是说，1个逻辑像素，在x轴和y轴方向，需要2个物理像素来显示，即：dpr=2时，表示1个CSS像素由4个物理像素点组成，如下图所示：
![img](https://img-blog.csdnimg.cn/20200923205006680.jpg#pic_center)

解决方案

**1. 0.5px 方案**

在`IOS8+`，苹果系列都已经支持`0.5px`了，可以借助`媒体查询`来处理。

```js
/* 这是css方式*/
.border { border: 1px solid #999 }
@media screen and (-webkit-min-device-pixel-ratio: 2) {
    .border { border: 0.5px solid #999 }
}
/*ios dpr=2和dpr=3情况下border相差无几，下面代码可以省略*/
@media screen and (-webkit-min-device-pixel-ratio: 3) {
    .border { border: 0.333333px solid #999 }
}
```

`IOS7`及以下和`Android`等其他系统里，`0.5px`将会被显示为`0px`。那么我们就需要想出办法解决，说实在一点就是找到`Hack`。

解决方案是通过`JavaScript`检测浏览器能否处理`0.5px`的边框，如果可以，给`html`标签元素添加个`class。`

```js
if (window.devicePixelRatio && devicePixelRatio >= 2) {
  var testElem = document.createElement('div');
  testElem.style.border = '.5px solid transparent';
  document.body.appendChild(testElem);
}
if (testElem.offsetHeight == 1) {
  document.querySelector('html').classList.add('hairlines');
}
  document.body.removeChild(testElem);
}
// 脚本应该放在body内，如果在里面运行，需要包装 $(document).ready(function() {})
```

然后，极细的边框样式就容易了：

```js
div {
  border: 1px solid #bbb;
}
.hairlines div {
  border-width: 0.5px;  
}
```

优点：简单，不需要过多代码。
缺点：无法兼容安卓设备、 iOS 7及以下设备。

**2. 伪类+transform**

原理：把原先元素的`border`去掉，然后利用`:before`或者`:after`重做`border`，并 `transform`的`scale`缩小一半，原先的元素相对定位，新做的`border`绝对定位。

```js
/*手机端实现真正的一像素边框*/
.border-1px, .border-bottom-1px, .border-top-1px, .border-left-1px, .border-right-1px {
    position: relative;
}
```

```js
/*线条颜色 黑色*/
.border-1px::after, .border-bottom-1px::after, .border-top-1px::after, .border-left-1px::after, .border-right-1px::after {
    background-color: #000;
}
```

```js
/*底边边框一像素*/
.border-bottom-1px::after {
    content: "";
    position: absolute;
    left: 0;
    bottom: 0;
    width: 100%;
    height: 1px;
    transform-origin: 0 0;
}
```

```js
/*上边边框一像素*/
.border-top-1px::after {
    content: "";
    position: absolute;
    left: 0;
    top: 0;
    width: 100%;
    height: 1px;
    transform-origin: 0 0;
}
```

```js
/*左边边框一像素*/
.border-left-1px::after {
    content: "";
    position: absolute;
    left: 0;
    top: 0;
    width: 1px;
    height: 100%;
    transform-origin: 0 0;
}
```

```js
/*右边边框1像素*/
.border-right-1px::after {
    content: "";
    box-sizing: border-box;
    position: absolute;
    right: 0;
    top: 0;
    width: 1px;
    height: 100%;
    transform-origin: 0 0;
}
```

```js
/*边框一像素*/
.border-1px::after {
    content: "";
    box-sizing: border-box;
    position: absolute;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    border: 1px solid gray;
}
```

```js
/*设备像素比*/
/*显示屏最小dpr为2*/
@media (-webkit-min-device-pixel-ratio: 2) {
    .border-bottom-1px::after, .border-top-1px::after {
        transform: scaleY(0.5);
    }
```

```js
 .border-left-1px::after, .border-right-1px::after {
        transform: scaleX(0.5);
    }
```

```js
 .border-1px::after {
        width: 200%;
        height: 200%;
        transform: scale(0.5);
        transform-origin: 0 0;
    }
}
```

```js
/*设备像素比*/
@media (-webkit-min-device-pixel-ratio: 3)  {
    .border-bottom-1px::after, .border-top-1px::after {
        transform: scaleY(0.333);
    }
```

```js
 .border-left-1px::after, .border-right-1px::after {
        transform: scaleX(0.333);
    }
```

```js
.border-1px::after {
        width: 300%;
        height: 300%;
        transform: scale(0.333);
        transform-origin: 0 0;
    }
}
/*需要注意<input type="button">是没有:before, :after伪元素的*/
```

优点：所有场景都能满足，支持圆角(伪类和本体类都需要加border-radius)。
缺点：代码量也很大，对于已经使用伪类的元素(例如clearfix)，可能需要多层嵌套。

**3. viewport + rem**

同时通过设置对应`viewport`的`rem`基准值，这种方式就可以像以前一样轻松愉快的写`1px`了。
在`devicePixelRatio=2` 时，设置`meta：`

```js
<meta name="viewport" content="width=device-width,initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no">
```

在`devicePixelRatio=3` 时，设置`meta：`

```js
<meta name="viewport" content="width=device-width,initial-scale=0.3333333333333333, maximum-scale=0.3333333333333333, minimum-scale=0.3333333333333333, user-scalable=no">
```

实例验证：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <title>移动端1px问题</title>
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
    <meta name="viewport" id="WebViewport"
        content="width=device-width,initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no" />
    <style>
        html {
            font-size: 11px;
        }
        body {
            padding: 1rem;
        }
        * {
            padding: 0;
            margin: 0;
        }
        .item {
            padding: 1rem;
            border-bottom: 1px solid gray;
            font-size: 1.2rem;
        }
    </style>
    <script>
        var viewport = document.querySelector("meta[name=viewport]");
        var dpr = window.devicePixelRatio || 1;
        var scale = 1 / dpr;
        //下面是根据设备dpr设置viewport
        viewport.setAttribute(
            "content", +
            "width=device-width," +
            "initial-scale=" +
            scale +
            ", maximum-scale=" +
            scale +
            ", minimum-scale=" +
            scale +
            ", user-scalable=no"
        );

        var docEl = document.documentElement;
        var fontsize = 10 * (docEl.clientWidth / 320) + "px";
        docEl.style.fontSize = fontsize;
    </script>
</head>
<body>
    <div class="item">border-bottom: 1px solid gray;</div>
    <div class="item">border-bottom: 1px solid gray;</div>
</body>
</html>
```

优点：所有场景都能满足，一套代码，可以兼容基本所有布局。
缺点：老项目修改代价过大，只适用于新项目。

**4. border-image**

首先准备一张符合你要求的`border-image：`

![在这里插入图片描述](https://img-blog.csdnimg.cn/2020092321035633.png#pic_center)

通常手机端的页面设计稿都是放大一倍的，如：为适应`iphone retina`，设计稿会设计成`750*1334`的分辨率，图片按照2倍大小切出来，在手机端看着就不会虚化，非常清晰。同样，在使用`border-image`时，将`border`设计为物理`1px`，如下：

样式设置：

```js
.border-image-1px {
    border-width: 0 0 1px 0;
    border-image: url(linenew.png) 0 0 2 0 stretch;
}
```

上文是把`border`设置在边框的底部，所以使用的图片是`2px`高，上部的`1px`颜色为透明，下部的`1px`使用视觉规定的`border`的颜色。如果边框底部和顶部同时需要`border`，可以使用下面的`border-image`：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200923210629594.png#pic_center)

样式设置：

```js
.border-image-1px {
    border-width: 1px 0;
    border-image: url(linenew.png) 2 0 stretch;
}
```

到目前为止，我们已经能在`iPhone`上展现`1px border`的效果了。但是我们发现这样的方法在非视网膜屏上会出现`border`显示不出来的现象，于是使用`Media Query`做了一些兼容，样式

设置如下

```js
.border-image-1px {
    border-bottom: 1px solid #666;
} 

@media only screen and (-webkit-min-device-pixel-ratio: 2) {
    .border-image-1px {
        border-bottom: none;
        border-width: 0 0 1px 0;
        border-image: url(../img/linenew.png) 0 0 2 0 stretch;
    }
}
```

优点：可以设置单条,多条边框，没有性能瓶颈的问题
缺点：修改颜色麻烦, 需要替换图片；圆角需要特殊处理，并且边缘会模糊

**5. background-image**

`background-image`跟`border-image`的方法一样，你要先准备一张符合你要求的图片：

![img](https://img-blog.csdnimg.cn/20200923210813984.png#pic_center)

此例是准备将`border`设置在底部 样式设置：

```js
.background-image-1px {
  background: url(../img/line.png) repeat-x left bottom;
  background-size: 100% 1px;
}
```

优点：可以设置单条,多条边框，没有性能瓶颈的问题。
缺点：修改颜色麻烦, 需要替换图片；圆角需要特殊处理，并且边缘会模糊。

**6.postcss-write-svg**

使用border-image每次都要去调整图片，总是需要成本的。基于上述的原因，我们可以借助于PostCSS的插件postcss-write-svg来帮助我们。如果你的项目中已经有使用PostCSS，那么只需要在项目中安装这个插件。然后在你的代码中使用：

```js
@svg 1px-border {
    height: 2px;
    @rect {
      fill: var(--color, black);
      width: 100%;
      height: 50%;
    }
}
.example {
    border: 1px solid transparent;
    border-image: svg(1px-border param(--color #00b1ff)) 2 2 stretch;
 }
```

这样`PostCSS`会自动帮你把CSS编译出来：

```js
.example {
    border: 1px solid transparent;
    border-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' height='2px'%3E%3Crect fill='%2300b1ff' width='100%25' height='50%25'/%3E%3C/svg%3E")
          2 2 stretch;
  }
```

这个方案简单易用，是我所需要的。目前测试下来，基本能达到我所需要的需求，在最新的适配方案中，我也采用了这个插件来处理1px边框的问题。

总结
0.5px，相信浏览器肯定是会慢慢支持的，目前而言，如果能用的话，可以hack一下。
对于老项目，建议采用transform+伪类。
新项目可以设置viewport的scale值，这个方法兼容性好。
postcss-write-svg简单易用，仅适合直线，圆角建议用transform+伪类实现。

### JavaScript 的基本类型有哪些？引用类型有哪些？null 和 undefined 的区别？

**数据类型:** 

基本数据类型：Number、String、Boolean、undefined 、null

引用数据类型：Function、Object、Array 

**区别:**

undefined：表示`变量声明但未初始化`时的值 

null：表示`准备用来保存对象，还没有真正保存对象`的值。从逻辑角度看，null 值表示一个空对象指针 

>ECMA 标准要求 null 和 undefined 等值判断返回 true 
>
>null == undefined // true 
>
>null === undefined // false

### 如何判断 JavaScript 的数据类型？

**1、typeof**

`typeof `可以用来区分`除了 null 类型以外的原始数据类型`，对象类型的可以从普通对象里面识别出函数： 

```js
typeof 1 // "number" 
typeof "1" // "string" 
typeof undefined // "undefined"  
typeof Symbol() // "symbol" 
typeof function() {} // "function"
typeof null // "object"
typeof [1, 2, 3] // object
typeof {} // "object"

// ES6 引入了一种新的原始数据类型 Symbol ，表示独一无二的值，最大的用法是用来定义对象的唯一属性名。
```

>问题一：typeof 不能识别 null，如何识别 null？ 
>
>答案：如果想要判断是否为 null，可以直接使用===全等运算符来判断（或者使用下面 的 Object.prototype.toString 方法）
>
>```js
>let a = null 
>a === null // true 
>```
>
>问题二：typeof 作用于未定义的变量，会报错吗？ 
>
>答案：不会报错，返回"undefined"。 
>
>```js
>typeof randomVariable // 'undefined'
>```
>
>问题三：typeof Number(1)的返回值是什么？ 
>
>答案："number"。注意 Number 和 String 作为普通函数调用的时候，是把参数转化为 相 应的原始数据类型，也就是类似于做一个强制类型转换的操作，而不是默认当做构造函数 调用。注意和 Array 区分，Array(...)等价于 new Array(...) 
>
>```js
>typeof Number(1) // 'number' 
>typeof String("1") // 'string'
>Array(1, 2, 3) // 等价于 new Array(1, 2, 3) // [1, 2, 3]
>```
>
>问题四：typeof new Number(1)的返回值是什么？ 
>
>答案："object"。 
>
>```js
>typeof new Number(1) // 'object' 
>typeof new String(1) // 'object'
>```

**2、instanceof** 

`instanceof` `不能用于判断原始数据类型的数据`

```js
 3 instanceof Number // false 
'3' instanceof String // false 
true instanceof Boolean // false 
```

`instanceof` `可以用来判断对象的类型` 

```js
var date = new Date() 
date instanceof Date // true 
var number = new Number() 
number instanceof Number // true 
var string = new String() 
string instanceof String // true 
```

需要注意的是，instanceof 的结果并不一定是可靠的，因为在 ECMAScript7 规范中可以通过自定义 Symbol.hasInstance 方法来覆盖默认行为。 

```js
Object.prototype.toString 
Object.prototype.toString.call(3).slice(8, -1) // "Number" 
Object.prototype.toString.call(new Number(3)).slice(8, -1) // "Number" 
Object.prototype.toString.call('3').slice(8, -1) // "String" 
Object.prototype.toString.call(new String(3)).slice(8, -1) // "String" 
Object.prototype.toString.call(true).slice(8, -1) // "Boolean" 
Object.prototype.toString.call(new Boolean(true)).slice(8, -1) // "Boolean" 
Object.prototype.toString.call(undefined).slice(8, -1) // "Undefined" 
Object.prototype.toString.call(null).slice(8, -1) // "Null" 
Object.prototype.toString.call(Symbol()).slice(8, -1) // "Symbol" 
```

由上面的示例可知，该方法没有办法区分`数字类型和数字对象类型`，同理还有`字符串类型和字符串对象类型`、`布尔类型和布尔对象类型 `

另外，ECMAScript7 规范定义了符号 Symbol.toStringTag，你可以通过这个符号自定义 Object.prototype.toString 方法的行为： 

```js
'use strict' 
var number = new Number(3) 
number[Symbol.toStringTag] = 'Custom' Object.prototype.toString.call(number).slice(8, -1) // "Custom" 
function a () {} 
a[Symbol.toStringTag] = 'Custom' 
Object.prototype.toString.call(a).slice(8, -1) // "Custom" 
var array = [] 
array[Symbol.toStringTag] = 'Custom' 
Object.prototype.toString.call(array).slice(8, -1) // "Custom" 
```

因为 Object.prototype.toString 方法可以通过 Symbol.toStringTag 属性来覆盖默认行 为，所以使用这个方法来判断数据类型也不一定是可靠的 

```js
Array.isArray 
Array.isArray(value)可以用来判断 value 是否是数组： 
Array.isArray([]) // true 
Array.isArray({}) // false 
(function () {console.log(Array.isArray(arguments))}()) // false
```

### 简述创建函数的几种方式？

1、函数声明

```js
  function sum1(num1, num2) {
    return num1 + num2;
  }
```

2、函数表达式

```js
  var sum2 = function (num1, num2) {
    return num1 + num2;
  }
```

3、函数对象方式

```js
  var sum3 = new Function("num1", "num2", "return num1+num2");
```

### Javascript 创建对象的几种方式？

1、简单对象的创建使用`对象字面量`的方式{} 

创建一个对象（最简单，好理解，推荐使用） 

```js
  var Cat = {} // JSON 
  Cat.name = "kity" // 添加属性并赋值 
  Cat.age = 2
  Cat.sayHello = function () {
    alert("hello " + Cat.name + ",今年" + Cat["age"] + "岁了") // 可以使用 “.” 的方式访问属性， 也可以使用 HashMap 的方式访问 
  }
  Cat.sayHello() // 调用对象的（方法）函数
```

2、`用 function(函数)来模拟 class `

2.1） 创建一个对象，相当于 new 一个类的实例(无参构造函数) 

```js
  function Person() {}
  var personOne = new Person() // 定义一个 function，如果有 new 关键字去 "实例化" ,那么该 function 可以看作是一个类 
  personOne.name = "dylan"
  personOne.hobby = "coding"
  personOne.work = function () {
    alert(personOne.name + " is coding now...")
  }
  personOne.work()
```

2.2）可以使用有参构造函数来实现，这样定义更方便，扩展性更强（推荐使用）

```js
  function Pet(name, age, hobby) {
    this.name = name // this 作用域：当前对象
    this.age = age
    this.hobby = hobby
    this.eat = function () {
      alert("我叫" + this.name + ",我喜欢" + this.hobby + ",也是个吃货")
    }
  }
  var maidou = new Pet("麦兜", 5, "睡觉") // 实例化/创建对象
  maidou.eat() // 调用 eat 方法(函数)
```

3、使用`工厂方式`来创建（Object 关键字）

```js
  var wcDog = new Object()
  wcDog.name = "旺财"
  wcDog.age = 3
  wcDog.work = function () {
    alert("我是" + wcDog.name + ",汪汪汪......")
  }
  wcDog.work()
```

4、使用`原型对象的方式` prototype 关键字

```js
  function Dog() {
  }
  Dog.prototype.name = "旺财"
  Dog.prototype.eat = function () {
    alert(this.name + "是个吃货")
  }
  var wangcai = new Dog()
  wangcai.eat()
```

5、`混合模式`(原型和构造函数)

```js
  function Car(name, price) {
    this.name = name
    this.price = price
  }
  Car.prototype.sell = function () {
    alert("我是" + this.name + "，我现在卖" + this.price + "万元")
  }
  var camry = new Car("凯美瑞", 27)
  camry.sell()
```

6、`动态原型`的方式(可以看作是混合模式的一种特例)

```js
  function Car(name, price) {
    this.name = name
    this.price = price
    if (typeof Car.sell == "undefined") {
      Car.prototype.sell = function () {
        alert("我是" + this.name + "，我现在卖" + this.price + "万元")
      }
      Car.sell = true
    }
  }
  var camry = new Car("凯美瑞", 27)
  camry.sell()
```

以上几种，是 javascript 中最常用的创建对象的方式

### 请指出 JavaScript 宿主对象和原生对象的区别？

`原生对象`

“`独立于宿主环境的 ECMAScript 实现提供的对象`”

包含：Object、Function、Array、String、Boolean、Number、Date、RegExp、Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError、URIError

`内置对象`

开发者不必明确实例化内置对象，它已被内部实例化了

同样是“独立于宿主环境”。而 ECMA-262 只定义了两个内置对象，即 Global 和 Math

 `宿主对象`

BOM 和 DOM 都是宿主对象。因为其对于不同的“宿主”环境所展示的内容不同。其实说白了就是，ECMAScript 官方未定义的对象都属于宿主对象，因为其未定义的对象大多数是自己通过 ECMAScript 程序创建的对象

### JavaScript 内置的常用对象有哪些？并列举该对象常用的方法？

**1、对象及方法**

Arguments 函数参数集合

Arguments[] 函数参数的数组

Arguments 一个函数的参数和其他属性

Arguments.callee 当前正在运行的函数

Arguments.length 传递给函数的参数的个数

**2、 Number 数值对象**

Number.MAX_VALUE 最大数值

Number.MIN_VALUE 最小数值

Number.NaN 特殊的非数字值

Number.NEGATIVE_INFINITY 负无穷大，溢出时返回该值

Number.POSITIVE_INFINITY 正无穷大，溢出时返回该值

Number.toExponential( ) 用指数计数法格式化数字

Number.toFixed( ) 采用定点计数法格式化数字

Number.toLocaleString( ) 把数字转换成本地格式的字符串

Number.toPrecision( ) 格式化数字的有效位

Number.toString( ) 将—个数字转换成字符串

Number.valueOf( ) 返回原始数值

**3、String 字符串对象** 

Length 获取`字符串的长度`。如：var len = strObj.length

`toLowerCase()` `将字符串中的字母转成全小写`。如：strObj.toLowerCase()

`toUpperCase()` `将字符串中的字母转成全大写`。如：strObj.toUpperCase()

charAt(index) 返回指定下标位置的一个字符。如果没有找到，则返回空字符串

`substr()` 在原始字符串，返回一个子字符串

`substring()` 在原始字符串，返回一个子字符串

>区别：
>
>“abcdefgh”.substring(2，3) = “c”
>
>“abcdefgh”.substr(2，3) = “cde”

`split()` `将一个字符串转成数组`

charCodeAt() 返回字符串中的第 n 个字符的代码

concat() 连接字符串

fromCharCode() 从字符编码创建—个字符串

`indexOf()` `返回一个子字符串在原始字符串中的索引值`。`如果没有找到，则返回固定值 -1`

lastIndexOf() 从后向前检索一个字符串

localeCompare() 用本地特定的顺序来比较两个字符串

`match()` `找到一个或多个正则表达式匹配的子字符串`

`replace()` `替换一个与正则表达式匹配的子字符串`

`search()` `检索与正则表达式相匹配的子字符串`

slice() 抽取一个子串

toLocaleLowerCase() 把字符串转换成小写

toLocaleUpperCase() 将字符串转换成大写

toLowerCase() 将字符串转换成小写

toUpperCase() 将字符串转换成大写

>toLowerCase()和toUpperCase()是两个经典的方法，借鉴自java.lang.String中的同名方法。
>
>而toLocaleLowerCase()和toLocaleUpperCase()方法则是`针对特定地区`的方法。
>
>一般来说，在不知道自己的代码将在那种语言环境中运行的情况下，还是使用针对地区的方法更稳妥一些。

valueOf() 返回 String 对象的原始值

**4、Boolean 布尔对象**

Boolean.toString() 将布尔值转换成字符串

Boolean.valueOf() Boolean 对象的原始值的布尔值

**5、Array数组**  

length 属性 `动态获取数组长度`

join() 将一个数组转成字符串。`返回一个字符串`

reverse() 将数组中各元素`颠倒顺序`

`delete 运算符` `只能删除数组元素的值，而所占空间还在，总长度没变(arr.length)`

`shift()` `删除数组中第一个元素，返回删除的那个值，并将长度减 1`

`pop()` `删除数组中最后一个元素，返回删除的那个值，并将长度减 1`

`unshift() 往数组前面添加一个或多个数组元素，长度要改变`。arrObj.unshift(“a” ， “b，“c”)

`push() 往数组结尾添加一个或多个数组元素，长度要改变`。arrObj.push(“a” ，“b”， “c”) 

concat() 连接数组

slice() 返回数组的一部分

`splice()` `插入、删除或替换数组的元素`

toLocaleString() 把数组转换成局部字符串

`toString()` `将数组转换成一个字符串`

`forEach` `遍历所有元素`

```js
  var arr = [1, 2, 3]
  arr.forEach(function (item, index) {
    // 遍历数组的所有元素
    console.log(index, item)
  })
```

`every` `判断所有元素是否都符合条件`

```js
  var arr = [1, 2, 3]
  var arr1 = arr.every(function (item, index) {
    if (item < 4) {
      return true
    }
  })
  console.log(arr1) // true
```

`sort` `对数组元素进行排序`

```js
  var arr = [1, 5, 2, 7, 3, 4]
  var arr2 = arr.sort(function (a, b) {
    // 从小到大
    return a - b
    // 从大到小
    return b - a
  })
  console.log(arr2) // 1,2,3,4,5,7
```

`map` `对元素重新组装，生成新数组`

```js
  var arr = [1, 5, 2, 7, 3, 4]
  var arr2 = arr.map(function (item, index) {
    return '<b>' + item + '</br>'
  })
  console.log(arr2) //  ['<b>1</br>', '<b>5</br>', '<b>2</br>', '<b>7</br>', '<b>3</br>', '<b>4</br>']
```

`filter` `过滤符合条件的元素`

```js
  var arr = [1, 2, 3, 4]
  var arr2 = arr.filter(function (item, index) {
    if (item > 2) {
      return true
    }
  })
  console.log(arr2) // [3, 4]
```

**6、Function 函数构造器**

Function.arguments[] 传递给函数的参数

Function.apply() 将函数作为一个对象的方法调用

Function.call() 将函数作为对象的方法调用

>**call()** 和 **apply()** 是预定义的函数方法。 两个方法可用于调用函数，两个方法的第一个参数必须是对象本身。
>
>两者的区别在于第二个参数： apply传入的是一个参数数组，也就是将多个参数组合成为一个数组传入，而call则作为call的参数传入（从第二个参数开始）。

Function.caller 调用当前函数的函数

Function.length 已声明的参数的个数

Function.prototype 对象类的原型

Function.toString() 把函数转换成字符串

**7、Object 基础对象**

Object 含有所有 JavaScript 对象的特性的超类

Object.constructor 对象的构造函数

Object.hasOwnProperty( ) 检查属性是否被继承

Object.isPrototypeOf( ) 一个对象是否是另一个对象的原型

Object.propertyIsEnumerable( ) 是否可以通过 for/in 循环看到属性

Object.toLocaleString( ) 返回对象的本地字符串表示

Object.toString( ) 定义一个对象的字符串表示

Object.valueOf( ) 指定对象的原始值

**8、Date 日期时间**

创建 Date 对象的方法

（1）创建当前(现在)日期对象的实例，不带任何参数

```js
var today = new Date()
```

（2）创建指定时间戳的日期对象实例，参数是时间戳。

`时间戳：是指某一个时间距离 1970 年 1 月 1 日 0 时 0 分 0 秒，过去了多少毫秒值(1 秒 =1000 毫秒)`

```js
var timer = new Date(10000) // 时间是 1970 年 1 月 1 日 0 时 0 分 10 秒
```

（3）指定一个字符串的日期时间信息，参数是一个日期时间字符串

```js
var timer = new Date(“2015/5/25 10：00：00”)
```

（4）指定多个数值参数

```js
var timer = new Date(2015+100，4，25，10，20，0) //顺序为：年、月、日、时、分、秒，年、月、日是必须的
```

方法：

Date.getFullYear() 返回 Date 对象的年份字段

Date.getMonth() 返回 Date 对象的月份字段

Date.getDate() 返回一个月中的某一天

Date.getDay() 返回一周中的某一天

Date.getHours() 返回 Date 对象的小时字段

Date.getMinutes() 返回 Date 对象的分钟字段

Date.getSeconds() 返回 Date 对象的秒字段

Date.getMilliseconds() 返回 Date 对象的毫秒字段

Date.getTime() 返回 Date 对象的毫秒表示

**9、Math 数学对象**

Math 对象是一个`静态对象`

Math.PI 圆周率

Math.abs() 绝对值

Math.ceil() 向上取整(整数加 1，小数去掉)

Math.floor() 向下取整(直接去掉小数)

Math.round() 四舍五入

Math.pow(x，y) 求 x 的 y 次方

Math.sqrt() 求平方根

**10、RegExp 正则表达式对象**

RegExp.exec()   检索字符串中指定的值。返回找到的值，并确定其位置。

RegExp.test( ) 检索字符串中指定的值。返回 true 或 false。

RegExp.toString( ) 把正则表达式转换成字符串

RegExp.globa 判断是否设置了 "g" 修饰符

RegExp.ignoreCase 判断是否设置了 "i" 修饰符

RegExp.lastIndex 用于规定下次匹配的起始位置

RegExp.source 返回正则表达式的匹配模式

**11、Error 异常对象** 

Error.message 设置或返回一个错误信息(字符串)

Error.name 设置或返回一个错误名

Error.toString( ) 把 Error 对象转换成字符串

EvalError 在不正确使用 eval()时抛出

SyntaxError 抛出该错误用来通知语法错误

RangeError 在数字超出合法范围时抛出

ReferenceError 在读取不存在的变量时抛出

TypeError 当一个值的类型错误时，抛出该异常 URIError 由 URl 的编码和解码方法抛出 

### === 和 ==的区别？

===：三个等号称为等同符，既要判断值也要判断类型是否相等

==：两个等号称为等值符，等号只要值相等就可以

### JavaScript 中什么情况下会返回 undefined 值？

1、访问声明，但是没有初始化的变量

```js
var aaa
console.log(aaa) // undefined
```

2、访问不存在的属性

```js
var aaa = {}
console.log(aaa.c)
```

3、访问函数的参数没有被显式的传递值

```js
  (function (b) {
    console.log(b) // undefined
  })()
```

4、访问任何被设置为 undefined 值的变量

```js
var aaa = undefined
console.log(aaa) // undefined
```

5、没有定义 return 的函数隐式返回

```js
function aaa() {}
console.log(aaa()) // undefined
```

6、函数 return 没有显式的返回任何内容

```js
  function aaa() {
    return
  }
  console.log(aaa()) // undefined
```

### 如何区分数组和对象？

1、通过 ES6 中的 Array.isArray 来识别

```js
Array.isArray([]) // true
Array.isArray({}) // false
```

2、通过 instanceof 来识别

```js
[] instanceof Array // true
{} instanceof Array // SyntaxError语法错误
```

3、通过调用 constructor 来识别

```js
[].constructor // 返回 Array 
{}.constructor // SyntaxError语法错误
```

4、通过 Object.prototype.toString.call 方法来识别

```js
Object.prototype.toString.call([]) // '[object Array]'
Object.prototype.toString.call({}) // '[object Object]'
```

### 多维数组降维的几种方法?

1、数组字符串化

```js
  let arr = [
    [222, 333, 444],
    [55, 66, 77]
  ]
  arr += ''
  arr = arr.split(',')
  console.log(arr) // ['222', '333', '444', '55', '66', '77']
```

2、递归

```js
  function reduceDimension(arr) {
    let ret = []
    let toArr = function (arr) {
      arr.forEach(function (item) {
        item instanceof Array ? toArr(item) : ret.push(item)
      })
    }
    toArr(arr)
    return ret
  }
```

3、Array.prototype.flat()

```js
  var arr1 = [1, 2, [3, 4]]
  arr1.flat() // [1, 2, 3, 4]
  var arr2 = [1, 2, [3, 4, [5, 6]]]
  arr2.flat() // [1, 2, 3, 4, [5, 6]]
  var arr3 = [1, 2, [3, 4, [5, 6]]]
  arr3.flat(2) // [1, 2, 3, 4, 5, 6]
  // 使用 Infinity 作为深度，展开任意深度的嵌套数组
  arr3.flat(Infinity) // [1, 2, 3, 4, 5, 6]
```

4、使用 stack 无限反嵌套多层嵌套数组

```js
  var arr1 = [1, 2, 3, [1, 2, 3, 4, [2, 3, 4]]] 
  function flatten(input) {
    const stack = [...input]
    const res = []
    while (stack.length) {
      // 使用 pop 从 stack 中取出并移除值
      const next = stack.pop()
      if (Array.isArray(next)) {
        // 使用 push 送回内层数组中的元素，不会改动原始输入 original input
        stack.push(...next)
      } else {
        res.push(next)
      }
    }
    // 使用 reverse 恢复原数组的顺序
    return res.reverse()
  }
  flatten(arr1) // [1, 2, 3, 1, 2, 3, 4, 2, 3, 4]
```

5、使用 reduce、concat 和递归无限反嵌套多层嵌套的数组

```js
  var arr1 = [1, 2, 3, [1, 2, 3, 4, [2, 3, 4]]]

  function flattenDeep(arr1) {
    return arr1.reduce((acc, val) => Array.isArray(val) ? acc.concat(flattenDeep(val)) : acc.concat(val), [])
  }
  flattenDeep(arr1) // [1, 2, 3, 1, 2, 3, 4, 2, 3, 4]
```

### 怎么判断两个对象相等？

​		ES6 中有一个方法判断两个对象是否相等，这个方法判断是两个对象引用地址是否一致

```js
  let obj1 = {
    a: 1
  }
  let obj2 = {
    a: 1
  }
  console.log(Object.is(obj1, obj2)) // false
  let obj3 = obj1
  console.log(Object.is(obj1, obj3)) // true
  console.log(Object.is(obj2, obj3)) // false
```

当需求是比较两个对象内容是否一致时就没用了。

想要比较两个对象内容是否一致，思路是要遍历对象的所有键名和键值是否都一致： 

1、判断两个对象是否指向同一内存 

2、使用 Object.getOwnPropertyNames 获取对象所有键名数组 

3、判断两个对象的键名数组是否相等 

4、遍历键名，判断键值是否都相等

```js
  let obj1 = {
    a: 1,
    b: {
      c: 2
    }
  }
  let obj2 = {
    b: {
      c: 3
    },
    a: 1
  }

  function isObjectValueEqual(a, b) {
    // 判断两个对象是否指向同一内存，指向同一内存返回 true
    if (a === b) return true
    // 获取两个对象键值数组
    let aProps = Object.getOwnPropertyNames(a)
    let bProps = Object.getOwnPropertyNames(b)
    // 判断两个对象键值数组长度是否一致，不一致返回 false
    if (aProps.length !== bProps.length) return false
    // 遍历对象的键值
    for (let prop in a) {
      // 判断 a 的键值，在 b 中是否存在，不存在，返回 false
      if (b.hasOwnProperty(prop)) {
        // 判断 a 的键值是否为对象，是则递归，不是对象直接判断键值是否相等，不相等返回 false
        if (typeof a[prop] === 'object') {
          if (!isObjectValueEqual(a[prop], b[prop])) return false
        } else if (a[prop] !== b[prop]) {
          return false
        }
      } else {
        return false
      }
    }
    return true
  }
  console.log(isObjectValueEqual(obj1, obj2)) // false
```

### 列举三种强制类型转换和两种隐式类型转换？

**强制**

1、转化成字符串 toString()，String()

2、转换成数字 Number()，parseInt()，parseFloat()

3、转换成布尔类型 Boolean()

**隐式**

1、拼接字符串

2、- * / % ==

### JavaScript 中怎么获取当前日期的月份？

JavaScript 中获得当前日期是使用 new Date 这个内置对象的实例，其他一些进阶的操作也是基于这个内置对象的实例。 

1、获取完整的日期（默认格式）： 

```js
var date = new Date() // Sat Jul 06 2019 19:59:27 
```

2、GMT+0800 (中国标准时间) 获取当前年份：

```js
var year = date.getFullYear() // 2019
```

3、获取当前月份：

```js
var month = date.getMonth() + 1; // 7 
```

4、获取当前日： 

```js
var day = date.getDay(); // 6 
```

5、获取当前日期（年-月-日）： 

```js
month = (month > 9) ? month : ("0" + month); day = (day < 10) ? ("0" + day) : day; var today = year + "-" + month + "-" + day; // 2019-07-06 
```

另外的一些操作： 

```js
date.getYear() // 获取当前年份(2 位) 
date.getFullYear() // 获取完整的年份(4 位, 1970-????) 
date.getMonth() // 获取当前月份(0-11,0 代表 1 月) 
date.getDate() // 获取当前日(1-31) 
date.getDay() // 获取当前星期 X(0-6,0 代表星期天) 
date.getTime() // 获取当前时间(从 1970.1.1 开始的毫秒数) 
date.getHours() // 获取当前小时数(0-23) 
date.getMinutes() // 获取当前分钟数(0-59) 
date.getSeconds() // 获取当前秒数(0-59) 
date.getMilliseconds() // 获取当前毫秒数(0-999) 
date.toLocaleDateString() // 获取当前日期 
date.toLocaleTimeString() // 获取当前时间 
date.toLocaleString( ) // 获取日期与时间
```

### 什么是类数组（伪数组），如何将其转化为真实的数组？

**伪数组**

1、具有 length 属性

2、按索引方式存储数据

3、不具有数组的 push.pop 等方法伪数组（类数组）：无法直接调用数组方法或期望 length 属性有什么特殊的行为，不具有数组的 push.pop 等方法，但仍可以对真正数据遍历方法来遍历它们。典型的是函数 document.childnodes 之类的，它们返回的 nodeList 对象都属于伪数组

**伪数组转化为真实数组的方法**

1、使用 Array.from()--ES6

2、[].slice.call(eleArr) 或则 Array.prototype.slice.call(eleArr)

```js
  let eleArr = document.querySelectorAll('li')
  Array.from(eleArr).forEach(function (item) {
    alert(item)
  })

  let eleArr = document.querySelectorAll('li')
  let arr = []
  arr.slice.call(eleArr).forEach(function (item) {
    alert(item)
  })
```

### 如何遍历对象的属性？

1、遍历自身可枚举的属性 (可枚举，非继承属性) Object.keys() 方法

​		该方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中的属性名的排列顺序和使用 for..in 遍历该对象时返回的顺序一致（两者的区别是 for ..in 还会枚举其原型链上的属性 ）

```js
  /** Array 对象 **/
  var arr = ['a', 'b', 'c']
  console.log(Object.keys(arr)) // ['0','1','2']
  /** Object 对象 **/
  var obj = {
    foo: 'bar',
    bar: 42
  }
  console.log(Object.keys(obj)) // ["foo","bar"]
  /** 类数组对象 随机 key 排序 **/
  var anObj = {
    100: 'a',
    2: 'b',
    7: 'c'
  }
  console.log(Object.keys(anObj)) // ['2','7','100']
  /** getFoo 是一个不可枚举的属性 **/
  var my_obj = Object.create({}, {
    getFoo: {
      value: function () {
        return this.foo
      }
    }
  })
  my_obj.foo = 1
  console.log(Object.keys(my_obj)) // ['foo']
```

2、遍历自身的所有属性(可枚举，不可枚举，非继承属性) Object.getOwnPropertyNames() 方法

​		该方法返回一个由指定对象的所有自身属性组成的数组(包括不可枚举属性但不包括 Symbol 值作为名称的属性)

```js
  // 数组
  var arr = ["a", "b", "c"]
  console.log(Object.getOwnPropertyNames(arr).sort()) // ['0', '1', '2', 'length']
  // 类数组对象
  var obj = {
    0: "a",
    1: "b",
    2: "c"
  }
  console.log(Object.getOwnPropertyNames(obj).sort()) // ['0', '1', '2']
  // 使用 Array.forEach 输出属性名和属性值
  Object.getOwnPropertyNames(obj).forEach(function (val, idx, array) {
    console.log(val + " -> " + obj[val])
  })
  // 输出
  // 0 -> a
  // 1 -> b
  // 2 -> c
  // 不可枚举属性
  var my_obj = Object.create({}, {
    getFoo: {
      value: function () {
        return this.foo;
      },
      enumerable: false
    }
  })
  my_obj.foo = 1
  console.log(Object.getOwnPropertyNames(my_obj).sort()) // ["foo", "getFoo"]
```

3、遍历可枚举的自身属性和继承属性 （可枚举，可继承的属性） for in 遍历对象的属性

 		注：hasOwnProperty()方法判断对象是有某个属性(本身的属性，不是继承的属性)

```js
  var obj = {
    name: '张三',
    age: '24',
    getAge: function () {
      console.log(this.age)
    }
  }
  var arry = {}
  for (var i in obj) {
    if (obj.hasOwnProperty(i) && obj[i].typeOf != 'function') {
      arry[i] = obj[i]
    }
  }
  console.log(arry) // {name: '张三', age: '24', getAge: ƒ}
```

4、遍历所有的自身属性和继承属性

```js
  (function () {
    var getAllPropertyNames = function (obj) {
      var props = []
      do {
        props = props.concat(Object.getOwnPropertyNames(obj))
      } while (obj = Object.getPrototypeOf(obj))
      return props;
    }
    var propertys = getAllPropertyNames(window)
    alert(propertys.length) // 1068
    alert(propertys.join("\n")) //Object 等
  })()
```

### 如何使用原生 JavaScript 给一个按钮绑定两个 onclick 事件？

```js
<body>
  <button id="btn"></button>
  <script>
    //事件监听 绑定多个事件
    let btn = document.querySelector('#btn')
    btn.addEventListener('click', fn1)
    btn.addEventListener('click', fn2)

    function fn1() {
      alert('我是方法1')
    }

    function fn2() {
      alert('我是方法2')
    }
  </script>
</body>
```

### JavaScript 中的作用域、预解析与变量声明提升？

**作用域**

作用域就是变量的有效范围。 在一定的空间里可以对数据进行读写操作，这个空间就是数据的作用域。 

1、全局作用域： 最外层函数定义的变量拥有全局作用域，即对任何内部函数来说，都是可以访问的。

2、局部作用域： 局部作用域一般只在固定的代码片段内可访问到，而对于函数外部是无法访问的，最常见的例如函数内部。在 ES6 之前，只有函数可以划分变量的作用域，所以 在函数的外面无法访问函数内的变量。

3、块级作用域：凡是代码块就可以划分变量的作用域，这种作用域的规则就叫块级作用域。

>块级作用域、函数作用域和词法作用域之间的区别： 
>
>1. 块级作用域和函数作用域描述的是，什么东西可以划分变量的作用域 
>
>2. 词法作用域描述的是，变量的查找规则之间的关系
>
>3. 块级作用域 包含 函数作用域
>
>4. 词法作用域 与 块级作用域、函数作用域之间没有任何交集， 他们从两个角度描述了作用域的规则。

ES6 之前 JavaScript 采用的是函数作用域+词法作用域，ES6 js 采用的是块级作用域+词法作用域。

**预解析**

JavaScript 代码的执行是由浏览器中的 JavaScript 解析器来执行的。JavaScript 解析器 执行 JavaScript 代码的时候，分为两个过程：`预解析过程`和`代码执行过程`。

预解析过程： 

1.把变量的声明提升到当前作用域的最前面，只会提升声明，不会提升赋值 

2.把函数的声明提升到当前作用域的最前面，只会提升声明，不会提升调用 

3.先提升 function，在提升 var

JavaScript 的执行过程：

```js
    // 案例 1
    var a = 25
    function abc() {
      alert(a) // undefined
      var a = 10
    }
    abc()
    // 案例 2
    console.log(a) // 25
    function a() {
      console.log('aaaaa') // 不会执行, 没人调用 a()
    }
    var a = 1
    console.log(a) // 1
```

**变量提升**

变量提升：定义变量的时候，变量的声明会被提升到作用域的最上面，变量的赋值不会提升。

函数提升：JavaScript 解析器首先会把当前作用域的函数声明提前到整个作用域的最前面。

```js
    // 1、-----------------------------------
    var num = 10
    fun()
    function fun() {
      console.log(num) // undefined
      var num = 20
    }
    //2、-----------------------------------
    var a = 18
    f1() // 后者覆盖前者 f1 函数
    function f1() {
      var b = 9
      console.log(a)
      console.log(b)
      var a = '123'
    }
    // 3、-----------------------------------
    f1() // 再次调用下面的 f1 执行
    console.log(c) // 9
    console.log(b) // 9
    console.log(a) // 18
    function f1() {
      var a = b = c = 9 // 这里相当于 var a = 9; b = 9; c = 9, 所以后 2 个隐藏转换为全局变量了
      console.log(a) // 9
      console.log(b) // 9
      console.log(c) // 9
    }
```

变量声明提升： 使用 var 关键字定义的变量，被称为变量声明；函数声明提升的特点是，在函数声明的前面，可以调用这个函数。

### 变量提升与函数提升的区别？

**变量提升**

简单说就是在 JavaScript 代码执行前引擎会先进行预编译，预编译期间会将`变量声明与函数声明`提升至其`对应作用域的最顶端`，`函数内声明的变量`只会提升至`该函数作用域最顶层`，`当函数内部定义的一个变量与外部相同时`，那么`函数体内的这个变量就会被上升到最顶端`。

```js
    console.log(a) // undefined
    var a = 3 // 预编译后的代码结构可以看做如下运行顺序
    var a // 将变量 a 的声明提升至最顶端，赋值逻辑不提升。
    console.log(a) // undefined
    a = 3 // 代码执行到原位置即执行原赋值逻辑
```

**函数提升** 

函数提升只会提升函数声明式写法，函数表达式的写法不存在函数提升

函数提升的优先级大于变量提升的优先级，即函数提升在变量提升之上

### 什么是作用域链？

作用域链：当代码在一个环境中执行时，会创建变量对象的一个作用域链，由子级作用域返回父级作用域中寻找变量，就叫做作用域链。

作用域链中的下一个变量对象来自包含环境，也叫外部环境。而再下一个变量对象则来自下一个包含环境，一直延续到全局执行环境。全局执行环境的变量对象始终都是作用域链中的最后一个对象。

作用域链前端始终都是当前执行的代码所在环境的变量对象，如果环境是函数，则将 其活动对象作为变量对象。

### 如何延长作用域链？

作用域链是可以延长的。

延长作用域链： 执行环境的类型只有两种，全局和局部（函数）。但是有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移除。

具体来说就是执行这两个语句时，作用域链都会得到加强

1. try - catch 语句的 catch 块：会创建一个新的变量对象，包含的是被抛出的错误对 象的声明。
2. with 语句：with 语句会将指定的对象添加到作用域链中。

### 判断一个值是什么类型有哪些方法？

1、typeof 运算符

2、instanceof 运算符

​		instanceof 严格来说是 Java 中的一个双目运算符，用来测试一个对象是否为一个类的实例

```js
    // 判断 foo 是否是 Foo 类的实例
    function Foo() {}
    var foo = new Foo()
    console.log(foo instanceof Foo) //true 
```

3、Object.prototype.toString 方法

在 JavaScript 里使用 typeof 来判断数据类型，只能区分基本类型，即 Number，String，undefined，Boolean，Object，Function，symbol (ES6 新增)七种。对于null、数组、对象来说，其关系错综复杂，使用 typeof 都会统一返回 “object” 。

要想区别对象、数组、函数单纯使用 typeof 是不行的，JavaScript 中，通过 Object.prototype.toString 方法，判断某个对象值属于哪种内置类型。

```js
    var arr = [1, 2] // 直接对一个数组调用 toString()
    arr.toString() // "1,2"
    // 通过 call 指定 arr 数组为 Object.prototype 对象中的 toString 方法的上下文
    Object.prototype.toString.call(arr) // "[object Array]"
```

### 如何实现数组的随机排序？

方法一：

```js
    var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

    function randSort1(arr) {
      for (var i = 0, len = arr.length; i < len; i++) {
        var rand = parseInt(Math.random() * len)
        var temp = arr[rand]
        arr[rand] = arr[i]
        arr[i] = temp
      }
      return arr
    }
    console.log(randSort1(arr))
```

方法二：

```js
    var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

    function randSort2(arr) {
      var mixedArray = []
      while (arr.length > 0) {
        var randomIndex = parseInt(Math.random() * arr.length)
        mixedArray.push(arr[randomIndex])
        arr.splice(randomIndex, 1)
      }
      return mixedArray
    }
    console.log(randSort2(arr))
```

方法三：

```js
    var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    arr.sort(function () {
      return Math.random() - 0.5
    })
    console.log(arr)
```

### src 和 href 的区别是？

src（source）指向`外部资源的位置`，指向的内容将会嵌入到文档中当前标签所在位置。在请求 src 资源时会将其指向的资源下载并应用到文档中，如 JavaScript 脚本，img 图片和 iframe 等元素。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，类似于将所指向资源嵌入当前标签内。

href（hypertext reference/超文本引用）指向`网络资源所在位置`，建立和当前元素（锚点）或当前文档（ 链 接 ）之间的链接 ，如果我们在文档中添加<link href="common.css" rel="stylesheet"/>那么浏览器会识别该文档为 CSS 文件，就会并行下载资源并且不会停止对当前文档的处理。

## ajax

### http的请求方式有哪些？

HTTP 1.0 标准中，定义了3种请求⽅法：GET、POST、HEAD

HTTP 1.1 标准中，新增了请求⽅法：PUT、PATCH、DELETE、OPTIONS、TRACE、CONNECT

###各个HTTP方法的具体作用是什么？

|  方法   | 功能                                                         |
| :-----: | ------------------------------------------------------------ |
|   GET   | 通常⽤于请求服务器发送某些资源                               |
|  POST   | 发送数据给服务器                                             |
|  HEAD   | 请求资源的头部信息, 并且这些头部与 HTTP GET ⽅法请求时返回的⼀致。<br />该请求⽅法的⼀个使⽤场景是在下载⼀个⼤⽂件前先获取其⼤⼩再决定是否要下载, 以此可以节约带宽资源 |
|   PUT   | ⽤于全量修改⽬标资源 (看接口, 也可以用于添加)                |
| DELETE  | ⽤于删除指定的资源                                           |
| OPTIONS | ⽤于获取⽬的资源所⽀持的通信选项 (跨域请求前, 预检请求, 判断目标是否安全) |
|  TRACE  | 该方法会  让服务器  原样返回任意客户端请求的信息内容, 用于诊断和判断 |
| CONNECT | HTTP/1.1协议中预留给能够将连接改为管道⽅式的代理服务器<br />(把服务器作为跳板，让服务器代替用户去访问其它网页, 之后把数据原原本本的返回给用户) |
|  PATCH  | ⽤于对资源进⾏部分修改                                       |

GET POST PUT PATCH DELETE

GET/DELETE  参数是在地址栏中传递的

PUT/PATCH/POST 参数是在请求体传递的

### post和get 请求有哪些区别？

默认的http请求的内容, 在网络中传输, 明文的形式传递的  (https 对内容加密)

|                  | GET方法                                                      | POST方法                                           |
| ---------------- | ------------------------------------------------------------ | -------------------------------------------------- |
| **数据传输⽅式** | 通过URL传输数据 (地址栏拼接参数)                             | 通过请求体传输                                     |
| **数据安全**     | 数据暴露在URL中，可通过浏览历史记录、缓存等很容易查到数据信息 | 数据因为在请求主体内，<br />所以有⼀定的安全性保证 |
| **数据类型**     | 只允许 ASCII 字符                                            | ⽆限制                                             |
| **GET⽆害**      | 刷新、后退等浏览器操作是⽆害的                               | 可能会引起重复提交表单                             |
| **功能特性**     | 安全且幂等（这⾥的安全是指只读特性，就是使⽤这个⽅法不会引起服务器状态变化。<br />**幂等的概念是指同⼀个请求⽅法执⾏多次和仅执⾏⼀次的效果完全相同）** | ⾮安全(会引起服务器端的变化)、**⾮幂等**           |

### HTTP请求报文是什么样的？

HTTP 请求报⽂的组成：请求⾏、请求头、(空⾏)、请求体。

实际请求报文实例:


**请求行**

包含了请求⽅法、URL、HTTP 协议版本，它们之间⽤空格进行分隔。例如：

```bash
GET http://www.abc.com/articles HTTP/1.1
```

**请求头**

请求头由键值对组成，每⾏⼀对，键值之间⽤英⽂冒号`:`进行分隔。例如：

```
Content-Type: application/json
Host: www.abc.com
```

**请求体**

请求体中放置 POST、PUT、PATCH 等请求方法所需要携带的数据。

### HTTP响应报文是什么样的？

HTTP 响应报⽂的组成: 响应⾏、响应头、空⾏、响应体。

**响应行**

响应行由协议版本、状态码、状态码的原因短语3个内容组成，中间以空格分隔。例如：

```bash
HTTP/1.1 200 OK
```



**响应头**

响应头由键值对组成，每⾏⼀对，键值之间⽤英⽂冒号`:`进行分隔。例如：

```
Content-Length: 1024
Content-Type: application/json
```



**响应体**

服务器发送过来的数据。

小结:

### http状态码分别代表什么意思？

1xx	表示HTTP请求`已经接受`，继续处理请求
2xx	表示HTTP请求`已经处理完成`(200)
3xx	表示把请求访问的`URL重定向`到其他目录(304资源没有发生变化，会重定向到本地资源)
4xx	表示`客户端出现错误`(403禁止访问、404资源不存在)
5xx	表示`服务端出现错误`

**成功（2XX）**

| 状态码 | 原因短语        | 说明                                                         |
| ------ | --------------- | ------------------------------------------------------------ |
| 200    | OK              | 表示从客户端发来的请求在服务器端被正确处理                   |
| 201    | Created         | 请求已经被实现，⽽且有⼀个新的资源已经依据请求的需要⽽建⽴<br />通常是在POST请求，或是某些PUT请求之后创建了内容, 进行的返回的响应 |
| 202    | Accepted        | 请求服务器已接受，但是尚未处理，不保证完成请求<br />适合异步任务或者说需要处理时间比较长的请求，避免HTTP连接一直占用 |
| 204    | No content      | 表示请求成功，但响应报⽂不含实体的主体部分                   |
| 206    | Partial Content | 进⾏的是范围请求, 表示服务器已经成功处理了部分 GET 请求<br />响应头中会包含获取的内容范围 (常用于分段下载) |

**重定向（3XX）**

| 状态码  | 原因短语           | 说明                                                         |
| ------- | ------------------ | ------------------------------------------------------------ |
| 301     | Moved Permanently  | 永久性重定向，表示资源已被分配了新的 URL<br />比如，我们访问 **http**://www.baidu.com 会跳转到 **https**://www.baidu.com |
| 302     | Found              | 临时性重定向，表示资源临时被分配了新的 URL, 支持搜索引擎优化<br />首页, 个人中心, 遇到了需要登录才能操作的内容, 重定向 到 登录页 |
| 303     | See Other          | 对于POST请求，它表示请求已经被处理，客户端可以接着使用GET方法去请求Location里的URI。 |
| **304** | **Not Modified**   | **自从上次请求后，请求的网页内容未修改过。<br />服务器返回此响应时，不会返回网页内容。(协商缓存)** |
| 307     | Temporary Redirect | 对于POST请求，表示请求还没有被处理，客户端应该向Location里的URI重新发起POST请求。<br />不对请求做额外处理, 正常发送请求, 请求location中的url地址 |

因为post请求, 是非幂等的,  从302中, 细化出了 303 和 307

简而言之: 

- 301  302  307  都是重定向
- 304 协商缓存

**客户端错误（4XX）**

| 状态码  | 原因短语        | 说明                                        |
| ------- | --------------- | ------------------------------------------- |
| **400** | **Bad Request** | **请求报⽂存在语法错误(（传参格式不正确）** |
| 401     | UnAuthorized    | 权限认证未通过(没有权限)                    |
| 403     | Forbidden       | 表示对请求资源的访问被服务器拒绝            |
| 404     | Not Found       | 表示在服务器上没有找到请求的资源            |
| 408     | Request Timeout | 客户端请求超时                              |
| 409     | Confict         | 请求的资源可能引起冲突                      |

**服务端错误（5XX）**

| 状态码 | 原因短语                   | 说明                                                         |
| ------ | -------------------------- | ------------------------------------------------------------ |
| 500    | Internal Sever Error       | 表示服务器端在执⾏请求时发⽣了错误                           |
| 501    | Not Implemented            | 请求超出服务器能⼒范围，例如服务器不⽀持当前请求所需要的某个功能，<br />或者请求是服务器不⽀持的某个⽅法 |
| 503    | Service Unavailable        | 表明服务器暂时处于超负载或正在停机维护，⽆法处理请求         |
| 505    | Http Version Not Supported | 服务器不⽀持，或者拒绝⽀持在请求中使⽤的 HTTP 版本           |

问到状态码: 304   400  401??

当前端看到控制台报出 400 时, 请问一定是后台的问题么? 如何排查错误? (前端先检查传参格式是否有误)

###  HTTP1.x 的 keep-alive 是什么作用？

作用：使客户端到服务器端的连接**持续有效**(长连接)，当出现对服务器的后继请求时，

Keep-Alive功能避免了建立或者重新建立连接。

早期 HTTP/1.0 在每次请求的时候，都要创建⼀个新的连接，⽽创建连接的过程需要消耗资源和时间，

为了减少资源消耗、缩短响应时间，就需要复⽤已有连接。

在后来的 HTTP/1.0 以及 HTTP/1.1 中引⼊了复⽤连接的机制，也就是在请求头中加⼊Connection: keep-alive，

以此告诉对⽅这个请求响应完成后不要关闭连接，下⼀次还⽤这个请求的连接进行后续交流。

**协议规定，如果想要保持连接，则需要在请求头中加上 Connection: keep-alive。** 

**keep-alive 的优点** (复用连接)

- 较少的 CPU 和内存的占⽤（因为要打开的连接数变少了, 复用了连接） 
- 减少了后续请求的延迟（⽆需再进⾏握⼿） 
- ...

缺点: 因为在处理的暂停期间，本来可以释放的资源仍旧被占用。请求已经都结束了, 但是还一直连接着也不合适

解决：Keep-Alive: timeout=5, max=100

- timeout：过期时间5秒（对应httpd.conf里的参数是：KeepAliveTimeout），

- max是最多一百次请求，强制断掉连接。

  就是在timeout时间内又有新的连接过来，同时max会自动减1，直到为0，强制断掉。

### 为什么需要HTTPS？

HTTP协议是网络通信的基石, 基于HTTP协议, 完成了很多的网页应用功能, 但是HTTP协议是明文传输数据的! 太不安全了!

HTTPS 是安全版的 HTTP。

HTTP 协议在传输数据时采用的是明⽂方式传递，因此，⼀些敏感信息的传输就变得很不安全。

而 HTTPS 就是为了解决 HTTP 的不安全⽽产⽣的。

### HTTPS是如何保证安全的？

HTTPS 在传输数据的过程中会对数据进行加密处理，保证安全性。

那HTTPS采用的什么样的加密方式呢？我们来了解下一些加密的基本概念。

目前常见的加密算法可以分成三类，`对称加密算法`，`非对称加密算法` 和 `Hash算法`。

1. 对称加密算法: 相同密钥加密解密,  可逆的! 可以用于加密解密传输数据

   想使用对称加密算法, 一定要保证密钥不被泄漏  (且进行密钥的传输约定时, 一定要保证安全)

2. 非对称加密算法: 有两把钥匙, 公钥, 私钥,  可逆的, 可以用于 https 的初步交换密钥

3. Hash算法: 不可逆的,  根据一段内容, 生成一段唯一标识, 一般用于验证数据是否被修改!   (md5)

**什么是对称加密？**

对称加密的特点是文件加密和解密使用相同的密钥，即加密密钥也可以用作解密密钥，

这种方法在密码学中叫做对称加密算法，对称加密算法使用起来简单快捷，密钥较短，且破译困难

**通信的双⽅都使⽤同⼀个秘钥进⾏加密, 解密。**⽐如，两个人事先约定的暗号，就属于对称加密。 

对称加密的特点是：

- 优点:

  计算量小、加密速度快、加密效率高。

- 缺点: 

  **在数据传送前，发送方和接收方必须商定好秘钥，然后双方保存好秘钥。**

  **如果一方的秘钥被泄露，那么加密信息也就不安全了**

  最不安全的地方, 就在于第一开始, 互相约定密钥的时候!!! 传递密钥!

使用场景：本地数据加密、https通信、网络传输等

常见算法：AES、DES、3DES、DESX、Blowfish、IDEA、RC4、RC5、RC6  (全球公开, 通过了层层筛选, 层层检验)  没有被破解

全球有专门做算法设计的加密算法设计师, 但经过公开检验的算法才是安全的 (很多公开的算法, 虽然可以用撞库的方式破解, 但是尝试破解的成本会非常高 (甚至几百年))

**什么是⾮对称加密？**

而加密和解密其实可以使用不同的规则，只要这两种规则之间存在某种对应关系即可，

这样就避免了直接传递之前的相同的密钥。这种新的加密模式被称为"非对称加密算法"。

通信的双方使用不同的秘钥进行加密解密，即秘钥对（私钥 + 公钥）。

特征: 私钥可以解密公钥加密的内容,  公钥可以解密私钥加密的内容

非对称加密的特点是：

- 优点：非对称加密与对称加密相比其安全性更好

- **缺点：加密和解密花费时间长、速度慢，只适合对少量数据进行加密。**

使用场景：https会话前期、CA数字证书、信息加密、登录认证等

常见算法：RSA、ECC（移动设备用）、Diffie-Hellman、El Gamal、DSA（数字签名用）

**HTTPS 加密解决⽅案** 

结合了两种加密⽅式：

- 将 `对称加密的密钥(一串约定的字符串)` ⽤非对称加密的公钥, 进⾏加密并发送出去，接收⽅使⽤私钥解密得到 `对称加密密钥`

- 双⽅沟通时使⽤ `对称加密密钥` 进⾏

**可以看到，只有在发送秘钥阶段才使用非对称加密，而后续的通信都使用对称加密，这样解决了性能问题。**

HTTPS 目前所使用的 TLS或SSL协议,  就是目前采用的加密通道的规范协议 

它利用对称加密、(公私钥)非对称加密, 以及其密钥交换算法，可完成可信任的信息传输

1. 利用 非对称加密 加密传输 对称加密所约定的密钥  (保证了密钥传输的安全)
2. 后续, 利用对称加密, 有效便捷的进行数据传输!!

**数字证书**

为了安全性, 一般还需要签发数字证书! 

客户端 和 服务器端要初步互通消息时,  客户端发送请求可以拿到公开的公钥信息

进而进行非对称加密, 使用公钥, 加密`对称加密密钥`, 传递给服务器, 后续通信都使用对称加密! 

**问题是: 初步互通消息时, 如果请求拿到的公钥信息, 就是假的, 或者不安全的! 那么后续的所有操作, 都将是不安全的!**

如何保证公钥的安全性呢??  说白了, 需要证明公钥是安全可靠的!!! 要证明网站是安全可靠的!!!



所以, 就需要有数字证书(CA证书),  一般是CA机构(互联网的机构,  登记网站和公钥的)颁发的, 证明这个公钥是安全可靠的!

**CA证书中心会对你网站的公钥, 网站的域名地址,  证书到期时间, 等一些相关信息一起加密签发数字证书, 保证你网站的安全性**




当公司申请了 CA 证书后, 就应该在响应时, 将数字证书一起发送给客户端

而客户端, 接收到消息后, 就可以查看证书 , 权威CA机构都可以

1. 如果正在访问的网站 和 证书记载的网址 不一致, 说明不安全,  可能被冒用, 浏览器就会发出警告!!! 

2. 如果签发证书的机构, 不权威, 发出警告 


3. 如果证书过期了, 浏览器也会发出警告

   因为一旦证书过期了, CA机构, 不会继续实时检测网站的安全有效性!

**数字签名**

但这还是有问题：如果证书被篡改了怎么办?

这时就需要用⼀个技术：**数字签名**。 (根据证书内容, 生成的一个唯一标识) 

数字签名就是先⽤ **CA ⾃带的 Hash 算法来计算出证书内容的⼀个摘要**，然后使⽤ CA 私钥进行加密，组成数字签名。

当别⼈把他的证书发过来时，**接收方⽤同样的算法再次⽣成摘要**，⽤ CA 公钥解密后得到CA生成的摘要，两者进行对⽐后,

就能确定中间是否被⼈篡改。这样就能最⼤程度的保证通信的安全了。

[博客参考](https://blog.csdn.net/u014044812/article/details/80723009)

---

简要小结:

1. 为什么需要 HTTPS ? 因为HTTP是明文传输数据的, 不安全, 而 HTTPS 是会对内容加密的

2. HTTPS 的加密策略是什么 ?

   先用 `非对称加密`, 传递对称加密的密钥   (保证了密钥传输的安全)

   后续 使用`对称加密`, 进行交流  (保证了传输数据安全)

3. 问题: 就算是第一次交流用非对称加密,  公钥也是要在网络中传输的!

   如何证明公钥是可靠的? 如何证明网站是可靠的 ?    (CA机构认证, 网站需要申请  **`数字证书`**  )

   请求时, 网站就会将数字证书给到浏览器, 浏览器默认就会检测证书的可靠性!

   (1) 是否是权威机构发布的!

   (2) 看证书中记录的地址 和 当前访问的网站的地址, 是否一致, 只有一致, 才可靠!

   (3) 看证书是否过期

   ...

4. 如何保证证书不被篡改 => **`数字签名`**,  可以根据证书的所有的内容, 生成一个唯一标识!!! (`Hash加密算法`)

   一旦内容如果被修改了, 再次生成唯一标识时,  和之前生成的唯一标识就不一样!  检测是否被修改!

### HTTP/2 和 HTTP1.x 比，有什么优势和特点？(了解)

**HTTP/2 的升级, 对于用户来说, 是跨时代的!  基于HTTP/2, 用户访问网页的速度会非常快!!! (充分利用带宽)**

HTTP/2: 淘宝, 天猫, 京东等, 已做升级 ....

1. HTTP/2 采⽤`⼆进制格式`来传输数据，⽽⾮ HTTP 1.x 的⽂本格式，⼆进制协议`解析起来更⾼效`
2. HTTP/2 采用一些`头部压缩技术`，减少在请求和响应头中重复携带的数据，`降低网络负担`
3. HTTP/2 采⽤`服务器推送`方式，主动向客户端推送资源，提高页面加载效率
4. **HTTP/2 采⽤`多路复用机制`，减少需要创建的连接数量，降低资源占用和性能消耗**

下面是一些与之关联的技术知识。

**⼆进制格式分帧**

帧：HTTP/2 数据通信的最⼩单位消息，是指 HTTP/2 中逻辑上的 HTTP 消息（例如请求、响应等）。消息由⼀个或多个帧组成 

流：存在于连接中的⼀个虚拟通道，它可以承载双向消息，且每个流都有唯⼀的整数ID

**头部压缩**

在 HTTP1.x 中，请求和响应中会重复携带一些不常改变、冗⻓的头数据，给⽹络带来额外负担。

在 HTTP/2 中，客户端和服务端使⽤ **“⾸部表”** 来跟踪和存储之前发送过的键值对，

相同的数据不再随着每次请求和响应发送。⾸部表在连接存续期间始终存在，由客户端和服务器共同渐进更新。

每个新的⾸部键值对，要么被追加到当前表的末尾，要么替换表中已存在的键值对。

> 可以简单的理解为：只发送差异数据，⽽不是全部发送，从⽽减少头部的信息量

下图为首部表的更新示意图：

**服务器推送**

服务端可以在发送⻚⾯ HTML 内容时，再主动推送一些其它资源，⽽不⽤等到浏览器解析到相应的位置时发起请求后再作响应。

例如，服务端可以主动把 JS 和 CSS ⽂件推送给客户端，⽽不需要客户端解析 HTML 时再发送这些请求。 

不过，服务端的主动推送行为，客户端有权利选择是否要接收。

如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送 RST_STREAM 帧来拒收。

**多路复用**

在 HTTP 1.x 中如果想并发多个请求的话，必须使⽤多个 TCP 链接，但浏览器为了控制资源，

会对单个域名有 6-8 个 TCP 链接的数量限制。而在 HTTP/2 中： 

- 同域名下的所有通信，都在单个连接上完成 
- 单个连接可以承载任意数量的双向数据流 
- 数据流以消息的形式发送，⽽消息⼜由⼀个或多个帧组成（多个帧可以乱序发送，因为可以根据帧⾸部的流标识来重新组装）


[参考文章：HTTP/2特性及其在实际应用中的表现](https://zhuanlan.zhihu.com/p/30166894)

**小结:** 

**HTTP1.X 同一时间, 只能并发建立 6-8 个 TCP 连接, 一个连接同时只能一个请求  (虽然可以 keep-alive复用, 但也得一个个来)**

**(建立连接的成本比较高, 不让一次性建立太多连接)**

**而新版本 HTTP/2 建立一次连接, 就可以并发很多个请求!** 

所以 HTTP/2 的升级, 大大提升了页面加载的效率!

### http缓存控制

**基本认知**

**Web 服务缓存** 大致可以分为：数据库缓存、服务器端缓存（代理服务器缓存、CDN 服务器缓存）、浏览器缓存。

**浏览器缓存** 也包含很多内容： HTTP 缓存、indexDB、cookie、localstorage 等等。**`这里我们只讨论 HTTP 缓存相关内容`。**

**HTTP缓存**:  (优化页面加载的效率, 如果没有缓存策略, 每次重新加载页面, 会非常慢!)

- **强缓存**
- **协商缓存**

在具体了解 HTTP 缓存之前先来明确几个术语：

- 缓存命中率：从缓存中得到数据的请求数  与    所有请求数的比率。理想状态是越高越好。

  (看所有的请求中, 多少从缓存中读的)

- 过期内容：超过设置的有效时间，被标记为“陈旧”的内容。

- 验证：验证缓存中的过期内容是否仍然有效，验证通过的话刷新过期时间。

- 失效：失效就是把内容从缓存中移除。

**浏览器缓存主要是 HTTP 协议定义的缓存机制。**

**浏览器缓存, HTTP缓存分类**

浏览器缓存分为`强缓存 `和 `协商缓存`，浏览器加载一个页面的简单流程如下：

1. 浏览器先根据这个资源的  **http头信息**  来 **判断是否命中强缓存**。

   如果命中则直接加载在缓存中的资源，并不会将请求发送到服务器。（强缓存）

2. 如果未命中强缓存，则浏览器会将资源加载请求发送到服务器。

   服务器来判断浏览器本地缓存是否失效。

   若可以使用，则服务器并不会返回资源信息，浏览器继续从缓存加载资源。（协商缓存）

3. 如果未命中协商缓存，则服务器会将完整的资源返回给浏览器，浏览器加载新资源，并更新缓存。（新的请求）

**强缓存  (验证缓存是否过期)**

**(进行判断缓存是否有效,  就是判断资源是否过期, 如果未过期, 直接用缓存)**

命中强缓存时，浏览器并不会将请求发送给服务器。

在Chrome的开发者工具中看到http的返回码是200，但是在Size列会显示为(from cache)。

![940884-20180423141536107-329179455](D:/%E5%B0%A4%E7%90%A6%E7%AB%AF/web71/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A7%86%E9%A2%91%E8%AF%A6%E8%A7%A3/day4/02-%E7%AC%94%E8%AE%B0/images/940884-20180423141536107-329179455.png)



强缓存是利用http的返回的响应头中的Expires或者Cache-Control (优先级更高) 两个字段来控制的，用来表示资源的缓存时间。

Expires: 指定一个具体时间(2020年12月12日 17:00), 到了这个时间了, 缓存过期了, 在时间内, 都是有效的, 可以直接读

Cache-Control : 指定一个过期时间 (3600s), 这个资源你加载到后, 可以用 3600s

**Expires**

缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，Expires=max-age + 请求时间，需要和Last-modified结合使用。但在上面我们提到过，cache-control的优先级更高。 

Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。

该字段会返回一个时间，比如Expires:  Wed, 23 Nov 2050 16:00:01 GMT 。这个时间代表着这个资源的失效时间，也就是说在xx年xx月xx日时间之前都是有效的，即命中缓存。

这种方式有一个明显的缺点，由于失效时间是一个`绝对时间`，所以当 **服务器与客户端 时间偏差很大**  以后，就会导致缓存混乱。于是发展出了Cache-Control。

**Cache-Control**

Cache-Control是一个`相对时间`，例如Cache-Control:max-age 3600，代表着资源的有效期是3600秒。

由于是相对时间，并且都是与客户端时间比较，所以服务器与客户端时间偏差也不会导致问题。

Cache-Control与Expires可以在服务端配置同时启用或者启用任意一个，同时启用的时候Cache-Control优先级高。

Cache-Control 可以由多个字段组合而成，主要有以下几个取值：

1. **max-age** 指定一个时间长度，在这个时间段内缓存是有效的，单位是s。

   例如设置 Cache-Control:max-age=31536000，也就是说缓存有效期为（31536000 / 24 / 60 / 60）天，

   第一次访问这个资源的时候，服务器端也返回了 Expires 字段，并且过期时间是一年后。

   在没有禁用缓存并且没有超过有效时间的情况下，再次访问这个资源就命中了缓存，不会向服务器请求资源而是直接从浏览器缓存中取。

2. **no-cache** 强制所有缓存了该响应的用户，在使用已缓存的数据前，发送带验证的请求到服务器, 问服务器是否可以读缓存。

   不是字面意思上的不缓存。 

3. **no-store** 禁止缓存，每次请求都要向服务器重新获取数据。

注意: 如果命中强缓存,  在有效期内, 使用了本地浏览器的缓存,  请求该资源是不会向服务器发送请求的! (大大减轻了服务器压力)

**协商缓存 (强缓存未命中-发送请求进行协商)**

看看过期时间, 食品没过期, 直接吃 (直接读缓存, 不发请求)    命中强缓存!

食品过期时间过了,  能不能吃呢?  问问专家(服务器),  专家瞅了一眼,  还能吃, 不会死人, 重新标了个过期时间(有科学依据)

 (响应304, 不返回内容) , 可以用 (协商缓存) 

如果问过专家(服务器), 专家瞅了一眼, 呀真不能用了, 原来的不要了, 我重新给你发一个 (响应200, 并返回内容)

**协商缓存**

若未命中强缓存(强缓存过期了)，则浏览器会将请求发送至服务器。

服务器根据http头信息中的`Last-Modify/If-Modify-Since`或`Etag/If-None-Match`来判断是否命中协商缓存。

如果命中，则http返回码为304 (你本地之前加载的资源是有效的)，浏览器从缓存中加载资源。

**Last-Modify/If-Modify-Since**

浏览器第一次请求一个资源的时候, 服务器返回的header中会加上Last-Modify，

Last-modify是一个时间标识该资源的**最后修改时间**，例如`Last-Modify: Thu,31 Dec 2037 23:59:59 GMT`。

当浏览器再次请求该资源时(进行协商请求时)，发送的请求头中会包含If-Modify-Since，**该值为缓存之前返回的Last-Modify**。

服务器收到If-Modify-Since后，根据实际服务器的资源的最后修改时间, 进行判断是否命中缓存。

如果命中缓存，则返回 **http304**，并且不会返回资源内容，并且不会返回Last-Modify。

由于对比的是**服务端的修改时间**，所以就算客户端与服务端时间差距,  也不会有问题。

**但是有时候通过最后修改时间来判断资源是否修改还是不太准确（资源变化了最后修改时间也可以一致）。**

比如: 最后修改只能精确到秒级, 一秒进行了多次修改, 就不行了,  **于是出现了ETag/If-None-Match。**

**ETag/If-None-Match**

与Last-Modify/If-Modify-Since (最后修改时间)不同的是，Etag/If-None-Match返回的是一个校验码（ETag: entity tag）。

ETag可以保证每一个资源是唯一的，资源变化都会导致ETag变化。

ETag值的变更则说明资源状态已经被修改。

服务器根据浏览器上发送的If-None-Match值来判断是否命中缓存。

ETag生成靠以下几种因子

1. 文件的i-node编号，是Linux/Unix用来识别文件的编号。 

2. 文件最后修改时间

3. 文件大小

   ...

**生成Etag的时候，可以使用其中一种或几种因子，使用抗碰撞散列函数来生成。生成一个标记文件的唯一值**

**既生 Last-Modified 何生 Etag ？**

你可能会觉得使用Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要Etag（实体标识）呢？

Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：

1. Last-Modified标注的最后修改只能精确到秒级

   如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间

2. 有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形

Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加 **准确的控制缓存。** 

不会仅仅只根据最后的修改时间判断是否进行使用缓存

Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，

最后才决定是否返回304。

小结:

- **强缓存:** 检查过期时间, 判断缓存是否失效,  如果不失效, 直接用, 不发请求 

  大大的减少了 服务器的请求次数, 在过期时间内, 直接从客户端内存中读 

- **协商缓存**: 强缓存命中失效了, 超过过期时间了, 拿着标识(最后的修改时间,  唯一标识etag), 去问服务器, 是否真的过期了

  如果验证通过,  服务器会直接响应 304, 且不会返回资源

不太会变的资源 => 图片, 非常的适合应用强缓存 (过期时间也可以设置的很长)

如果是一些很可能会变的资源, 也希望能缓存 => 过期时间设置短一些,  一旦过期, 协商缓存

实际工作两者相互配合

**整体请求缓存流程**

**浏览器第一次请求**




**浏览器第二次请求**


### TCP协议是什么?

TCP(Transmission Control Protocol 传输控制协议) 是一种面向连接(连接导向) 的、可靠的、 基于IP的传输层协议。

TCP 使⽤校验、确认和重传机制来保证可靠传输 

**而 HTTP协议 就是建立在 TCP / IP 协议 之上的一种应用。**

TCP: 三次握手, 四次挥手~

### 一次完整的HTTP服务过程是什么

当我们在web浏览器的地址栏中输入：`www.baidu.com`，具体发生了什么？

1. 对`www.baidu.com`这个网址进行DNS域名解析，得到对应的IP地址
2. 根据这个IP，找到对应的服务器，发起TCP的三次握手
3. 建立TCP连接后, 发起HTTP请求
4. 服务器响应HTTP请求，浏览器得到html代码
5. 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等）（先得到html代码，才能去找这些资源）
6. 浏览器对页面进行渲染呈现给用户
7. 服务过程完毕, 关闭TCP连接, 四次挥手

注：

1.DNS怎么找到域名的？

> DNS域名解析采用的是递归查询的方式，过程是，先去找DNS缓存->缓存找不到就去找根域名服务器->根域名又会去找下一级，这样递归查找之后，找到了，给我们的web浏览器

2.为什么HTTP协议要基于TCP来实现？  

> TCP是一个端到端的可靠面相连接的协议，HTTP基于传输层TCP协议不用担心数据传输的各种问题（当发生错误时，可以重传）

3.最后一步浏览器是如何对页面进行渲染的？  

> a）解析html文件构成 DOM树
> b）解析CSS文件构成渲染树
> c）边解析，边渲染
> d）JS 单线程运行，JS有可能修改DOM结构，意味着JS执行完成前，后续所有资源的下载是没有必要的，所以JS是单线程，会阻塞后续资源下载

### 什么是DNS 解析

**DNS解析（域名解析服务器）**  将 域名 转换成 ip地址   (一个域名和ip的映射关系, 具体登记在哪里, 看我们如何申请关联的!)

假定请求的是 www.baidu.com

a）首先会搜索浏览器自身的DNS缓存（缓存时间比较短，大概只有1分钟，且只能容纳1000条缓存）

b）如果浏览器自身的缓存里面没有找到，那么浏览器会搜索系统自身的DNS缓存

c）如果还没有找到，那么尝试从 hosts 文件里面去找  (一个系统电脑的文件, 可以编辑, 可以存 域名 和 ip 的对应关系)

d）在前面三个过程都没获取到的情况下，就递归地去域名服务器去查找(就近查找)，具体过程如下

DNS优化两个方面：DNS缓存、DNS负载均衡 (准备多台dns服务器, 进行dns解析)

### TCP 三次握手理解 (双方确认)

TCP是一个端到端的  **可靠**  面相连接的协议，

HTTP基于传输层TCP协议不用担心数据传输的各种问题（当发生错误时，可以重传）

根据这个IP，找到对应的服务器，发起TCP的三次握手 ([tcp 三次握手四次挥手](https://blog.csdn.net/qq_38950316/article/details/81087809) ) 

**为什么要3次握手**

我们假定第一次发送的请求,  因为网络延迟很慢才到达服务端，

然后客户端以为这服务器居然不理睬我，然后默默的关闭的等待连接的请求，走开了（好比追女神）；

但事实呢？女神（服务器）是因为各种各样的原因，很晚才看到，然后说我接受你了, 同意你的要求咱们两结婚吧！

但是，A早已经远走高飞，这个请求A完全不会收到（在第二次握手，服务端打开连接，等待客户端的响应），

那么女生呢，以为对方收到了，就会一直等待，这样B的资源就会被浪费的（创建连接的时候，空间浪费以及端口消耗）；

而三次握手, 就不会发生，服务端同意连接了，但是A缺一直没有下一步的动作，导致资源浪费；

### 关闭TCP连接四次挥手的理解 (客气挽留)

目标: 关闭连接(四次挥手) 

不能直接一次性断开连接(双方知晓), 万一还有什么数据没有传完, 造成数据的丢失!

 这和有礼貌的好友道别一样：（a：客户端 b:服务端）
1、一开始A想要回家离开，但是呢？怕B还有事情要交代，那么呢？只好先向B打招呼，我要走了，请求停止交谈(请求断开连接)

​    (此时，a到B的连接没有断开，依旧可以进行通信）；
2、同意A的请求，说好的，但是我这里可能还有一些话（数据）没说完。我检查看看,  你等等,  等我说完你再走。
3、B确实没啥要补充的了，就告知你我可以撤了
4、A说好的，知道了，88；（B得知A走开了，关闭了自己的连接 )



**完整的一次 http 请求流程才算结束**

### 什么是同源策略？

所谓同源策略是浏览器的一种安全机制，来限制不同源的网站不能通信。同源就是`域名、协议、端口`一致。

### 跨域问题及解决方案

**什么是跨域**

指的是浏览器不能执行其他网站的脚本，它是由浏览器的同源策略造成的,是浏览器对 javascript 施加的安全限制，防止他人恶意攻击网站

**解决方式** 

**1、`jsonp`**

原理：动态创建一个 script 标签。利用 script 标签的 src 属性不受同源策略限制。因为所有的 src 属性和 href 属性都不受同源策略限制。可以请求第三方服务器数据内容。

步骤:

1.1）去创建一个 script 标签

1.2）script 的 src 属性设置接口地址

1.3）接口参数,必须要带一个自定义函数名要不然后台无法返回数据。

1.4）通过定义函数名去接收后台返回数据

```js
    //去创建一个 script 标签
    var script = document.createElement("script");
    //script 的 src 属性设置接口地址 并带一个 callback 回调函数名称
    script.src = "HTTP://127.0.0.1:8888/index.php?callback=jsonpCallback";
    //插入到页面
    document.head.appendChild(script);
    //通过定义函数名去接收后台返回数据
    function jsonpCallback(data){
    //注意 jsonp 返回的数据是 json 对象可以直接使用
    //Ajax 取得数据是 json 字符串需要转换成 json 对象才可以使用。
    }
```

**2、 CORS：跨域资源共享**

原理：服务器设置 Access-Control-Allow-OriginHTTP 响应头之后，浏览器将会允许跨域请求

限制：浏览器需要支持 HTML5，可以支持 POST，PUT 等方法兼容 ie9 以上，需要后台设置

```js
Access-Control-Allow-Origin: * //允许所有域名访问，或者
Access-Control-Allow-Origin: HTTP://a.com //只允许所有域名访问
```

**3、代理服务器**

说明: 同源策略, 是浏览器的安全策略, 服务器于服务器之间, 没有跨域问题! 所以可以利用代理服务器转发请求!

1. 开发环境的跨域问题 (使用webpack代理服务器解决)

   配置 devServer 的 proxy 配置项

   ```jsx
   module.exports = {
     devServer: {
      // 代理配置
       proxy: {
           // 这里的api 表示如果我们的请求地址有/api的时候,就出触发代理机制
           '/api': {
             target: 'www.baidu.com', // 我们要代理请求的地址
              // 路径重写
             pathRewrite: {
                 // 路径重写  localhost:8888/api/login  => www.baidu.com/api/login
                 '^/api': '' // 假设我们想把 localhost:8888/api/login 变成www.baidu.com/login 就需要这么做 
             }
         },
       }
     }
   }
   ```

2. 生产环境的跨域问题 (使用 nginx 服务器代理)




### **一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？**

01.`浏览器` `查找`域名对应的`IP地址`(DNS 查询：浏览器缓存->系统缓存->路由器缓存->ISP DNS 缓存->根域名服务器)

02.`浏览器` `向 Web 服务器` `发送`一个 `HTTP 请求`（TCP三次握手）

03.`服务器` 301 `重定向`（从 [http://example.com](http://example.com/) 重定向到 [http://www.example.com）](http://www.example.com%29/)

04.`浏览器` `跟踪` `重定向地址`，请求另一个带 www 的网址

05.`服务器` `处理请求`（通过路由读取资源）

06.`服务器` `返回`一个 `HTTP 响应`（报头中把 Content-type 设置为 'text/html'）

07.`浏览器` `进 DOM 树构建`

08.`浏览器` `发送请求获取`嵌在 HTML 中的`资源`（如图片、音频、视频、CSS、JS等）

09.`浏览器` `显示完成页面`

10.`浏览器` `发送异步请求`

### 安全问题 ：CSRF 和 XSS攻击？

`CSRF`（`Cross-site request forgery`）：**`跨站请求伪造`**。

**方法一、Token 验证：**（用的最多）

1. 服务器发送给客户端一个`token`；
2. 客户端提交的表单中带着这个`token`。
3. 如果这个 `token` 不合法，那么服务器拒绝这个请求。

**方法二：隐藏令牌：**

把 `token` 隐藏在 `http` 的 `head`头中。

方法二和方法一有点像，本质上没有太大区别，只是使用方式上有区别。

**方法三、Referer 验证：**

`Referer` 指的是页面请求来源。意思是，**只接受本站的请求，服务器才做响应**；如果不是，就拦截

`XSS`（`Cross Site Scripting`）：**`跨域脚本攻击`**。

**1. 编码**：

对用户输入的数据进行`HTML Entity`编码。

如上图所示，把字符转换成 转义字符。

`Encode`的作用是将`$var`等一些字符进行转化，使得浏览器在最终输出结果上是一样的。

比如说这段代码：

```javascript
<script>alert(1)</script>
```

> 若不进行任何处理，则浏览器会执行alert的js操作，实现XSS注入。进行编码处理之后，在浏览器中的显示结果就是`<script>alert(1)</script>`，实现了将``$var`作为纯文本进行输出，且不引起`JavaScript`的执行。

**2、过滤：**

- 移除用户输入的和事件相关的属性。如`onerror`可以自动触发攻击，还有`onclick`等。（总而言是，过滤掉一些不安全的内容）
- 移除用户输入的`Style`节点、`Script`节点、`Iframe`节点。（尤其是`Script`节点，它可是支持跨域的呀，一定要移除）。

**3、校正**

- 避免直接对`HTML Entity`进行解码。
- 使用`DOM Parse`转换，校正不配对的`DOM`标签。

备注：我们应该去了解一下`DOM Parse`这个概念，它的作用是把文本解析成`DOM`结构。

比较常用的做法是，通过第一步的编码转成文本，然后第三步转成`DOM`对象，然后经过第二步的过滤。

### CSRF 和 XSS 的区别

**区别一：**

- `CSRF`：需要用户先登录网站`A`，获取 `cookie`
- `XSS`：不需要登录。

**区别二：（原理的区别）**

- `CSRF`：是利用`网站`A`本身的漏洞`，去请求网站`A`的`api`。
- `XSS`：是向`网站 `A` 注入 `JS`代码，然后执行 `JS` 里的代码，篡改网站`A`的内容`。

### cookie 、localstorage 、 sessionstrorage 之间有什么区别？

- `与服务器交互`：
  - cookie 是网站为了`标示用户身份`而`储存在用户本地终端上`的数据（通常经过加密）
  - cookie 始终会在`同源 http 请求头`中携带（即使不需要），在浏览器和服务器间来回传递
  - sessionStorage 和 localStorage `不会自动把数据发给服务器`，`仅在本地保存`
- `存储大小`：
  - cookie 数据根据不同浏览器限制，大小一般不能超过`4k`
  - sessionStorage 和 localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到`5M`或更大

- `有期时间`：
  - localStorage `存储持久数据`，`浏览器关闭后数据不丢失除非主动删除数据`
  - sessionStorage 数据在`当前浏览器窗口关闭后自动删除`
  - cookie 设置的`cookie过期时间之前一直有效`，`与浏览器是否关闭无关`

### cookie和session 的区别

- 1、`cookie数据`存放在`客户的浏览器`上，`session数据`放在`服务器`上。
- 2、cookie不是很`安全`，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
  - 考虑到安全应当使用session。
- 3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的`性能`
  - 考虑到减轻服务器性能方面，应当使用COOKIE。
- 4、单个cookie保存的数据不能超过4K，很多浏览器都`限制`一个站点最多保存20个cookie。
- 5、所以个人建议：
  - 将登陆信息等重要信息存放为SESSION
  - 其他信息如果需要保留，可以放在COOKIE中

### 说一下 AJAX 的状态码

### 说一下 HTTP 的状态码，301、302、304 分别是什么

400: 请求参数错误

401: token过期,没有权限

403: 没有权限

405: 请求方式错误

301: 

302: 

304:

## node

### 说一下你对 Node 的了解

Node 是基于 v8 引擎的开发环境,可以开发一些命令行小工具,

## webpack

### 平时都是用那些工具进行打包的？babel是什么？

babel 是一个 `ES6 转码器`，可以帮我们将`语法降级`

WebPack 是一个模块打包工具，你可以使用WebPack管理你的`模块依赖`，并`编绎输出模块们所需的静态文件`。它能够很好地管理、打包Web开发中所用到的HTML、Javascript、CSS以及各种静态文件（图片、字体等），让开发过程更加高效。对于不同类型的资源，webpack有对应的模块加载器。webpack模块打包器会分析模块间的依赖关系，最后 生成了优化且合并后的静态资源

babel可以帮助我们转换一些当前浏览器不支持的语法，它会把这些语法转换为低版本的语法以便浏览器识别。

### 怎么配置 vue-cli 这个工具呢，你都配置过哪些东西（vue.config.js）

### 了解 Webpack 吗，说一下常见的配置

## vue

## react

### 什么是虚拟DOM？

​		虚拟 DOM (VDOM)是真实 DOM 在内存中的表示。UI 的表示形式保存在内存中，并与实际的 DOM 同步。这是一个发生在渲染函数被调用和元素在屏幕上显示之间的步骤，整个过程被称为调和。

### 虚拟DOM实现的原理？

1)虚拟DOM本质上是JavaScript对象,是对真实DOM的抽象
2)状态变更时，记录新树和旧树的差异
3)最后把差异更新到真正的dom中

### 类组件和函数组件之间的区别是啥？

类组件可以使用其他特性，如状态 state 和生命周期钩子。
当组件只是接收 props 渲染到页面时，就是无状态组件，就属于函数组件，也被称为哑组件或展示组件。
函数组件和类组件当然是有区别的，而且函数组件的性能比类组件的性能要高，因为类组件使用的时候要实例化，而函数组件直接执行函数取返回结果即可。如果都能满足需求的情况下，为了提高性能，尽量使用函数组件。

### React 中 refs 干嘛用的？

Refs 提供了一种访问在render方法中创建的 DOM 节点或者 React 元素的方法。
		可以在组件添加一个 ref 属性来使用，该属性的值是一个回调函数，接收作为其第一个参数的底层 DOM 元素或组件的挂载实例。

### 在 React 中如何处理事件？

为了解决跨浏览器的兼容性问题，SyntheticEvent(事件e) 实例将被传递给你的事件处理函数，SyntheticEvent是 React 跨浏览器的浏览器原生事件包装器，它还拥有和浏览器原生事件相同的接口，包括 stopPropagation() 和 preventDefault()。

### state 和 props 区别是啥？

props和state是普通的 JS 对象。虽然它们都包含影响渲染输出的信息，但是它们在组件方面的功能是不同的。即
1)state 是组件自己管理数据，控制自己的状态，可变；
2)props 是外部传入的数据参数，不可变；
3)没有state的叫做无状态组件，有state的叫做有状态组件；
4)多用 props，少用 state，也就是多写无状态组件。

### 如何创建 refs？

​	Refs 是使用 React.createRef() 创建的，并通过 ref 属性附加到 React 元素。在构造组件时，通常将 Refs 分配给实例属性，以便可以在整个组件中引用它们。

### 什么是高阶组件？

​	高阶组件(HOC)是接受一个组件并返回一个新组件的函数。基本上，这是一个模式，是从 React 的组合特性中衍生出来的，称其为纯组件，因为它们可以接受任何动态提供的子组件，但不会修改或复制输入组件中的任何行为。

### 在构造函数调用 `super` 并将 `props` 作为参数传入的作用是啥？

​	在调用 super() 方法之前，子类构造函数无法使用this引用，ES6 子类也是如此。将 props 参数传递给 super() 调用的主要原因是在子构造函数中能够通过this.props来获取传入的 props。

### 什么是控制组件？

在 HTML 中，表单元素如 <input>、<textarea>和<select>通常维护自己的状态，并根据用户输入进行更新。当用户提交表单时，来自上述元素的值将随表单一起发送。
	而 React 的工作方式则不同。包含表单的组件将跟踪其状态中的输入值，并在每次回调函数(例如onChange)触发时重新渲染组件，因为状态被更新。以这种方式由 React 控制其值的输入表单元素称为受控组件。

### 讲讲什么是 JSX ？

jsx是JavaScript的一种语法扩展，它跟模板语言很接近，但是它充分具备JavaScript的能力
当 Facebook 第一次发布 React 时，他们还引入了一种新的 JS 方言 JSX，将原始 HTML 模板嵌入到 JS 代码中。JSX 代码本身不能被浏览器读取，必须使用Babel和webpack等工具将其转换为传统的JS。
JSX中的标签可以是单标签，也可以是双标签，但必须保证标签是闭合的。

### 为什么不直接更新 `state` 呢 ?

如果试图直接更新 state ，则不会重新渲染组件。
需要使用setState()方法来更新 state。它调度对组件state对象的更新。当state改变时，组件通过重新渲染来响应。

### React 组件生命周期有哪些不同阶段？

在组件生命周期中有四个不同的阶段：
	1)Initialization：在这个阶段，组件准备设置初始化状态和默认属性。
	2)Mounting：react 组件已经准备好挂载到浏览器 DOM 中。这个阶段包括componentWillMount和componentDidMount生命周期方法。
	3)Updating：在这个阶段，组件以两种方式更新，发送新的 props 和 state 状态。此阶段包括shouldComponentUpdate、componentWillUpdate和componentDidUpdate生命周期方法。
	4)Unmounting：在这个阶段，组件已经不再被需要了，它从浏览器 DOM 中卸载下来。这个阶段包含 componentWillUnmount 生命周期方法。
除以上四个常用生命周期外，还有一个错误处理的阶段：
	5)Error Handling：在这个阶段，不论在渲染的过程中，还是在生命周期方法中或是在任何子组件的构造函数中发生错误，该组件都会被调用。这个阶段包含了 componentDidCatch 生命周期方法。

### React 的生命周期方法有哪些？

1)componentWillMount:在渲染之前执行，用于根组件中的 App 级配置。
2)componentDidMount：在第一次渲染之后执行，可以在这里做AJAX请求，DOM 的操作或状态更新以及设置事件监听器。
3)componentWillReceiveProps：在初始化render的时候不会执行，它会在组件接受到新的状态(Props)时被触发，一般用于父组件状态更新时子组件的重新渲染
4)shouldComponentUpdate：确定是否更新组件。默认情况下，它返回true。如果确定在 state 或 props 更新后组件不需要在重新渲染，则可以返回false，这是一个提高性能的方法。
5)componentWillUpdate：在shouldComponentUpdate返回 true 确定要更新组件之前件之前执行。
6)componentDidUpdate：它主要用于更新DOM以响应props或state更改。
7)componentWillUnmount：它用于取消任何的网络请求，或删除与组件关联的所有事件监听器。

### 使用 React Hooks 好处是啥？

首先，Hooks 通常支持提取和重用跨多个组件通用的有状态逻辑，而无需承担高阶组件或渲染 props 的负担。Hooks 可以轻松地操作函数组件的状态，而不需要将它们转换为类组件。
Hooks 在类中不起作用，通过使用它们，咱们可以完全避免使用生命周期方法，例如 componentDidMount、componentDidUpdate、componentWillUnmount。相反，使用像useEffect这样的内置钩子。

### 什么是 React Hooks？

​	Hooks是 React 16.8 中的新添加内容。它们允许在不编写类的情况下使用state和其他 React 特性。使用 Hooks，可以从组件中提取有状态逻辑，这样就可以独立地测试和重用它。Hooks 允许咱们在不改变组件层次结构的情况下重用有状态逻辑，这样在许多组件之间或与社区共享 Hooks 变得很容易。

### React 中的 `useState()` 是什么？

useState 是一个内置的 React Hook。useState(0) 返回一个元组，其中第一个参数count是计数器的当前状态，setCounter 提供更新计数器状态的方法。
可以在任何地方使用setCounter方法更新计数状态-在这种情况下，咱们在setCount函数内部使用它可以做更多的事情，使用 Hooks，能够使咱们的代码保持更多功能，还可以避免过多使用基于类的组件。

### React 中的StrictMode(严格模式)是什么？

React 的StrictMode是一种辅助组件，可以帮助咱们编写更好的 react 组件，可以使用<StrictMode />包装一组组件，并且可以帮咱们以下检查：
1)验证内部组件是否遵循某些推荐做法，如果没有，会在控制台给出警告。
2)验证是否使用的已经废弃的方法，如果有，会在控制台给出警告。
3)通过识别潜在的风险预防一些副作用。

### 为什么类方法需要绑定到类实例？

在 JS 中，this 值会根据当前上下文变化。在 React 类组件方法中，开发人员通常希望 this 引用组件的当前实例，因此有必要将这些方法绑定到实例。

### 受控组件和非受控组件区别是啥？

受控组件是 React 控制中的组件，并且是表单数据真实的唯一来源。

非受控组件是由 DOM 处理表单数据的地方，而不是在 React 组件中。

尽管非受控组件通常更易于实现，因为只需使用refs即可从 DOM 中获取值，但通常建议优先选择受控制的组件，而不是非受控制的组件。

这样做的主要原因是受控组件支持即时字段验证，允许有条件地禁用/启用按钮，强制输入格式。

### 如何避免组件的重新渲染？

React 中最常见的问题之一是组件不必要地重新渲染。React 提供了两个方法，在这些情况下非常有用：
	1)React.memo():这可以防止不必要地重新渲染函数组件
	2)PureComponent:这可以防止不必要地重新渲染类组件
	这两种方法都依赖于对传递给组件的props的浅比较，如果 props 没有改变，那么组件将不会重新渲染。虽然这两种工具都非常有用，但是浅比较会带来额外的性能损失，因此如果使用不当，这两种方法都会对性能产生负面影响。
	通过使用 React Profiler，可以在使用这些方法前后对性能进行测量，从而确保通过进行给定的更改来实际改进性能。

### 如何避免在React重新绑定实例(解决this指向)？

有几种常用方法可以避免在 React 中绑定方法：
	1)将事件处理程序定义为内联箭头函数
	2)使用箭头函数来定义方法
	3)使用带有 Hooks 的函数组件

### React组件通信如何实现?

React组件间通信方式:

1)父组件向子组件通讯: 父组件可以向子组件通过传 props 的方式，向子组件进行通讯
2)子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信息，作为参数，传递到父组件的作用域中
3)兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信息进行通信
4)跨层级通信: Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再适合不过
5)发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入event模块进行通信
6)全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维护一个全局状态中心Store,并根据不同的事件产生新的状态

### React如何进行组件/逻辑复用?

1)高阶组件:
	(1)属性代理
	(2)反向继承
2)渲染属性
3)react-hooks

### redux的工作流程?

首先，我们看下几个核心概念：

1. Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
2. State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这种时点的数据集合，就叫做State。
3. Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到View。所以，

4. State的变化必须是View导致的。Action就是View发出的通知，表示State应该要发生变化了。
5. Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
6. Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参数，返回一个新的State
7. dispatch：是View发出Action的唯一方法。
   然后整个工作流程：
   * 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   * 然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer会返回新的State。
   * State一旦有变化，Store就会调用监听函数，来更新View。

### redux中如何进行异步操作?

当然,我们可以在componentDidmount中直接进行请求无须借助redux.
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中间件进行异步处理.
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度还是npm下载量都比较差了。

## 浏览器底层原理

### 浏览器是如何解析CSS选择器的？

在生成渲染树的过程中，渲染引擎会根据选择器提供的信息来遍历 DOM 树，找到对应的 DOM 节点后将样式规则附加到上面。

来看一段样式选择器代码、以及一段要应用样式的 HTML：

```css
.mod-nav h3 span {
	font-size: 16px;
}
```

```html
<div class="mod-nav">
  <header>
    <h3>
      <span>标题</span>
    </h3>
  </header>
  
  <div>
    <ul>
      <li><a href="#">项目一</a></li>
      <li><a href="#">项目一</a></li>
      <li><a href="#">项目一</a></li>
    </ul>
  </div>
</div>

<div class="box">
    ...
</div>
```



渲染引擎是怎么根据以上样式选择器去遍历这个 DOM 树的呢？是按照从左往右的选择器顺序去匹配，还是从右往左呢？

为了更直观的观查，我们先将这棵 DOM 树先绘制成图：


然后我们来对比一下两种顺序的匹配：



**从左往右：`.mod-nav  =>   h3  =>    span`**

1. 遍历所有的元素, 找有 .mod-nav 类的节点

2. 从 `.mod-nav` 开始遍历所有的⼦孙节点 `header`、`div` 、 `h3`、 `ul` ....

   遍历所有的后代元素后, 知道了, 整个子孙后代只有一个 h3

3. 找到 `h3` ,  还要继续重新遍历 `h3` 的所有子孙节点, 去找 `span`

   ...

**问题: 会进行大量树形结构子孙节点的遍历, 这是非常消耗成本的!**

**这在真实页面中⼀棵 DOM 树的节点成百上千的情况下，这种遍历方式的效率会非常的低，根本不适合采用。**



**从右往左：`span   =>   h3   =>   .mod-nav`**

1. 先找到所有的 `span` 节点 ，然后基于每⼀个 `span` 再向上查找 `h3` 

2. 由 `h3` 再向上查找 `.mod-nav` 的节点

3. 最后触及根元素 `html` 结束该分⽀遍历

   ...

从右向左的匹配规则, 只有第一次会遍历所有元素找节点, 而剩下的就是在看父辈祖辈是否满足选择器的条件, 匹配效率大大提升!

因此，浏览器遵循 “从右往左” 的规则来解析 CSS 选择器！

### 浏览器是如何进行界面渲染的？

不同的渲染引擎的具体做法稍有差异，但是大体流程都是差不多的，下面以 chrome渲染引擎 的 渲染流程来说明：

上图展示的流程是：

1. 获取 HTML ⽂件并进⾏解析，生成一棵 DOM 树（DOM Tree）

2. 解析 HTML 的同时也会解析 CSS，⽣成样式规则（Style Rules）

3. 根据 DOM 树和样式规则，生成一棵渲染树（Render Tree）

4. 进行布局（Layout）(重排)，即为每个节点分配⼀个在屏幕上应显示的确切坐标位置 

5. 进⾏绘制（Paint）(重绘)，遍历渲染树节点，调⽤ GPU(图形处理器) 将元素呈现出来 

### 什么是重绘和回流，如何减少重绘和回流

**重排**

重排是指部分或整个渲染树需要重新分析，并且节点的尺⼨需要重新计算。

表现为 **重新⽣成布局，重新排列元素。**

**重绘**

重绘是由于节点的⼏何属性发⽣改变，或由于样式发⽣改变（例如：改变元素背景⾊）。

表现为某些元素的外观被改变。或者重排后, 进行重新绘制!

**两者的关系**

> 重绘不⼀定会出现重排，重排必定会触发重绘。

每个页面至少需要一次回流+重绘。(初始化渲染)

重排和重绘的代价都很⾼昂，频繁重排重绘, 会破坏⽤户体验、让界面显示变迟缓。

我们需要尽可能避免频繁触发重排和重绘, 尤其是重排

### **何时会触发重排？**

重排什么时候发生？

1、添加或者删除可见的DOM元素；

2、元素位置改变；

3、元素尺寸改变——边距、填充、边框、宽度和高度

4、内容改变——比如文本改变或者图片大小改变而引起的计算值宽度和高度改变；

5、页面渲染初始化；

6、浏览器窗口尺寸改变——resize事件发生时；

### 浏览器对重绘重排的优化

思考下述代码的重绘重排过程!

```javascript
let s = document.body.style
s.padding = "2px" // 重排 + 重绘
s.border = "1px solid red" // 再一次 重排 + 重绘
s.color = "blue" // 再一次重绘
s.backgroundColor = "#ccc" // 再一次 重绘
s.fontSize = "14px" // 再一次 重排 + 重绘
document.body.appendChild(document.createTextNode('abc!')) // 添加node，再一次 重排 + 重绘
```

**聪明的浏览器:**

从上个实例代码中可以看到几行简单的JS代码就引起了 4次重排、6次重绘。

而且我们也知道重排的花销也不小，如果每句JS操作都去重排重绘的话，浏览器可能就会受不了!

所以浏览器会优化这些操作，**浏览器会维护1个队列，把所有会引起重排、重绘的操作放入这个队列**，

**等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会flush队列，进行一个`批处理`。**

这样就会让多次的重排、重绘变成了一次重排重绘。

虽然有了浏览器的优化，但有时候我们写的一些代码可能会强制浏览器提前flush队列，这样浏览器的优化可能起不到作用了。

比如当你请求向浏览器获取一些样式信息的时候(保证获取结果的准确性)，就会让浏览器flush队列

1. offsetTop, offsetLeft, offsetWidth, offsetHeight
2. scrollTop/Left/Width/Height
3. clientTop/Left/Width/Height
4. 请求了getComputedStyle()
5. ....

### 重绘重排角度, 我们应该如何优化页面渲染性能 ？

优化页面渲染性能的角度:  尽可能减少重绘和重排的次数

主要有几大方式来避免：

- 1 集中修改样式 (这样可以尽可能利用浏览器的优化机制, 一次重排重绘就完成渲染)

- 2 尽量避免在遍历循环中, 进行元素 offsetTop 等样式值的获取操作, 会强制浏览器刷新队列, 进行渲染

- 3 利用 transform 实现动画变化效果, 去代替 left top 的变换 (轮播图等)

  transform变换, 只是视觉效果! 不会影响到其他盒子,  只触发了自己的重绘

- 4 使用文档碎片（DocumentFragment）可以用于批量处理, 创建元素

**文档碎片的理解:**

**documentFragment**是一个保存多个元素的容器对象（保存在内存）当更新其中的一个或者多个元素时，页面不会更新。

当documentFragment容器中保存的所有元素操作完毕了,  只有将其插入到页面中才会更新页面。

```html
<ul id="box"></ul>

<script>
  let ul = document.getElementById("box")
  for (let i = 0; i < 20; i++) {
    let li = document.createElement("li")
    li.innerHTML = "index: " + i
    ul.appendChild(li)
  }


  // let ul = document.getElementById("box")
  // let fragment = document.createDocumentFragment()
  // for (let i = 0; i < 20; i++) {
  //     let li = document.createElement("li")
  //     li.innerHTML = "index: " + i
  //     fragment.appendChild(li)
  // }
  // ul.appendChild(fragment)
</script>
```

vue底层渲染更新, 就用了  document.createDocumentFragment

### 前端如何实现即时通讯？websocket

`严格意义上: HTTP协议只能做到客户端请求服务器, 服务器做出响应, 做不到让服务器主动给客户端推送消息!`

**那么如果服务器数据更新了, 想要即时通知到客户端怎么办呢 ? (即时通信需求)**

即时通信需求: 服务器数据一有更新, 希望推送给到浏览器

提问的回答重心:

1. 即时通信有哪些方案? 
2. 为什么使用了其中某一个方案! websocket



基于Web的前端，存在以下几种可实现即时通讯的方式：

- 短轮询 (历史方案)   

  开个定时器, 每隔一段时间发请求 (实时性不强)

- Comet - ajax长轮询(历史方案)    

  发送一个请求, 服务器只要数据不更新, 就一直阻塞  (服务器压力过大)

- SSE   

  (利用了http协议, 流数据的传输, 并不是严格意义的双向通信, 无法复用连接)

- WebSocket (主流)  

  性能和效率都高!

**短轮询** (历史方案)

短轮询就是客户端定时发送请求，获取服务器上的最新数据。不是真正的即时通讯，但一定程度上可以模拟即时通讯的效果。

优缺点：

- 优点：浏览器兼容性好，实现简单  setInterval
- 缺点：实时性不高，资源消耗高，存在较多无用请求，影响性能



**Comet - ajax长轮询** (历史方案)

短轮询的实时性, 着实太差,  所以 Comet 技术方案应运而生, 用以实现即时通讯

使用 Ajax 长轮询（long-polling）

- 浏览器发出XMLHttpRequest 请求，服务器端接收到请求后，会阻塞请求直到有数据或者超时才返回

- 浏览器JS在处理返回信息(有数据或者超时) 后再次发出请求。服务器收到请求后, 会再次阻塞到有数据或者超时 

  ...



优缺点：

- 优点：浏览器兼容性好，**即时性好**，**不存在⽆⽤请求** 

- 缺点：**服务器压力较大**（维护⻓连接会消耗较多服务器资源）



**SSE**

服务端推送事件（Server-Sent Event），它是⼀种基于HTTP协议,  允许服务端向客户端推送新数据的 HTML5 技术。 

**问题: HTTP协议 不是 无法做到服务器主动向客户端推送消息么?**

这些 SSE 采用了一些小技巧! 详细见 [参考文章：SSE教程](https://www.ruanyifeng.com/blog/2017/05/server-sent_events.html)


优缺点：

- 优点：基于 HTTP，无需太多改造就能使⽤；相比 WebSocket 要简单一些
- 缺点：基于⽂本传输，效率没有 WebSocket ⾼；基于HTTP协议, 不是严格的双向通信



**WebSocket** (目前主流)

这是基于 TCP 协议的全新、独⽴的协议，作⽤是在服务器和客户端之间建⽴实时的双向通信。

WebSocket 协议与 HTTP 协议保持兼容，但它不会融⼊ HTTP 协议，仅作为 HTML 5 的⼀部分。 

优缺点：

- 优点：真正意义上的双向实时通信，性能好、延迟低 

- 缺点：由于是独⽴于 HTTP 的协议，因此要使用的话需要对项⽬作改造；

  使⽤复杂度会⾼一些，通常需要引⼊成熟的库 (如: Socket-io )；并且⽆法兼容低版本的浏览器

HTTP 和 WebSocket 的连接通信比较图：

## 前端工程化

### Babel的原理是什么？

Babel 的主要工作是对代码进行转译。(解决兼容,  解析执行一部分代码)

```jsx
let a = 1 + 1    =>  var a = 2
```

转译分为三阶段：

- 解析（Parse），将代码解析⽣成抽象语法树 AST，也就是词法分析与语法分析的过程 

- 转换（Transform），对语法树进⾏变换方面的⼀系列操作。通过 babel-traverse，进⾏遍历并作添加、更新、删除等操作

- ⽣成（Generate），通过 babel-generator 将变换后的 AST 转换为 JS 代码



转译流程示意图：

我们可以通过  [AST Explorer 工具](https://astexplorer.net/) 来查看 Babel 具体生成的 AST 节点。

### 如何编写一个Babel插件？(了解)

Babel 插件的主要工作阶段是在 Babel 将代码解析成抽象语法树  AST 之后，

插件们对抽象语法树 AST 进行各种操作后，再由 Babel 输出最终的代码。

要编写一个 Babel 插件模块，则需要为模块代码导出一个函数，且该函数返回一个对象，对象内应包含有 `visitor` 属性：

```js
module.exports = function (babel) {
  return {
    visitor: {}
  }
}
```

`visitor` 是针对各类 抽象语法树节点作处理的地⽅。

我们可以通过  [AST Explorer 工具](https://astexplorer.net/) 来查看 Babel 具体生成的 AST 节点。



**示例**

我们来编写一个插件，其功能是能自动将源码中的数字字面量数学运算进行预计算处理，简化代码。例如：

```js
// 原来的代码
const result = 1 + 2

// 处理后的代码
const result = 3    // 这样优化以后，在实际运行时可以减少一次加法操作
```

我们可以先通过 AST Explorer 来获取 JSON 格式的 AST 结构：

```json
{
  "type": "Program",
  "start": 0,
  "end": 20,
  "body": [
    {
      "type": "VariableDeclaration",
      "start": 0,
      "end": 20,
      "declarations": [
        {
          "type": "VariableDeclarator",
          "start": 6,
          "end": 20,
          "id": {
            "type": "Identifier",
            "start": 6,
            "end": 12,
            "name": "result"
          },
          "init": {
            "type": "BinaryExpression",
            "start": 15,
            "end": 20,
            "left": {
              "type": "Literal",
              "start": 15,
              "end": 16,
              "value": 1,
              "raw": "1"
            },
            "operator": "+",
            "right": {
              "type": "Literal",
              "start": 19,
              "end": 20,
              "value": 2,
              "raw": "2"
            }
          }
        }
      ],
      "kind": "const"
    }
  ],
  "sourceType": "module"
}
```



从以上 AST 结构可以知道，`1 + 2` 是一个 `BinaryExpression` (二进制表达式)类型的节点，

那么在我们编写的插件代码中的 `visitor` 里就可以这样进行处理：

1 装包

```txt
yarn add babel-types babel-core
```

2 新建 `index.js`, 贴入下面到的代码

```js
const t = require('babel-types')

const visitor = {
  BinaryExpression(path) { 
    const node = path.node

    let result

    // 判断表达式两边，是否都是数字 
    if (t.isNumericLiteral(node.left) && t.isNumericLiteral(node.right)) { 
      // 根据不同的操作符作运算 
      switch (node.operator) { 
        case "+": 
          result = node.left.value + node.right.value
          break;
        case "-": 
          result = node.left.value - node.right.value
          break
        case "*": 
          result = node.left.value * node.right.value
          break;
        case "/": 
          result = node.left.value / node.right.value
          break
        default:
          break
      } 
    }

    // 如果上⾯的运算有结果的话 
    if (result !== undefined) { 
      // 把表达式节点替换成number字⾯量 
      path.replaceWith(t.numericLiteral(result))
    } 
  }
}

module.exports = function (babel) { 
  return { 
    visitor 
  }
}      
```

这个插件的基本功能就完成了，新建 test.js 来运行试试：

```js
const babel = require("babel-core")

const result = babel.transform("const result = 1 + 2", { 
  plugins: [ 
    require("./index") 
  ] 
})

console.log(result.code)	// 结果：const result = 3
```

转换结果符合预期。



不过这个插件还不能完全正确的工作，在转换如 `const result = 1 + 2 + 3 + 4 + 5;` 这样的代码时，

结果为 `const result = 3 + 3 + 4 + 5;`，也就是只转换了代码中的第一段表达式计算。

如果用 AST Explorer 查看 AST 结构的话，会发现原来这个运算由层层嵌套的 `BinaryExpression` 组成：

> BinaryExpression(  BinaryExpression( BinaryExpression( BinaryExpression(1 + 2) + 3 ) + 4 ) + 5 ) 



因此我们得改造一下之前的代码逻辑，进行遍历操作：

```js
// 如果上⾯的运算有结果的话 
if (result !== undefined) { 
  // 把表达式节点替换成number字⾯量 
  path.replaceWith(t.numericLiteral(result))

  // 向上遍历⽗级节点
  let parentPath = path.parentPath 
  parentPath && visitor.BinaryExpression.call(this, parentPath)
}
```

这样就能正确工作了。

[参考文档：Babel插件手册](https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md#builders)

### 你们公司的Git工作流是什么样的？

每个公司采用的 Git 工作流都可能会有差别，有的比较规范，有的比较随意。

在这里介绍一个名为 GitFlow 的 git 标准化操作流程。

在 GitFlow 标准下，我们的 git 仓库需要包含以下几个关键分支：

- master：主分支

- develop：主开发分⽀。包含确定即将发布的代码

- feature：新功能分⽀。⼀个新功能对应⼀个分⽀

- release：发布分⽀。发布时⽤的分⽀，⼀般测试阶段发现的 bug 在这个分⽀进⾏修复

- hotfix：热补丁分支。用于修改在线上版本中发现的严重紧急 bug

  

**GitFlow 的主要优点**

- 支持并⾏开发

因为每个新功能都会建⽴⼀个新的 feature 分⽀，从⽽和其他已经完成的功能隔离开，

且当只有在新功能完成开发的情况下，其对应的 feature 分⽀才会被合并到主开发分⽀（develop 分支）。

另外，如果你正在开发某个功能的同时⼜有⼀个新功能需要开始开发，那么你只需把当前 feature 的代码提交后，

切回 develop 分支, 新建另外⼀个 feature 分⽀即可开发新功能了。

你也可以随时切回之前的其他 feature 分⽀继续完成该功能的开发。 



- 协作开发

因为每个 feature 分⽀上改动的代码都只对该 feature 对应的功能生效，

所以不同 feature 分支上的代码在开发时不会互相影响，大家可以相安无事的开发自己负责的功能。

同时我们可以根据分支的名称，很容易知道每个⼈都在做什么功能。 



- ⽀持紧急修复

hotfix 分⽀是从某个已经发布的仓库版本基础上创建出来，用于紧急修复 Bug。

该紧急修复只影响这个已经发布的仓库版本，⽽不会影响你正在开发的其他新 feature 。



**注意点**

1. feature 分⽀都是从 develop 分⽀上创建的，开发完成后再合并到 develop 分⽀上，等待发布

2. 当需要发布时，我们要从 develop 分⽀上创建⼀个 release 分⽀，然后该 release 分⽀会发布到测试环境进⾏测试。

   如果发现问题的话，就会直接在该分⽀上进⾏修复。

   所有问题修复之前，会不停重复 `发布` > `测试` > `修复` > `重新发布`  > `重新测试` 流程。 

   发布结束，该 release 分⽀会被合并到 develop 以及 master 分⽀，从⽽保证不会有代码丢失

3. master 分⽀只跟踪已经发布的代码，合并到 master 上的 commit 只能来⾃ release 分⽀和 hotfix 分⽀

4. hotfix 分⽀的作⽤是紧急修复⼀些 Bug，它们都是从 master 分⽀上的某个版本建⽴，

   修复结束后再被合并到 develop 和 master 分⽀上

### Git的rebase和merge的区别是什么？

`git rebase` 和 `git merge` 两个命令都⽤于从⼀个分⽀获取内容并合并到当前分⽀。 

以一个 `feature/todo` 分⽀合并到 `master`主分⽀为例，我们来看一下分别⽤ `rebase` 和 `merge` 会有什么不同。



**使用 Merge**


`merge` 会⾃动创建⼀个新的 `commit`， 如果合并时遇到冲突的话，只需要修改后重新 `commit`。 

- 优点：能记录真实的 `commit` 情况，包括每个分⽀的详情 

- 缺点：由于每次 `merge` 会⾃动产⽣⼀个 `merge commit`，

  因此在使⽤⼀些可视化的 git 工具时会看到这些自动产生的 `commit`，

  这些 `commit` 对于程序员来说没有什么特别的意义，多了反而会影响阅读



**使用 Rebase**

`rebase` 会合并之前的 `commit` 历史。 

- 优点：可以得到更简洁的提交历史，去掉了 `merge commit`

- 缺点：因为合并而产生的代码问题，就不容易定位，因为会重写提交历史信息 



**建议**

- 当需要保留详细的合并信息，建议使⽤ `git merge`,  尤其是要合并到 master 上

- 当发现⾃⼰修改某个功能时提交比较频繁，并觉得过多的合并记录信息对自己来说没有必要，那么可尝试使用 `git rebase`

### Git 的 reset回退 和 revert撤销

在利用git实现多人合作程序开发的过程中，我们有时会出现  **错误提交** 的情况，

此时我们希望能撤销提交操作, 或者想要回退到某个版本

reset => 回退到某个版本  `git reset --hard 版本号`

revert => 撤销某个版本内容的内容修改  `git revert -n 版本号`

博客参考: https://blog.csdn.net/yxlshk/article/details/79944535



如果git reset 后, 版本回退了, 无法直接push 到远程仓库(因为远程仓库版本更加新) => git push -f 覆盖推送即可

效果: 将远程仓库的版本, 也进行了回退

## 项目

### 后台管理系统中的权限管理是怎么实现的？

登录：当用户填写完账号和密码后向服务端验证是否正确，验证通过之后，服务端会返回一个**`token`**，拿到token之后（我会将这个token存贮到`cookie`中，保证刷新页面后能记住用户登录状态），前端会根据token再去拉取一个 **`user_info`** 的接口来获取用户的详细信息（如用户权限，用户名等等信息）。

权限验证：通过token获取用户对应的 权限，动态根据用户的 权限算出其对应有权限的路由，通过 **router.addRoutes** 动态挂载这些路由。

具体思路：

登录成功后，服务端会返回一个 **token**（该token的是一个能`唯一`标示用户身份的一个key），之后我们将token存储在本地cookie之中，这样下次打开页面或者刷新页面的时候能记住用户的登录状态，不用再去登录页面重新登录了。

ps:为了保证安全性，我司现在后台所有token有效期(Expires/Max-Age)都是Session，就是当浏览器关闭了就丢失了。重新打开游览器都需要重新登录验证，后端也会在每周固定一个时间点重新刷新token，让后台用户全部重新登录一次，确保后台用户不会因为电脑遗失或者其它原因被人随意使用账号。

用户登录成功之后，我们会在全局钩子`router.beforeEach`中拦截路由，判断是否已获得token，在获得token之后我们就要去获取用户的基本信息了

页面会先从 cookie 中查看是否存有 token，没有，就走一遍上一部分的流程重新登录，如果有token,就会把这个 token 返给后端去拉取user_info，保证用户信息是最新的。 当然如果是做了单点登录得功能的话，用户信息存储在本地也是可以的。当你一台电脑登录时，另一台会被提下线，所以总会重新登录获取最新的内容。

先说一说我权限控制的主体思路，前端会有一份路由表，它表示了每一个路由可访问的权限。当用户登录之后，通过 **`token`** 获取用户的 **`role`** ，动态根据用户的 **role** 算出其对应有权限的路由，再通过`router.addRoutes`动态挂载路由。但这些控制都只是页面级的，说白了前端再怎么做权限控制都不是绝对安全的，后端的权限验证是逃不掉的。

我司现在就是前端来控制页面级的权限，不同权限的用户显示不同的侧边栏和限制其所能进入的页面(也做了少许按钮级别的权限控制)，后端则会验证每一个涉及请求的操作，验证其是否有该操作的权限，每一个后台的请求不管是 get 还是 post 都会让前端在请求 `header`里面携带用户的 **token**，后端会根据该 **token** 来验证用户是否有权限执行该操作。若没有权限则抛出一个对应的状态码，前端检测到该状态码，做出相对应的操作。

使用vuex管理路由表，根据vuex中可访问的路由渲染侧边栏组件。

具体实现：

创建vue实例的时候将vue-router挂载，但这个时候vue-router挂载一些登录或者不用权限的公用的页面。

当用户登录后，获取用role，将role和路由表每个页面的需要的权限作比较，生成最终用户可访问的路由表。

调用router.addRoutes(store.getters.addRouters)添加用户可访问的路由。

使用vuex管理路由表，根据vuex中可访问的路由渲染侧边栏组件。

### 谈谈你平时都用了哪些方法进行性能优化？

`减少http请求次数`、`打包压缩上线代码`、`使用懒加载`、`使用精灵图`、`动态渲染组件`、`CDN加载包`。

### 图片懒加载是怎么实现的？

先设置图片的`data-set属性`值为其图片路径，由于不是src，所以不会发送http请求。

图片要显示出来了的时候，再将 data-set 属性替换为 src 属性



就是我们先设置图片的`data-set属性`（当然也可以是其他任意的，只要不会发送http请求就行了，作用就是为了存取值）值为其图片路径，由于不是src，所以不会发送http请求。 然后我们计算出页面scrollTop的高度和浏览器的高度之和， 如果图片距离页面顶端的坐标Y（相对于整个页面，而不是浏览器窗口）小于前两者之和，就说明图片就要显示出来了（合适的时机，当然也可以是其他情况），这时候我们再将 data-set 属性替换为 src 属性即可。

### 移动端有哪些常见的问题，都是怎么解决的？

点击事件300MS延迟问题  解决方案：下载fastclick的包

 **H5页面窗口自动调整到设备宽度，并禁止用户缩放页面**

```html
<meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"> 
```

**忽略Android平台中对邮箱地址的识别**

```html
<meta name="format-detection" content="email=no"> 
```

**当网站添加到主屏幕快速启动方式，可隐藏地址栏，仅针对ios的safari**

```html
<!-- ios7.0版本以后，safari上已看不到效果 -->

<meta name="apple-mobile-web-app-capable" content="yes">
```

### Vue 项目进行 SEO 优化

Vue SPA单页面应用对SEO不太友好，当然也有相应的解决方案，下面列出几种SEO方案

1. SSR服务器渲染

   服务端渲染, 在服务端html页面节点, 已经解析创建完了, 浏览器直接拿到的是解析完成的页面解构

   关于服务器渲染：[Vue官网介绍](https://ssr.vuejs.org/zh/#什么是服务器端渲染-ssr-？) ，对Vue版本有要求，对服务器也有一定要求，需要支持nodejs环境。

   优势:  更好的 SEO，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面

   缺点:  服务器nodejs环境的要求, 且对原代码的改造成本高!  `nuxt.js` (坑比较多, 做好踩坑的准备)

   

2. 静态化 (博客, 介绍性官网) 

   Nuxt.js 可以进行 generate 静态化打包, 缺点: 动态路由会被忽略。 `/users/:id`

   优势：

   - 编译打包时, 就会帮你处理,  纯静态文件，访问速度超快；
   - 对比SSR，不涉及到服务器负载方面问题；
   - 静态网页不宜遭到黑客攻击，安全性更高。

   不足：

   - 如果动态路由参数多的话不适用。



3. 预渲染 prerender-spa-plugin (插件)

   如果你只是对少数页面需要做SEO处理（例如  / 首页,  /about 关于等页面）

   预渲染是一个非常好的方式, 预渲染会在构建时, 简单的针对特定路由, 生成静态 HTML 文件 (打包时可以帮你解析静态化)

   优势: 设置预渲染简单, 对代码的改动小

   缺点: 只适合于做少数页面进行SEO的情况, 如果页面几百上千, 就不推荐了 (会打包很慢)



4. 使用Phantomjs `针对爬虫` 做处理

   Phantomjs是一个基于webkit内核的无头浏览器，没有UI界面，就是一个浏览器，

   其内的点击、翻页等人为相关操作需要程序设计实现。

   这种解决方案其实是一种旁路机制，原理就是通过Nginx配置， 判断访问的来源UA是否是爬虫访问，

   如果是则将搜索引擎的爬虫请求转发到一个node server，再通过PhantomJS来解析完整的HTML，返回给爬虫

   优势：

   - 完全不用改动项目代码，按原本的SPA开发即可，对比开发SSR成本小太多了；
   - 对已用SPA开发完成的项目，这是不二之选。

   不足：

   - 部署需要node服务器支持；

   - 爬虫访问比网页访问要慢一些，因为定时要定时资源加载完成才返回给爬虫；(不影响用户的访问)

   - 如果被恶意模拟百度爬虫大量循环爬取，会造成服务器负载方面问题，

     解决方法是判断访问的IP，是否是百度官方爬虫的IP。

   

小结:

- 如果构建大型网站，如商城类 => SSR服务器渲染

- 如果只是正常公司官网, 博客网站等 => 预渲染/静态化/Phantomjs 都比较方便
- 如果是已用SPA开发完成的项目进行SEO优化，而且部署环境支持node服务器，使用 Phantomjs 

博客参考: [SEO优化方案](https://www.jb51.net/article/164285.htm)

### Vue 项目权限处理

现在权限相关管理系统用的框架都是element提供的[vue-element-admin](https://panjiachen.github.io/vue-element-admin-site/zh/)模板框架比较常见。

权限控制常见分为三大块

- **菜单权限控制**
- **按钮权限控制**
- 请求url权限控制。

**权限管理在后端中主要体现在对接口访问权限的控制，在前端中主要体现在对菜单访问权限的控制。**

1. 按钮权限控制比较容易，主要采取的方式是从后端返回按钮的权限标识，然后在前端进行显隐操作 v-if / disabled。

2. url权限控制，主要是后端代码来控制，前端只需要规范好格式即可。

3. 剩下的菜单权限控制，是相对复杂一些的

   (1) **需要在路由设计时, 就拆分成静态路由和动态路由**

   ​       静态路由: 所有用户都能访问到的路由, 不会动态变化的 (登录页, 首页, 404, ...)

   ​	   动态路由: 动态控制的路由, 只有用户有这个权限, 才将这个路由添加给你 (审批页, 社保页, 权限管理页...)

   (2) 用户登录进入首页时, 需要立刻发送请求, 获取个人信息 (包含权限的标识)


   (3) **利用权限信息的标识, 筛选出合适的动态路由**, 通过路由的 **addRoutes 方法**, 动态添加路由即可!

   (4) router.options.routes (拿的是默认配置的项, 拿不到动态新增的) 不是响应式的! 

   ​	  为了能正确的显示菜单, 为了能够将来正确的获取到用户路由, 我们需要用**vuex管理routes路由数组**

   (5) 利用vuex中的 routes, 动态渲染菜单

### Vue 项目支付功能

支付宝方式：点击支付宝支付,  调用后台接口(携带订单号)，后台返回一个form表单(HTML字符串结构)，

 提交form就可以调用支付宝支付

代码:

```jsx
//  alipayWap: 后台接口返回的form 片段
<div v-html="alipayWap" ref="alipayWap"></div>

methods: {
	toAlipay () {
		this.$axios.get('xxx').then (res = > {
			this.alipayWap = res;
             // 等待dom更新, 等页面中有这个form表单了
			this.$nextTick(() => {
            	this.$refs.alipayWap.children[0].submit()
          	})
		})
	}
}
```



微信支付：需要自己根据后台返回的url生成二维码页面，如图所示


博客参考1: https://blog.csdn.net/qq_36710522/article/details/90480914

博客参考2: https://blog.csdn.net/zyg1515330502/article/details/94737044

### 如何处理 打包出来的项目(首屏)加载过慢的问题

SPA应用: 单页应用程序, 所有的功能, 都在一个页面中, 如果第一次将所有的路由资源, 组件都加载了, 就会很慢!

加载过慢 => 一次性加载了过多的资源,  一次性加载了过大的资源

- 加载过多 => 路由懒加载, 访问到路由, 再加载该路由相关的组件内容
- 加载过大 => 图片压缩, 文件压缩合并处理, 开启gzip压缩等

比如:

1. 配置异步组件, 路由懒加载

   ```js
   const login = () => import('../pages/login.vue')
   ```

2. 图片压缩: 使用 webp 格式的图片, 提升首页加载的速度

3. CDN加速: 配置CDN加速, 加快资源的加载效率 (花钱)

4. 开启 gzip 压缩 (一般默认服务器开启的, 如果没开, 确实可能会很慢, 可以让后台开一下)

   ...	



博客: https://www.cnblogs.com/xidian-Jingbin/p/10643391.html

### 你在项目中遇到过什么技术难题

**问题: 考察解决问题的能力!**

话术: 前端要学的东西确实很多，但是并不夸张, 肯多花点时间沉淀一般都会有解决方案

一般遇到难题 (这些前端所谓的难题, 一般都是一些没有做过, 没有尝试过得一些业务),  我们要时刻保持独立思考，

**知道自己要做什么业务**，**由此决定要学什么知识**, 然后**实现业务**, 举一反三，总结归纳!

比如1: 如果之前没有做过国际化, 换肤, 没有做过支付, 权限控制,  没有做过即时通信websocket,  excel导入导出, 就会觉得很难, 

但其实真正上手花时间去学着做了, 也都能逐步思考解决相关页面, 这些其实也都还 ok

比如2: 有时候, `复杂的或者困难的`, 并不是技术层面的, 而是`业务需求方面`的, 需要进行大量树形结构的处理

展示列表式数据时,  展示图表数据时,  筛选条件关联条件多了,  组件与组件的联动关系的控制也比较麻烦, 

将联动的条件, 存vuex,  然后 => 进行分模块管理也是比较合适的选择 

### 说一下页面访问控制和权限管理你是怎么做的

### 如何封装组件的

编辑/添加，公告头部的封装，每个页面都会用到的面包屑...考虑过哪些技术点：传值和校验、插槽和作用域插槽、自定义事

### APP

Web APP、可以安装的应用程序（Android、IOS、Android/IOS 提供 Webview + 套（网页））、uni-app 可以把网页打包成可以安装的应用程序

### Git 工作流

<font color=e32d40>**Gitlab**</font> 公司内部私有部署的代码管理平台。

master => 打包上线

release => 测试分支

develop => 开发分支（普通开发者具有权限的分支）

功能分支 => 一般我在开发新功能的时候，会基于 develop 开一个自己的功能分支，在上面写代码，写完之后再合并到 develop

git stash 将本次修改缓存到本地；git stash apply 恢复最近缓存

### 这个项目接口请求是怎么做的/你对 axios 封装过哪些东西

首先我们会划分三个模块：`utils/request.js`、`api/*`、`组件.vue`

一般封装 axios 的时候会封装：首先创建一个 axios 实例、baseURL、timeout、请求拦截器（统一携带 Token、Token 过期时候的前端主动介入）、响应拦截器（成功的时候对数据进行脱壳、失败的时候统一错误提示、Token 过期处理）、transformRequest（表示允许在向服务器发送前，修改请求数据）、transformResponse（在传递给 then/catch 前，允许修改响应数据）

Token 过期时候的前端主动介入：登录成功存一个时间戳、请求拦截器中，用当前时间戳 - 登录成功时候的那个时间戳，如果大于超时时间了，就直接拦截到登录页。

transformRequest：

**作用：**表示允许在向服务器发送前，修改请求数据

**使用要求：**
1、只能用在 ‘PUT’, ‘POST’ 和 ‘PATCH’ 这几个请求方法
2、后面[数组](https://so.csdn.net/so/search?q=数组&spm=1001.2101.3001.7020)中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream

**用法：**

```js
transformRequest: [function (data, headers) {
    // 对 data 进行任意转换处理
    return data;
  }],
```

transformResponse：

**作用：**
在传递给 then/catch 前，允许修改响应数据

**用法：**

```js
transformResponse: [function (data) {
    // 对 data 进行任意转换处理
    return data;
  }],
```

### CDN

内容分发网络：公司花钱 => 七牛 CDN => 买空间 => 把自己的资源上传到此空间 => 得到 CDN

### 和 Vue 相关的性能优化的手段都考虑过哪些

- v-for 循环的时候加 key

- v-for 和 v-if 不要放一行（计算属性）

- v-if 和 v-show 区分使用场景

- 路由懒加载、组件动态加载

- KeepAlive

- computed 和 方法区分使用场景（优先 computed）

- ...

### Websocket

轮询或 Websocket

### 你们公司接口文档是怎么交付的

SwaggerUI：一套接口生成的集成方案，是后端生成接口文档的框架，一般后端会部署一个地址，提供给我。

### 开发项目的时候，有没有碰到过数据明明变了，但是视图没有变，这种情况？

- 什么情况？

Vue2 有 2 种情况修改数据不是响应式的：给对象不存在的 key 进行赋值；通过索引修改数组的内容；

```
const obj = {}
obj.age = 18
```

```
const arr = ['a', 'b', 'c']
arr[0] = 'd'
```

- 为什么？

给对象不存在的 key 进行赋值不是响应式的为什么？

由于 Vue2 是通过 Object.defineProperty 递归劫持的 data 里面的每一个【属性】，一上来就进行了递归劫持的操作，所以后续添加的属性当然就没有被劫持到！

通过索引修改数组的内容为什么不是响应式的？

性能！[issue](https://github.com/vuejs/vue/issues/8562)

- 怎么解决的？

```js
// const obj = {}
// obj.age = 18
// 解决
this.$set(this.obj, 'age', 19)
Vue.set(this.obj, 'age', 19)
```

```js
// const arr = ['a', 'b', 'c']
// arr[0] = 'd'
// 解决
this.$set(this.arr, 0, 888)
// 使用数组的变更方法
this.arr.splice(0, 1, 888)
```

- Vue3 呢？

Vue3 对数组通过索引修改就是响应式的，因为 Proxy 对数组的处理不存在性能问题！

Vue3 给对象不存在的 key 进行赋值也是响应式的啦，因为 Proxy 它劫持的直接就是整个对象（而不是一个个的属性），所以就无所谓你这个属性是不是后续添加的啦！

### 小程序和网页开发的差异

- 宿主环境不一样（网页=>浏览器，小程序=>微信软件）

- 开发方式不一样（微信开发者工具）

- 上线流程不一样

### 上传图片怎么做的

1. 准备一个 `<input type="file" hidden>` 并通过 hidden 属性隐藏

2. 准备一个按钮，给按钮绑定点击事件，在事件的回调里面主动触发 input:file 的 click 事件

3. 监听 input 的 onchange 事件，在回调里面通过 e.target.files 拿到文件信息

4. 创建 formData 对象，把文件信息放进去通过 axios 传到后端

```js
const form = new FormData()
form.append('avatar', e.target.files[0])
```

5. 图片预览：URL.createObjectURL（Blob） 或 FileReader（base64）

```html
<input type="file" hidden id="file" />
<img id="img" alt="" />
<button id="btn">click</button>
<script>
  btn.onclick = function () {
    file.click()
  }
  file.onchange = function (e) {
    const f = e.target.files[0]

    const formData = new FormData()
    formData.append('avatar', f)
    // axios({ url: '/xxx', data: formData })
    /* const s = URL.createObjectURL(f)
       img.src = s */
    const fileReader = new FileReader()
    // 图片 => base64
    fileReader.readAsDataURL(f)
    fileReader.onload = function () {
      img.src = this.result
    }
  }
</script>
```

### 后端接口还没有开发好 / mock数据

Mock: 模拟数据；拦截请求；

```js
// mock/index.js
Mock.mock('/api/users', 'get', (req, res) => {
  // 通过 req 拿到前端的信息
  // 根据此信息返回对应的数据（Mock 的数据）
  res.send({ mock 的数据 })
})
```

```js
// main.js
import './mock'
```

### 说一下权限管理怎么做的

#### 路由级别的权限

用户登录成功之后，后端返回当前用户的标识；`['/user', '/news']`

前端拿到标识之后筛选出【有权限的路由】；`[{path: '/user', component: User}, {path: '/news', component: News}, ]，#1`

然后做了 2 件事情！

第 1 件事情：通过 addRoutes/addRoute 把【有权限的路由】添加到路由实例；`router.addRoutes(#1)`，这样当前用户就具有了访问某个路由的权限啦；

第 2 件事情：把【有权限的路由】也添加到了 Vuex 一份，目的是为了给侧边栏或其他地方使用（通过 addRoutes 后续添加的路由，不能直接通过 router 获取到，官方推荐放到 Vuex 存储）；

#### 按钮级别的权限

封装一个全局的方法/指令，这个方法呢？只做一件事件，接收一个标识，内部进行判断，看一下这个标识这不在后端返回的功能列表里面，在就返回 true，不再就返回 false。

```js
function isFn(flag) {
  return ['a', 'b', 'c', 'DELETE'].includes(flag)
}
```

在需要做按钮权限控制的时候，调用这个方法，根据返回的是 true 还是 false，对这个按钮做禁用/启用或显示/隐藏的操作。

```html
<button v-if="isFn('DELETE')">删除</button>
```

### 深拷贝

1. JSON.stringify 的问题

```js
// ..........JSON.stringify 的确点............

// 1. 会忽略值为 undefined、函数、Symbol
// 2. 当值为 bigint 或循环引用的时候会报错
// 3. 日期会被转成字符串、正则会被转成空对象
// 4. ...
```

2. 三个点和 Object.assign 都是浅拷贝

```js
它们都是用来进行浅拷贝的，好的地方是能拷贝 undefined、函数、Symbol、正则...
```

3. 自己实现深拷贝：递归深拷贝

```js
// const copy = (target) => {
//   const type = Object.prototype.toString.call(target)
//   // 正则、日期
//   if (/(regexp|date)/i.test(type)) return new target.constructor(target)
//   // 错误对象
//   if (/error/i.test(type)) return new target.constructor(target.message)
//   // 函数
//   if (/function/i.test(type)) return new Function('return ' + target.toString())()
//   // null 和 简单数据类型
//   if (target === null || typeof target !== 'object') return target
//   // 数组和对象
//   /* const arr = []
//   const obj = {} */
//   const result = new target.constructor()
//   for (const attr in target) {
//     result[attr] = copy(target[attr])
//   }
//   return result
// }
```

4. 如何循环引用

```js
// const copy = (target, m = new Map()) => {
//   const type = Object.prototype.toString.call(target)
//   // 正则、日期
//   if (/(regexp|date)/i.test(type)) return new target.constructor(target)
//   // 错误对象
//   if (/error/i.test(type)) return new target.constructor(target.message)
//   // 函数
//   if (/function/i.test(type)) return new Function('return ' + target.toString())()
//   // null 和 简单数据类型
//   if (target === null || typeof target !== 'object') return target
//   // 数组和对象
//   /* const arr = []
//   const obj = {} */
//   // #2 m 里面存储了 target 就直接返回
//   // console.log(target, 233)

//   if (m.get(target)) return m.get(target)
//   const result = new target.constructor()
//   // #3
//   m.set(target, result)

//   for (const attr in target) {
//     // #4 传递 m
//     result[attr] = copy(target[attr], m)
//   }
//   return result
// };
```

5. 实际我怎么做的lodash

```js
const o = _.cloneDeep(obj1)
```

### 防抖和节流

```js
// 是什么？
// 防抖和节流都是性能优化的一种手段。
// 防抖：持续触发不执行，不触发的一段时间后才执行。
// 节流：持续触发也执行，只不过，执行的频率变低了。
// 实现一个？
// 匈牙利命名法的简版
// 类型 + 具体的含义
// const iNum = 8
// const bBar = false
// const aDiv = document.querySelctorAll('div')
// 把鼠标相对于盒子位置放到盒子里面
/*  oDiv.onmousemove = function (e) {
       let x = e.pageX - this.offsetLeft
       let t = e.pageY - this.offsetTop
       this.innerHTML = `x: ${x}, y: ${t}`
     }; */

// 防抖一下
/* let timer = null
    oDiv.onmousemove = function (e) {
      clearTimeout(timer)
      timer = setTimeout(() => {
        let x = e.pageX - this.offsetLeft
        let t = e.pageY - this.offsetTop
        this.innerHTML = `x: ${x}, y: ${t}`
      }, 200)
    }; */
// 封装一个防抖/节流函数？
/* const debounce = (callback, time) => {
      let timer = null
      return function (e) {
        clearTimeout(timer)
        timer = setTimeout(() => {
          callback.call(this, e) // window.callback(e)
        }, time)
      }
    } */

/* oDiv.onmousemove = _.debounce(function (e) {
      let x = e.pageX - this.offsetLeft
      let t = e.pageY - this.offsetTop
      this.innerHTML = `x: ${x}, y: ${t}`
    }, 200) */
// 生活中的例子？
// 王者荣耀英雄回城是防抖还是节流
// 打散弹枪，节流

// 应用场景？
// 根据输入的内容请求接口？防抖
// 获取窗口缩放的大小，滚动位置？节流

// 实际开发怎么做？ loadsh
oDiv.onmousemove = _.throttle(function (e) {
  let x = e.pageX - this.offsetLeft
  let t = e.pageY - this.offsetTop
  this.innerHTML = `x: ${x}, y: ${t}`
}, 1000)
```

### 原型链

定义：多个对象之间通过 `__proto__` 链接起来的这种关系就是原型链。

### Promise

`.catch() 之后还能再触发 then 吗？`

```js
const p = new Promise((resolve, reject) => {
  reject(new Error('233'))
})
p.catch((r) => {
  console.log(r)
  // return Promise.resolve(undefined)
}).then((r) => {
  console.log(r)
})
```

如何实现并发请求，按顺序拿到结果？

```js
Promise.all([p1, p2]).then((r) => {
  // r => [p1 的结果, p2 的结果]
})

// const p1 的结果 = await p1
// const p2 的结果 = await p2
```

### Vue2 双向数据绑定原理

```js
// 需求：双向数据绑定（数据变了，视图改变；视图改变，数据也变）

Object.defineProperty 进行劫持

const data = {
  name: 'ifer'
}

/* const tempData = { ...data }
    Object.defineProperty(data, 'name', {
      get() {
        // 获取 name 的时候会走这儿
        return tempData.name
      },
      set(newValue) {
        // 设置 name 的时候会走这儿
        tempData.name = newValue
      }
    })

    // console.log(data.name) // 'ifer'
    data.name = 'elser'
    console.log(data.name) */

/* const tempData = { ...data }
    Object.defineProperty(data, 'name', {
      get() {
        // 获取 name 的时候会走这儿
        return tempData.name
      },
      set(newValue) {
        // model => view => Data bindings
        // #2 设置 name 的时候会走这儿
        tempData.name = newValue
        oP.innerHTML = newValue
        oInput.value = newValue
      }
    })

    // view => model => DOM Listeners
    oInput.oninput = function (e) {
      // #1
      data.name = e.target.value
    } */

/* oInput.oninput = function (e) {
      oP.innerHTML = e.target.value
    } */
```

Vue3

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>

  <body>
    <p id="oP"></p>
    <input id="oInput" type="text" />
    <script>
      // 需求：双向数据绑定（数据变了，视图改变；视图改变，数据也变）

      const data = {
        name: 'ifer',
        address: '北京'
      }

      /* const tempData = { ...data }
    Object.keys(data).forEach(key => {
      Object.defineProperty(data, key, {
        get() {
          return tempData[key]
        },
        set(newValue) {
          tempData[key] = newValue
          oP.innerHTML = newValue
          oInput.value = newValue
        }
      })
    })
    oInput.oninput = function (e) {
      data.address = e.target.value
    } */

      // 上面 Vue2 的问题：如果 data 里面有 100 个属性，那可不是要循环 100 次吗？

      // p 就是一个代理，我对 p 的任何操作都会影响到 data
      const p = new Proxy(data, {
        get(target, attr) {
          // 获取的时候触发
          // console.log(target, attr)
          // target => data
          // attr => 属性
          return target[attr]
        },
        set(target, attr, newValue) {
          target[attr] = newValue
          oP.innerHTML = newValue
          oInput.value = newValue
        }
      })
      // p.name = 'xxx'
      // console.log(data.name);

      /* p.name = 'xxx'
    console.log(p.name) */

      oInput.oninput = function (e) {
        // p.address = e.target.value
        p.test = e.target.value
      }
    </script>
  </body>
</html>
```

### 插件

```js
Vue.use({
  install(Vue) {
    // 干了哪些事情
    Vue.mixin()
    Vue.component()
    Vue.directive()
    Vue.prototype.bus = new Vue()
  }
})
Vue.use(function (Vue) {})
```

### 难点

#### 路由的缓存问题。

点击 用户 1 按钮 和 用户 2 按钮 共用了同一个路由组件 User，我在 User 里面根据 userId 发请求的时候，发现永远是第一次发起的那个请求，好奇怪，当时找不到原因。

template 里面获取数据是实时更新的，但是 created 拿不到最新的数据，后来发现原因是公用了同一个组件，而 created 这个钩子也只会在组件创建完毕执行一次，所以 ...

解决方式 1

```html
<template>
  <div>User {{ $route.params.id }}</div>
</template>

<script>
  export default {
    name: 'User',
    created() {
      console.log(this.$route.params.id)
    },
    watch: {
      $route(newRoute) {
        console.log(newRoute.params.id)
      }
    }
  }
</script>
```

解决方式 2  :key="$route.fullPath"

```html
<router-view :key="$route.fullPath"></router-view>
```

#### 大数字问题。

根据文章 ID 请求文章详情的时候，有的时候正常，有的时候会出现 404，找不到详情，反复检查了传参和接口都没有问题，百思不得其解...

原因，后端给我返回的文章列表，当文章 ID 包含大数字的时候出事了。

`{"name":"xxx", "age": 18}`

本质上来说，后端返回的数据都是 JSON 格式的字符串，那么前端使用为什么可以直接当做对象去用呢？

就是因为 axios 帮我们进行了内部处理，它为了方便我们前端使用，内部进行了 JSON.parse 的操作转成了对象。

但是！！！当 JSON 格式的字符串里面包含了大数字的时候，JSON.parse 就搞不定了（转换出来的结果不对）

所以也就是当后端返回的 JSON 格式的字符串里面包含大数字的时候，axios 进行内部 JSON.parse 的时候，把那个大数字（文章 ID）转换成了另外一个结果，所以 404...

```json
JSON.parse('{ "ID": 9007199254740999 }')
```

怎么解决？2 种方法。

找后端，那个 ID 不要用数字表示，用字符串表示文章 ID。

```json
JSON.parse('{ "ID": "90071992547409998888888888888888" }')
```

自己搞定

```json
import jsonBigInt from 'json-bigint'
// transformResponse
axios.create({
  transformResponse(data) {
    data => JSON 格式的字符串
    // 默认
    // return JSON.parse(data)
    // 内部用一种算法，如果是大数字转出来的是一个对象，这个对象里面的信息经过运算可以得到大数字
    return jsonBigInt.parse(data)
  }
})
```

json-bigint 会把超出 JS 安全整数范围的数字转为一个 BigNumber 类型的对象，对象数据是它内部的一个算法处理之后的，我们要做的就是在使用的时候转为字符串来使用。

通过 Axios 请求得到的数据都是 Axios 处理（JSON.parse）之后的，我们应该在 Axios 执行处理之前手动使用 json-bigint 来解析处理。Axios 提供了自定义处理原始后端返回数据的 API：`transformResponse` 。

#### 长列表优化

（1）懒渲染

1 懒渲染概念
就是常见的无线滚动，每次只渲染一部分（比如10条），等剩余部分滚到可见区域，再渲染一部分。

2 原理
用数组保存所有的数据，根据一屏幕能渲染的数量大致算出一次性渲染的数量，比如10，然后将数据源数组10个分为一组生产一个二维数组。列表后面跟着一个dom，监听滚动事件，当这个dom滚动到可视区域时，取出二维数组中数据来渲染。

3 参考实践
根据一屏幕数量分割源数组，splitArray方法。
记录渲染了几组数据 groupIdx，默认0
记录已经渲染的数据 componentList
添加滚动事件
在滚动事件中，判断列表后面的dom是否进入可视区域。

（2）可视区渲染

1 可视区渲染概念

只渲染可见部分，不可见部分不渲染。

2 虚拟列表概念
虚拟列表（Virtual List），是一种长列表优化方案，是可视区渲染列表。其两个重要的概念：

可滚动区域：假设有1000条数据，每个列表项的高度是30，那么可滚动的区域的高度就是1000*30。当用户改变列表的滚动条的当前滚动值的时候，会造成可见区域的内容的变更。
可见区域：比如列表的高度是300，右侧有纵向滚动条可以滚动，那么视觉可见的区域就是可见区域。

3 虚拟列表原理：

用数组保存所有列表元素的位置，只渲染可视区内的列表元素，当可视区滚动时，根据滚动的offset大小以及所有列表元素的位置，计算在可视区应该渲染哪些元素。

4 参考实践

实现虚拟列表就是处理滚动条滚动后的可见区域的变更，具体实现步骤如下

计算当前可见区域起始数据的startIndex
计算当前可见区域结束数据的endIndex
计算当前可见区域的数据，并渲染到页面中
计算startIndex对应的数据在整个列表中的偏移位置startOffset，并设置到列表上
做了一个设定：每个列表项的高度都是30px。在这个约定下，核心JavaScript代码不超过10行，但是可以完整的实现可见区域的渲染和更新。

HTML、CSS如何实现，添加了这么几个样式：列表元素（.list-view）使用相对定位
使用一个不可见元素（.list-view-phantom）撑起这个列表，让列表的滚动条出现
列表的可见元素（.list-view-content）使用绝对定位，left、right、top设置为0

（3）vue-virtual-scroll-list

如果使用vue开发，建议使用 vue-virtual-scroll-list，功能原理都是使用虚拟列表来优化长列表渲染。

 当然也可以参照上面代码示例自己实现懒加载或者虚拟列表来优化长列表。另外也可以使用textarea来优化长列表，将首屏意外的数据放在textarea标签内部，滚动过程中取出渲染，写法类似懒渲染。

#### 上传图片的时候不会触发，解决：oFile.value = ''

#### 路由跳转，created 或 mounted 里面发请求不会触发（路由缓存问题），解决：watch $route

#### 大数字问题，告诉后端改成字符串，或者用 axios 中的 API transformResponse 里面配合 json-bigint 进行处理。

#### 滚动条问题，解决：overflow-y：auto，让每一个容器产生自己的滚动条。

### 界面访问控制

在全局前置路由导航守卫去做的；

如果有 token 就 next 放行，没有 token，如果访问的页面在白名单，同样 next 放行，否则拦截到登录页。

```
router.beforeEach((to, from, next) => {
  if (store.state.token) {
    next()
  } else {
    if ([白名单数组].includes(to.path)) {
      next()
    } else {
      router.push('/login')
    }
  }
})
```

### Token 过期怎么办 / 无感刷新

一般在响应拦截器根据后端返回的 401 进行处理（清除用户信息并跳转到登录页）。

出于安全性的考虑，token 的有效期一般是后端规定的 2 个小时，倘若用户在此网站停留的时间很久，那岂不是每个两个小时都要重新登录一下吗？（用户体验不好）

token

refresh_token: 当 token 过期触发 401 的时候，此时可以用 refresh_token 来获取到新的 token，覆盖旧的 token，然后再把失败的请求重新发出去！

**什么是 Refresh_Token**

AccessToken 和 IdToken 是 JSON Web Token (opens new window)，有效时间通常较短。通常用户在获取资源的时候需要携带 AccessToken，当 AccessToken 过期后，用户需要获取一个新的 AccessToken。
`Refresh Token `用于获取新的 AccessToken。这样可以缩短 AccessToken 的过期时间保证安全，同时又不会因为频繁过期重新要求用户登录。

用户在初次认证时，Refresh Token 会和 AccessToken、IdToken 一起返回。你的应用必须安全地存储 Refresh Token，它的重要性和密码是一样的，因为 Refresh Token 能够一直让用户保持登录。

### Polyfill

```js
// const arr = ['a', 'b', 'c']
    /* const o = { age: 18 }
    arr.forEach(function (item, index, originArr) {
      console.log(item, index, originArr, this)
    }, o); */
    // Array.prototype.forEach = Array.prototype.forEach || function () { }

    /* Array.prototype.forEach2 = function (callback, _this = window) {
      // this => arr
      for (let i = 0; i < this.length; i++) {
        callback.call(_this, this[i], i, this)
      }
    }
    const o = { age: 18 }
    arr.forEach2(function (item, index, originArr) {
      console.log(item, index, originArr, this)
    }, o); */
    // forEach => 如何退出 => 抛错


    /* const arr = ['a', 'b', 'c']
    Array.prototype.map2 = function (callback) {
      const newArr = []
      for (let i = 0; i < this.length; i++) {
        newArr.push(callback(this[i], i, this))
      }
      return newArr
    }
    console.log(arr.map2((item, index, originArr) => '~' + item + '~')) */

    /* const arr = [7, 9, 5, 1, 11, 19];
    Array.prototype.sort2 = function (callback) {
      // 把【排序】好的结果返回出去
      for (let i = 0; i < this.length - 1; i++) {
        for (let j = 0; j < this.length - i - 1; j++) {
          if (callback(this[j], this[j + 1]) > 0) {
            ;[this[j], this[j + 1]] = [this[j + 1], this[j]]
          }
        }
      }
      return this
    }
    console.log(arr.sort2((n1, n2) => n1 - n2)) */

    /* let num1 = 8
    let num2 = 9
      ;[num1, num2] = [num2, num1]
    console.log(num1, num2) */

    const arr = [7, 9, 5, 1, 11, 19];
    Array.prototype.filter = function (callback) {
      const newArr = []
      for (let i = 0; i < this.length; i++) {
        if (callback(this[i])) {
          newArr.push(this[i])
        }
      }
      return newArr
    }
    console.log(arr.filter(item => item > 9))
```

### 事件循环/EventLoop/事件环/JS 的执行机制

JS 代码的执行分为同步代码/任务和异步代码/任务；

当碰到同步代码时，直接在执行栈种执行；

当碰到异步代码并且时机符合时（例如定时器的时间到了）就把异步代码添加到任务队列当中；

**当执行栈中的同步代码执行完毕后**；

就去任务队列当中把异步代码拿到执行栈中进行执行；

这种反复轮询任务队列并把代码放到执行栈种执行的操作就是 EventLoop。

```
// 问题：波浪线 一定一定是在 1s 到了马上打印吗？
setTimeout(function() {
    console.log('~~~')
}, 1000);
// ...
// while(true) {}
```



```
// Vue 中父子组件嵌套的情况下生命周期顺序是怎么样
// 初始化
// 父 beforeCreate、父 created、父 beforeMount、子 beforeCreate、子 created、子 beforeMount、子 Mounted、父 mounted
// 更新父
// 父 beforeUpdate、子 beforeUpdate、子 updated、父 updated
```















































