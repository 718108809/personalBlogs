<!DOCTYPE html>
<html lang="zh-CN" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>小江的网站 | 小江的网站</title>
    <meta name="description" content="个人博客网">
    <link rel="preload stylesheet" href="/personalBlogs/assets/style.a9bd9622.css" as="style">
    <script type="module" src="/personalBlogs/assets/app.98eb18df.js"></script>
    <link rel="preload" href="/personalBlogs/assets/inter-roman-latin.2ed14f66.woff2" as="font" type="font/woff2" crossorigin="">
  <link rel="modulepreload" href="/personalBlogs/assets/chunks/framework.255dec5c.js">
  <link rel="modulepreload" href="/personalBlogs/assets/chunks/theme.0f95c3ee.js">
  <link rel="modulepreload" href="/personalBlogs/assets/blogs_JavaScript Class类详解.md.5b5afbc3.lean.js">
  <link rel="icon" href="logo.png">
  <script id="check-dark-light">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-b2cf3e0b><!--[--><!--]--><!--[--><span tabindex="-1" data-v-c8616af1></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-c8616af1> Skip to content </a><!--]--><!----><header class="VPNav" data-v-b2cf3e0b data-v-7e5bc4a5><div class="VPNavBar has-sidebar" data-v-7e5bc4a5 data-v-1d30fa41><div class="container" data-v-1d30fa41><div class="title" data-v-1d30fa41><div class="VPNavBarTitle has-sidebar" data-v-1d30fa41 data-v-f4ef19a3><a class="title" href="/personalBlogs/" data-v-f4ef19a3><!--[--><!--]--><!--[--><img class="VPImage logo" src="/personalBlogs/logo.png" alt data-v-6db2186b><!--]--><!--[-->小江的网站<!--]--><!--[--><!--]--></a></div></div><div class="content" data-v-1d30fa41><div class="curtain" data-v-1d30fa41></div><div class="content-body" data-v-1d30fa41><!--[--><!--]--><!----><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-1d30fa41 data-v-7f418b0f><span id="main-nav-aria-label" class="visually-hidden" data-v-7f418b0f>Main Navigation</span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/personalBlogs/blogs/" tabindex="0" data-v-7f418b0f data-v-37adc828 data-v-8f4dc553><!--[-->我的博客<!--]--><!----></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-1d30fa41 data-v-f6a63727><label title="toggle dark mode" data-v-f6a63727 data-v-a9c8afb8><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" aria-checked="false" data-v-a9c8afb8 data-v-f3c41672><span class="check" data-v-f3c41672><span class="icon" data-v-f3c41672><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-a9c8afb8><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-a9c8afb8><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></label></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-1d30fa41 data-v-0394ad82 data-v-f6988cfb><!--[--><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-1d30fa41 data-v-40855f84 data-v-764effdf><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-764effdf><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-764effdf><circle cx="12" cy="12" r="2"></circle><circle cx="19" cy="12" r="2"></circle><circle cx="5" cy="12" r="2"></circle></svg></button><div class="menu" data-v-764effdf><div class="VPMenu" data-v-764effdf data-v-e7ea1737><!----><!--[--><!--[--><!----><div class="group" data-v-40855f84><div class="item appearance" data-v-40855f84><p class="label" data-v-40855f84>Appearance</p><div class="appearance-action" data-v-40855f84><label title="toggle dark mode" data-v-40855f84 data-v-a9c8afb8><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" aria-checked="false" data-v-a9c8afb8 data-v-f3c41672><span class="check" data-v-f3c41672><span class="icon" data-v-f3c41672><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-a9c8afb8><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-a9c8afb8><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></label></div></div></div><div class="group" data-v-40855f84><div class="item social-links" data-v-40855f84><div class="VPSocialLinks social-links-list" data-v-40855f84 data-v-f6988cfb><!--[--><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-1d30fa41 data-v-e5dd9c1c><span class="container" data-v-e5dd9c1c><span class="top" data-v-e5dd9c1c></span><span class="middle" data-v-e5dd9c1c></span><span class="bottom" data-v-e5dd9c1c></span></span></button></div></div></div></div><!----></header><div class="VPLocalNav" data-v-b2cf3e0b data-v-f5a2ca58><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-f5a2ca58><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="menu-icon" data-v-f5a2ca58><path d="M17,11H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h14c0.6,0,1,0.4,1,1S17.6,11,17,11z"></path><path d="M21,7H3C2.4,7,2,6.6,2,6s0.4-1,1-1h18c0.6,0,1,0.4,1,1S21.6,7,21,7z"></path><path d="M21,15H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h18c0.6,0,1,0.4,1,1S21.6,15,21,15z"></path><path d="M17,19H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h14c0.6,0,1,0.4,1,1S17.6,19,17,19z"></path></svg><span class="menu-text" data-v-f5a2ca58>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-f5a2ca58 data-v-079b16a8><button data-v-079b16a8>Return to top</button><!----></div></div><aside class="VPSidebar" data-v-b2cf3e0b data-v-139a1f1d><div class="curtain" data-v-139a1f1d></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-139a1f1d><span class="visually-hidden" id="sidebar-aria-label" data-v-139a1f1d> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="group" data-v-139a1f1d><section class="VPSidebarItem level-0 has-active" data-v-139a1f1d data-v-c4656e6d><div class="item" role="button" tabindex="0" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><h2 class="text" data-v-c4656e6d>博客目录</h2><!----></div><div class="items" data-v-c4656e6d><!--[--><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/personalBlogs/blogs/" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>概述</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/personalBlogs/blogs/%E9%80%92%E5%BD%92%E6%9F%A5%E8%AF%A2name.html" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>递归查询name</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/personalBlogs/blogs/%E6%9F%A5%E8%AF%A2%E5%9C%BA%E6%99%AF%E4%B8%AD%E6%A8%A1%E5%9E%8B%E6%95%B0%E6%8D%AE.html" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>查询场景中模型数据</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/personalBlogs/blogs/%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A8%A1%E5%9E%8B%E8%A7%86%E8%A7%92.html" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>初始化模型视角</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/personalBlogs/blogs/%E6%A8%A1%E5%9E%8B%E7%82%B9%E5%87%BB%E9%AB%98%E4%BA%AE%E6%95%88%E6%9E%9C.html" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>模型点击高亮效果</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/personalBlogs/blogs/%E6%A8%A1%E5%9E%8B%E5%AE%9A%E4%BD%8D%E8%81%9A%E7%84%A6.html" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>模型定位聚焦</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/personalBlogs/blogs/%E9%80%9A%E8%BF%87%E4%BC%A0%E5%85%A5%E5%8F%82%E6%95%B0%E7%94%9F%E6%88%90%E7%9B%B4%E7%BA%BF+%E6%9B%B2%E7%BA%BF%E7%9A%84%E8%B7%AF%E5%BE%84.html" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>通过传入参数生成直线</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/personalBlogs/blogs/%E9%80%9A%E8%BF%87three.path%E7%94%9F%E6%88%90%E6%B5%81%E5%8A%A8%E7%9A%84%E7%AE%AD%E5%A4%B4%E5%AE%9E%E7%8E%B0%E5%85%89%E8%B7%AF%E6%95%88%E6%9E%9C.html" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>通过three.path生成流动的箭头实现光路效果</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/personalBlogs/blogs/%E5%BC%82%E6%AD%A5%E5%B9%B6%E5%8F%91%E7%94%9F%E6%88%90%E6%A0%87%E7%AD%BE.html" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>异步并发生成标签</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/personalBlogs/blogs/git%E5%8D%8F%E5%90%8C%E5%BC%80%E5%8F%91.html" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>git协同开发</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/personalBlogs/blogs/Map%E5%AF%B9%E8%B1%A1%E8%AF%A6%E8%A7%A3.html" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>Map对象详解</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/personalBlogs/blogs/Vue%E4%B8%AD%E7%9A%84v-slot%E8%AF%A6%E8%A7%A3%EF%BC%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD%E5%92%8C%E5%85%B7%E5%90%8D%E6%8F%92%E6%A7%BD.html" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>Vue中的v-slot详解，作用域插槽和具名插槽</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/personalBlogs/blogs/NProgress%E6%98%AF%E4%BB%80%E4%B9%88.html" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>NProgress是什么</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/personalBlogs/blogs/Vue%E7%BB%84%E4%BB%B6%E4%B8%ADname%E7%9A%84%E4%B8%89%E5%A4%A7%E4%BD%9C%E7%94%A8.html" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>Vue组件中name的三大作用</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/personalBlogs/blogs/%E4%BD%BF%E7%94%A8%20vue-router%EF%BC%8C%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%AE%8C%E6%88%90%E5%90%8E%EF%BC%8C$route%20%E7%9A%84%E5%80%BC%E4%B8%8D%E6%AD%A3%E7%A1%AE.html" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>使用 vue-router，页面加载完成后，$route 的值不正确</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/personalBlogs/blogs/new%20Set()%E7%9A%84%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95(ES6).html" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>new Set()的基础用法(ES6)</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/personalBlogs/blogs/JS%E4%B8%ADreduce%E7%9A%84%E7%94%A8%E6%B3%95.html" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>JS中reduce的用法</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/personalBlogs/blogs/Promise.all.html" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>Promise.all</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link is-active has-active" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/personalBlogs/blogs/JavaScript%20Class%E7%B1%BB%E8%AF%A6%E8%A7%A3.html" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>JavaScript Class类详解</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/personalBlogs/blogs/%E6%9C%89%E4%BA%86for%E5%BE%AA%E7%8E%AF%20%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81forEach%EF%BC%9F.html" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>有了for循环 为什么还要forEach？</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/personalBlogs/blogs/tween.js%20%E4%B8%AD%E6%96%87%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>tween.js 中文使用指南</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/personalBlogs/blogs/%E5%A4%A7%E5%B1%8F%E9%80%82%E9%85%8D%E6%96%B9%E6%A1%88%E6%B1%87%E6%80%BB.html" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>大屏适配方案汇总</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/personalBlogs/blogs/%E5%88%9B%E5%BB%BA%E6%96%87%E6%9C%AC%E6%A0%87%E7%AD%BE.html" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>创建文本标签</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/personalBlogs/blogs/%E5%B0%81%E8%A3%85websocket%E6%96%B9%E6%B3%95.html" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>封装websocket方法</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/personalBlogs/blogs/%E5%89%8D%E7%AB%AF%E5%BC%82%E6%AD%A5(async)%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88(%E6%89%80%E6%9C%89%E6%96%B9%E6%A1%88).html" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>前端异步(async)解决方案(所有方案)</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/personalBlogs/blogs/%E5%85%B3%E4%BA%8Ethree.js%E6%B8%B2%E6%9F%93%E5%99%A8THREE.WebGLRenderer()%E5%8F%82%E6%95%B0%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8.html" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>关于three.js渲染器THREE.WebGLRenderer()参数的介绍和使用</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/personalBlogs/blogs/threejs%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E5%85%A8%E6%99%AF%E7%9C%8B%E6%88%BFdemo%F0%9F%98%9C.html" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>threejs实现简单全景看房demo😜</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-c4656e6d data-v-c4656e6d><div class="item" data-v-c4656e6d><div class="indicator" data-v-c4656e6d></div><a class="VPLink link link" href="/personalBlogs/blogs/more.html" data-v-c4656e6d data-v-8f4dc553><!--[--><p class="text" data-v-c4656e6d>更多</p><!--]--><!----></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-b2cf3e0b data-v-a494bd1d><div class="VPDoc has-sidebar has-aside" data-v-a494bd1d data-v-c4b0d3cf><!--[--><!--]--><div class="container" data-v-c4b0d3cf><div class="aside" data-v-c4b0d3cf><div class="aside-curtain" data-v-c4b0d3cf></div><div class="aside-container" data-v-c4b0d3cf><div class="aside-content" data-v-c4b0d3cf><div class="VPDocAside" data-v-c4b0d3cf data-v-3f215769><!--[--><!--]--><!--[--><!--]--><div class="VPDocAsideOutline" data-v-3f215769 data-v-ff0f39c8><div class="content" data-v-ff0f39c8><div class="outline-marker" data-v-ff0f39c8></div><div class="outline-title" data-v-ff0f39c8>章节导航</div><nav aria-labelledby="doc-outline-aria-label" data-v-ff0f39c8><span class="visually-hidden" id="doc-outline-aria-label" data-v-ff0f39c8> Table of Contents for current page </span><ul class="root" data-v-ff0f39c8 data-v-8f12e865><!--[--><!--]--></ul></nav></div></div><!--[--><!--]--><div class="spacer" data-v-3f215769></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-c4b0d3cf><div class="content-container" data-v-c4b0d3cf><!--[--><!--]--><!----><main class="main" data-v-c4b0d3cf><div style="position:relative;" class="vp-doc _personalBlogs_blogs_JavaScript%20Class%E7%B1%BB%E8%AF%A6%E8%A7%A3" data-v-c4b0d3cf><div><blockquote><p>ECMAScript 6 提供了更接近传统语言的写法，新引入的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="noreferrer">class</a>关键字具有正式定义类的能力。类（class）是ECMAScript中新的基础性语法糖结构，虽然ECMAScript 6类表面上看起来可以支持正式的面向对象编程，但实际上它背后使用的仍然是原型和构造函数的概念，让对象原型的写法更加清晰、更像面向对象编程的语法。</p></blockquote><h2 id="一、类的定义" tabindex="-1">一、类的定义 <a class="header-anchor" href="#一、类的定义" aria-label="Permalink to &quot;一、类的定义&quot;">​</a></h2><p>定义类也有两种主要方式：类声明和类表达式。这两种方式都使用class关键字加大括号：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">// 类声明</span></span>
<span class="line"><span style="color:#A6ACCD;">class Person {}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// 类表达式</span></span>
<span class="line"><span style="color:#A6ACCD;">const TestPerson = class {}</span></span></code></pre></div><p>注意：<strong>函数声明</strong>和<strong>类声明</strong>之间的一个重要区别在于，函数声明会<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Hoisting" target="_blank" rel="noreferrer">提升</a>，类声明不会。需要先声明类，然后再访问它，否则就会出现<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError" target="_blank" rel="noreferrer">ReferenceError</a>，如：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">const test = new Person(); // ReferenceError: Person is not defined</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">class Person {}</span></span></code></pre></div><p>另一个跟函数声明不同的地方是，函数受函数作用域限制，而类受<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Block/Scripting" target="_blank" rel="noreferrer">块作用域</a>限制：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    function FunctionDeclaration () {}</span></span>
<span class="line"><span style="color:#A6ACCD;">    class ClassDeclaration {}</span></span>
<span class="line"><span style="color:#A6ACCD;">    // 使用var 声明</span></span>
<span class="line"><span style="color:#A6ACCD;">    var VarClass = class {}</span></span>
<span class="line"><span style="color:#A6ACCD;">    // 使用let/const 声明</span></span>
<span class="line"><span style="color:#A6ACCD;">    let LetClass = class {}</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(FunctionDeclaration) // FunctionDeclaration () {}</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(ClassDeclaration) // ReferenceError: ClassDeclaration is not defined</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(VarClass) // class {}</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(LetClass) // ReferenceError: letClass is not defined</span></span></code></pre></div><p>class 类完全可以看成构造函数的另一种写法，这种写法可以让对象的原型属性和函数更加清晰。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">class Person {}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(typeof Person) // function</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(Person === Person.prototype.constructor) // true</span></span></code></pre></div><p>上面代码表明，类的数据类型就是函数，类本身就指向构造函数。</p><h2 id="二、类构造函数" tabindex="-1">二、类构造函数 <a class="header-anchor" href="#二、类构造函数" aria-label="Permalink to &quot;二、类构造函数&quot;">​</a></h2><p>constructor 方法是一个特殊的方法，这种方法用于创建和初始化一个由 <code>class</code>创建的对象。通过 new 关键字生成对象实例时，自动会调用该方法。一个类只能拥有一个名为constructor构造函数，不能出现多个，如果定义了多个constructor构造函数，则将抛出 一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError" target="_blank" rel="noreferrer">SyntaxError</a>错误。如果没有定义constructor构造函数，class 会默认添加一个空的constructor构造函数。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">class Person {}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// 等于</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">class Person {</span></span>
<span class="line"><span style="color:#A6ACCD;">    constructor () {}</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span></code></pre></div><p>使用new操作符实例化Person的操作等于使用new调用其构造函数。唯一可感知的不同之处就是，JavaScript解释器知道使用new和类意味着应该使用constructor函数进行实例化。</p><p>类必须使用 <code>new</code>调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用 <code>new</code>也可以执行。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">class Person {}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">Person() // TypeError: Class constructor Test1 cannot be invoked without &#39;new&#39;</span></span></code></pre></div><p>使用new调用类的构造函数会执行如下操作。</p><ol><li>在内存中创建一个新对象；</li><li>这个新对象内部的[[Prototype]]指针被赋值为构造函数的prototype属性；</li><li>构造函数内部的this被赋值为这个新对象（即this指向新对象）；</li><li>执行构造函数内部的代码（给新对象添加属性）；</li><li>如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象；</li></ol><p>一起来看看下面例子：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">class Person {}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">class Test1 {</span></span>
<span class="line"><span style="color:#A6ACCD;">    constructor () {</span></span>
<span class="line"><span style="color:#A6ACCD;">        console.log(&#39;Test1 初始化&#39;)</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">class Test2 {</span></span>
<span class="line"><span style="color:#A6ACCD;">    constructor () {</span></span>
<span class="line"><span style="color:#A6ACCD;">        this.test = &#39;通过初始化构造函数设置值&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// 构造函数返回指定对象</span></span>
<span class="line"><span style="color:#A6ACCD;">const dataObj = { n: &#39;自定义实例对象&#39; }</span></span>
<span class="line"><span style="color:#A6ACCD;">class Test3 {</span></span>
<span class="line"><span style="color:#A6ACCD;">    constructor () {</span></span>
<span class="line"><span style="color:#A6ACCD;">        this.test = &#39;通过初始化构造函数设置值&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">        return dataObj</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">const a = new Person();</span></span>
<span class="line"><span style="color:#A6ACCD;">const b = new Test1(); // Test1 初始化</span></span>
<span class="line"><span style="color:#A6ACCD;">const c = new Test2();</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(c.test) // 通过初始化构造函数设置值</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">const d = new Test3();</span></span>
<span class="line"><span style="color:#A6ACCD;">d instanceof Test3; // false</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(d) // { n: &#39;自定义实例对象&#39; }</span></span></code></pre></div><p>类实例化时传入的参数会用作构造函数的参数。如果不需要参数，则类名后面的括号也是可选的：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">class Person {</span></span>
<span class="line"><span style="color:#A6ACCD;">    constructor (...args) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        console.log(args.length)</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">class Test1 {</span></span>
<span class="line"><span style="color:#A6ACCD;">    constructor (test) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        console.log(arguments.length)</span></span>
<span class="line"><span style="color:#A6ACCD;">        this.test = test || &#39;默认值&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// 不传值 可以省略()</span></span>
<span class="line"><span style="color:#A6ACCD;">const a = new Person // 0</span></span>
<span class="line"><span style="color:#A6ACCD;">const b = new Person(&#39;1&#39;, &#39;2&#39;) // 2</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">const c = new Test1() // 0</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(c.test) // 默认值</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">const d = new Test1(&#39;传入值&#39;) // 1</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(d.test) // 传入值</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">const d = new Test1(&#39;1&#39;, &#39;2&#39;, &#39;3&#39;) // 3</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(d.test) // 1</span></span></code></pre></div><p>与立即调用函数表达式相似，类也可以立即实例化：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">const a = new class Person {</span></span>
<span class="line"><span style="color:#A6ACCD;">    constructor (text) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        this.text = text</span></span>
<span class="line"><span style="color:#A6ACCD;">        console.log(text)</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">}(&#39;立即实例化类&#39;);</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// 立即实例化类</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(a); // Person</span></span></code></pre></div><h2 id="三、类的实例-、原型及类成员" tabindex="-1">三、类的实例 、原型及类成员 <a class="header-anchor" href="#三、类的实例-、原型及类成员" aria-label="Permalink to &quot;三、类的实例 、原型及类成员&quot;">​</a></h2><p>类的语法可以非常方便地定义应该存在于实例上的成员、应该存在于原型上的成员，以及应该存在于类本身的成员。</p><p>实例的属性除非显式定义在其本身（即定义在 <code>this</code>对象上），否则都是定义在原型上。</p><p>每个实例都对应一个唯一的成员对象，这意味着所有成员都不会在原型上共享:</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">class Person {</span></span>
<span class="line"><span style="color:#A6ACCD;">    constructor (x, y) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        this.text = new Number(1);</span></span>
<span class="line"><span style="color:#A6ACCD;">        this.x = x</span></span>
<span class="line"><span style="color:#A6ACCD;">        this.y = y</span></span>
<span class="line"><span style="color:#A6ACCD;">        this.getText = () =&gt; {console.log(this.text)}</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">    toString () {</span></span>
<span class="line"><span style="color:#A6ACCD;">        console.log(`${this.x}, ${this.y}`)</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">const test1 = new Person(&#39;x&#39;, &#39;y&#39;), test2 = new Person(&#39;x2&#39;, &#39;y2&#39;);</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(test1.getText()) // Number {1}</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(test2.getText()) // Number {1}</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(test1.x, test1.y) // x  y</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(test2.x, test2.y) // x2  y2</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// console.log(test1.text === test2.text)  // false</span></span>
<span class="line"><span style="color:#A6ACCD;">// console.log(test1.getText === test2.getText)  // false</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">test1.text = &#39;测试&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(test1.getText()) // 测试</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(test2.getText()) // Number {1}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">test1.toString() // x, y</span></span>
<span class="line"><span style="color:#A6ACCD;">test2.toString() // x2, y2</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">test1.hasOwnProperty(&#39;x&#39;); // true</span></span>
<span class="line"><span style="color:#A6ACCD;">test1.hasOwnProperty(&#39;y&#39;); // true</span></span>
<span class="line"><span style="color:#A6ACCD;">test1.hasOwnProperty(&#39;getText&#39;); // true</span></span>
<span class="line"><span style="color:#A6ACCD;">test1.hasOwnProperty(&#39;toString&#39;); // false</span></span>
<span class="line"><span style="color:#A6ACCD;">test1.__proto__.hasOwnProperty(&#39;toString&#39;); // true</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// 类的实例共享同一个原型对象</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(test1.__proto__ === test2.__proto__) // true</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// 也可以使用ES6提供的 Object.getPrototypeOf 来获取prototype </span></span>
<span class="line"><span style="color:#A6ACCD;">const test1Prototype = Object.getPrototypeOf(test1)</span></span>
<span class="line"><span style="color:#A6ACCD;">test1Prototype.myName = &#39;共享字段&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// test2 中也是能获取到</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(test2.myName) // 共享字段</span></span></code></pre></div><p>x、y、text和getText都是实例对象test1自身的属性，所以hasOwnProperty()方法返回true，而toString()是原型对象的属性（因为定义在Person类），所以hasOwnProperty()方法返回false，这些都与 ES5 的行为保持一致。</p><p>类的所有实例共享同一个原型对象。这也意味着，可以通过实例的 <code>__proto__</code>属性或Object.getPrototypeOf方法获取原型为“类”添加方法，这将会出现共享情况，必须相当谨慎，不推荐使用，因为这会改变“类”的原始定义，影响到所有实例。</p><p>类方法等同于对象属性，因此可以使用字符串、符号或计算的值作为键：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">const symbolKey = Symbol(&#39;test&#39;)</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">class Person {</span></span>
<span class="line"><span style="color:#A6ACCD;">    stringKey () {</span></span>
<span class="line"><span style="color:#A6ACCD;">        console.log(&#39;stringKey&#39;)</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">    [symbolKey] () {</span></span>
<span class="line"><span style="color:#A6ACCD;">        console.log(&#39;symbolKey&#39;)</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">    [&#39;calculation&#39; + &#39;1&#39;] () {</span></span>
<span class="line"><span style="color:#A6ACCD;">        console.log(&#39;calculation&#39;)</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">const a = new Person();</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">a.stringKey() // stringKey</span></span>
<span class="line"><span style="color:#A6ACCD;">a[symbolKey]() // symbolKey</span></span>
<span class="line"><span style="color:#A6ACCD;">a.calculation1() // calculation</span></span></code></pre></div><h3 id="getter-与-setter" tabindex="-1">getter 与 setter <a class="header-anchor" href="#getter-与-setter" aria-label="Permalink to &quot;getter 与 setter&quot;">​</a></h3><p>在 class 内部可以使用 get 与 set 关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">class Person {</span></span>
<span class="line"><span style="color:#A6ACCD;">    constructor (test) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        this.test = test || &#39;默认值&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">    get prop () {</span></span>
<span class="line"><span style="color:#A6ACCD;">        return this.test</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">    set prop (value) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        console.log(`setter prop value: ${value}`)</span></span>
<span class="line"><span style="color:#A6ACCD;">        this.test = value</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">const p = new Person(&#39;1&#39;)</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">p.prop // 1</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">p.prop = &#39;2&#39; // setter prop value: 2</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">p.prop // 2</span></span></code></pre></div><p>set函数和get函数是设置在属性的 Descriptor 对象上的,可以通过 Object.getOwnPrototyDescriptor 来获取指定属性的指定描述对象。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">const descriptor = Object.getOwnPropertyDescriptor(Person.prototype, &#39;prop&#39;)</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">&#39;get&#39; in descriptor // true</span></span>
<span class="line"><span style="color:#A6ACCD;">&#39;set&#39; in descriptor // true</span></span></code></pre></div><h3 id="generator-方法" tabindex="-1">Generator 方法 <a class="header-anchor" href="#generator-方法" aria-label="Permalink to &quot;Generator 方法&quot;">​</a></h3><p>如果某个方法之前加上星号（<code>*</code>），就表示该方法是一个 Generator 函数:</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">class Person {</span></span>
<span class="line"><span style="color:#A6ACCD;">  constructor(...args) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    this.args = args;</span></span>
<span class="line"><span style="color:#A6ACCD;">  }</span></span>
<span class="line"><span style="color:#A6ACCD;">  * generatorFun () {</span></span>
<span class="line"><span style="color:#A6ACCD;">    for (let arg of this.args) {</span></span>
<span class="line"><span style="color:#A6ACCD;">      yield arg;</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">  }</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">const a = new Person(1,2,3,4);</span></span>
<span class="line"><span style="color:#A6ACCD;">const generatorNext = a.generatorFun().next</span></span>
<span class="line"><span style="color:#A6ACCD;">generatorNext() // {value: 1, done: false}</span></span>
<span class="line"><span style="color:#A6ACCD;">generatorNext() // {value: 2, done: false}</span></span>
<span class="line"><span style="color:#A6ACCD;">generatorNext() // {value: 3, done: false}</span></span>
<span class="line"><span style="color:#A6ACCD;">generatorNext() // {value: 4, done: false}</span></span>
<span class="line"><span style="color:#A6ACCD;">generatorNext() // {value: undefined, done: true}</span></span></code></pre></div><h3 id="this-指向" tabindex="-1">this 指向 <a class="header-anchor" href="#this-指向" aria-label="Permalink to &quot;this 指向&quot;">​</a></h3><p>类的方法内部如果含有 <code>this</code>，它默认指向类的实例。但是某些情况是指向当前执行环境；</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">class Person {</span></span>
<span class="line"><span style="color:#A6ACCD;">    constructor () {</span></span>
<span class="line"><span style="color:#A6ACCD;">        this.text = &#39;1&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">    getText () {</span></span>
<span class="line"><span style="color:#A6ACCD;">        console.log(this.text)</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">const a = new Person()</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">a.getText() // 1</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">const {getText} = a</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// this 指向为undefined class 默认严格模式</span></span>
<span class="line"><span style="color:#A6ACCD;">getText() // TypeError: Cannot read properties of undefined (reading &#39;text&#39;)</span></span></code></pre></div><p>上面找不到 this 问题，<code>this</code>会指向该方法运行时所在的环境，因为 class 内部是严格模式，所以 this 实际指向的是 <code>undefined</code>。有两个方法解决当前问题：</p><p>第一、构造方法中绑定 <code>this</code>:</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">class Person {</span></span>
<span class="line"><span style="color:#A6ACCD;">    constructor() {</span></span>
<span class="line"><span style="color:#A6ACCD;">        this.text = &#39;1&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">        this.getText = this.getText.bind(this)</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">    getText () {</span></span>
<span class="line"><span style="color:#A6ACCD;">        console.log(this.text)</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span></code></pre></div><p>第二、使用箭头函数:</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">class Person {</span></span>
<span class="line"><span style="color:#A6ACCD;">    constructor() {</span></span>
<span class="line"><span style="color:#A6ACCD;">        this.text = &#39;1&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">    getText = () =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">        console.log(this.text)</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span></code></pre></div><p>箭头函数内部的 <code>this</code>总是指向定义时所在的对象。</p><p>第三、使用proxy 在获取方法的时候自动绑定this:</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">function classProxy (target) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    const map = new Map()</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span></span>
<span class="line"><span style="color:#A6ACCD;">    // 读取拦截配置, 只需要配置 get</span></span>
<span class="line"><span style="color:#A6ACCD;">    const hanlder = {</span></span>
<span class="line"><span style="color:#A6ACCD;">        get(target, key) {</span></span>
<span class="line"><span style="color:#A6ACCD;">            const val = Reflect.get(target, key)</span></span>
<span class="line"><span style="color:#A6ACCD;">            // 要获取的是函数执行, 如果不是函数就直接返回 val</span></span>
<span class="line"><span style="color:#A6ACCD;">            if (typeof val !== &#39;function&#39;) return val</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">            if (!map.has(val)) {</span></span>
<span class="line"><span style="color:#A6ACCD;">                // 使用 bind改变运行函数的 this为拦截的实例对象</span></span>
<span class="line"><span style="color:#A6ACCD;">                map.set(val, val.bind(target))</span></span>
<span class="line"><span style="color:#A6ACCD;">            }</span></span>
<span class="line"><span style="color:#A6ACCD;">            return map.get(val)</span></span>
<span class="line"><span style="color:#A6ACCD;">        }</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">    const proxy = new Proxy(target, hanlder)</span></span>
<span class="line"><span style="color:#A6ACCD;">    return proxy</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">class Person {</span></span>
<span class="line"><span style="color:#A6ACCD;">    constructor (text) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        this.text = text</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">    getText () {</span></span>
<span class="line"><span style="color:#A6ACCD;">        console.log(this.text)</span></span>
<span class="line"><span style="color:#A6ACCD;">        return this.text</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">const person = classProxy(new Person(&#39;test&#39;))</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">const { getText } = person</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">getText() // test</span></span></code></pre></div><h2 id="四、静态方法、静态属性及静态代码块" tabindex="-1">四、静态方法、静态属性及静态代码块 <a class="header-anchor" href="#四、静态方法、静态属性及静态代码块" aria-label="Permalink to &quot;四、静态方法、静态属性及静态代码块&quot;">​</a></h2><p>静态方法、静态属性及静态代码块(<a href="https://github.com/tc39/proposal-class-static-block" target="_blank" rel="noreferrer">proposal-class-static-block</a>)都是使用 <code>static</code>关键字定义的属性、方法或块只能 class 自己用，不能通过实例继承。</p><p>静态方法中的this 指向的是 当前类，而不是指向实例对象。静态属性是当前类自身的属性。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">class Person {</span></span>
<span class="line"><span style="color:#A6ACCD;">    static staticProp = &#39;Person静态属性&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">    constructor () {</span></span>
<span class="line"><span style="color:#A6ACCD;">        // 通过 类名 获取</span></span>
<span class="line"><span style="color:#A6ACCD;">        console.log(`output: ${Person.staticProp}`)</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">        // 也可以通过 构造函数的属性</span></span>
<span class="line"><span style="color:#A6ACCD;">        this.constructor.staticFun1()</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">    static staticFun1 () {</span></span>
<span class="line"><span style="color:#A6ACCD;">        this.staticFun2()</span></span>
<span class="line"><span style="color:#A6ACCD;">        console.log(`output: 静态方法staticFun1,获取Person静态属性 ==&gt; ${Person.staticProp}`)</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">    static staticFun2 () {</span></span>
<span class="line"><span style="color:#A6ACCD;">        console.log(`output: 静态方法staticFun2,获取静态属性 ==&gt; ${this.staticProp}`)</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">Person.staticProp // 静态属性</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">Person.staticFun1() </span></span>
<span class="line"><span style="color:#A6ACCD;">// output: 静态方法staticFun2,获取静态属性 Person静态属性</span></span>
<span class="line"><span style="color:#A6ACCD;">// output: 静态方法staticFun1,获取Person静态属性 ==&gt; Person静态属性</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">const a = new Person() // output: Person静态属性</span></span>
<span class="line"><span style="color:#A6ACCD;">a.staticProp // undefined</span></span>
<span class="line"><span style="color:#A6ACCD;">a.staticFun1 // undefined</span></span>
<span class="line"><span style="color:#A6ACCD;">a.staticFun2 // undefined</span></span>
<span class="line"><span style="color:#A6ACCD;">// 通过其原型构造函数还是能获取到 这些静态属性及方法 不推荐使用</span></span>
<span class="line"><span style="color:#A6ACCD;">// a.__proto__.constructor.staticProp</span></span>
<span class="line"><span style="color:#A6ACCD;">// a.__proto__.constructor.staticFun1()</span></span></code></pre></div><h3 id="静态代码块" tabindex="-1">静态代码块： <a class="header-anchor" href="#静态代码块" aria-label="Permalink to &quot;静态代码块：&quot;">​</a></h3><p>是在 Class 内创建了一个块状作用域，这个作用域内拥有访问 Class 内部私有变量的特权，在这个代码块内部，可以通过 <code>this</code> 访问 Class 所有成员变量，包括 <code>#</code> 私有变量，且这个块状作用域仅在引擎调用时初始化执行一次 ，决解以前初始化静态类属性需要设置一个静态变量初始化逻辑。</p><p>注意： <code>static</code> 变量或代码块都按顺序执行，父类优先执行，一个类中允许多个静态代码块存在。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">class Person {</span></span>
<span class="line"><span style="color:#A6ACCD;">    static staticProp = &#39;静态属性&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">    static staticPropArr = []</span></span>
<span class="line"><span style="color:#A6ACCD;">    static staticPropObj = {}</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span></span>
<span class="line"><span style="color:#A6ACCD;">    static getStatic (name) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        console.log(`获取：${name}`, name &amp;&amp; this[name])</span></span>
<span class="line"><span style="color:#A6ACCD;">        return name &amp;&amp; this[name]</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">    static resetData (name, data) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        name &amp;&amp; (this[name] = data)</span></span>
<span class="line"><span style="color:#A6ACCD;">        console.log(`重置：${name}`, name &amp;&amp; this[name])</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">    static {</span></span>
<span class="line"><span style="color:#A6ACCD;">        console.log(&#39;静态代码块执行&#39;);</span></span>
<span class="line"><span style="color:#A6ACCD;">        this.getStatic(&#39;staticProp&#39;);</span></span>
<span class="line"><span style="color:#A6ACCD;">        this.getStatic(&#39;staticPropArr&#39;);</span></span>
<span class="line"><span style="color:#A6ACCD;">        this.getStatic(&#39;staticPropObj&#39;);</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">        this.resetData(&#39;staticProp&#39;, &#39;重置静态属性&#39;);</span></span>
<span class="line"><span style="color:#A6ACCD;">        this.resetData(&#39;staticPropArr&#39;, [&#39;重置静态数组&#39;]);</span></span>
<span class="line"><span style="color:#A6ACCD;">        this.resetData(&#39;staticPropObj&#39;, { text: &#39;重置静态对象&#39; });</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">        this.staticPropObj.staticBlock1 = &#39;代码块中直接设置&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">        console.log(this.staticPropObj)</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">/**</span></span>
<span class="line"><span style="color:#A6ACCD;">* 静态代码块执行</span></span>
<span class="line"><span style="color:#A6ACCD;">  获取：staticProp 静态属性</span></span>
<span class="line"><span style="color:#A6ACCD;">  获取：staticPropArr []</span></span>
<span class="line"><span style="color:#A6ACCD;">  获取：staticPropObj {}</span></span>
<span class="line"><span style="color:#A6ACCD;">  重置：staticProp 重置静态属性</span></span>
<span class="line"><span style="color:#A6ACCD;">  重置：staticPropArr [&#39;重置静态数组&#39;]</span></span>
<span class="line"><span style="color:#A6ACCD;">  重置：staticPropObj {text: &#39;重置静态对象&#39;}</span></span>
<span class="line"><span style="color:#A6ACCD;">  {text: &#39;重置静态对象&#39;, staticBlock1: &#39;代码块中直接设置&#39;}</span></span>
<span class="line"><span style="color:#A6ACCD;">*/</span></span></code></pre></div><p>上面代码中可以看出，<code>static</code> 关键字后面不跟变量，而是直接跟一个代码块，就是 class static block 语法的特征，在这个代码块内部，可以通过 <code>this</code> 访问 Class 所有成员变量，包括 <code>#</code> 私有变量。</p><p>在这里提前使用一下私有变量，理论上 class 私有变量外部是访问不了的，但是有了静态代码块( *<em><strong><a href="https://link.zhihu.com/?target=https%3A//github.com/tc39/proposal-class-static-block" target="_blank" rel="noreferrer">class-static-block</a></strong></em> *)之后，我们可以将私有属性暴露给外部变量：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">let privateValue</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">export class Person {</span></span>
<span class="line"><span style="color:#A6ACCD;">  #value</span></span>
<span class="line"><span style="color:#A6ACCD;">  constructor(x) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    this.#value = x</span></span>
<span class="line"><span style="color:#A6ACCD;">  }</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">  static {</span></span>
<span class="line"><span style="color:#A6ACCD;">    privateValue = (obj) =&gt; obj.#x;</span></span>
<span class="line"><span style="color:#A6ACCD;">  }</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">export function getPrivateValue (obj) {</span></span>
<span class="line"><span style="color:#A6ACCD;">  return privateValue(obj)</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// 在另一个文件中 </span></span>
<span class="line"><span style="color:#A6ACCD;">import { Person, getPrivateValue } from &#39;xxx&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">const a = new Person(&#39;私有变量&#39;)</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">getPrivateValue(a) // 私有变量</span></span></code></pre></div><p>其实class-static-block本质上并没有增加新功能，我们完全可以用普通静态变量代替，只是写起来很不自然，所以这个特性可以理解为对缺陷的补充，或者是语法完善，个人认为现在越来越像java。</p><h2 id="五、私有属性和私有方法" tabindex="-1">五、私有属性和私有方法 <a class="header-anchor" href="#五、私有属性和私有方法" aria-label="Permalink to &quot;五、私有属性和私有方法&quot;">​</a></h2><p>私有属性和私有方法，是只能在类的内部访问的方法和属性，外部不能访问，不可以直接通过 Class 实例来引用，其定义方式只需要在方法或属性前面添加 <code>#</code>。</p><p>私有属性：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">class Person {</span></span>
<span class="line"><span style="color:#A6ACCD;">    #privateVar1;</span></span>
<span class="line"><span style="color:#A6ACCD;">    #privateVar2 = &#39;默认值&#39;;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span></span>
<span class="line"><span style="color:#A6ACCD;">    constructor (text) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        this.#privateVar1 = text || &#39;--&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">        console.log(this.#privateVar1)</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">    getPrivateData1 (key) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        // 这里是获取不了的</span></span>
<span class="line"><span style="color:#A6ACCD;">        console.log(&#39;传入key来获取私有变量：&#39;, this[key])</span></span>
<span class="line"><span style="color:#A6ACCD;">        console.log(&#39;获取私有变量&#39;, this.#privateVar2, this.#privateVar1)</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">    static staticGetPrivateData (person, key) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        console.log(&#39;静态方法获取私有变量：&#39;, person.#privateVar2, person.#privateVar1)                   </span></span>
<span class="line"><span style="color:#A6ACCD;">        // 下面是获取不到</span></span>
<span class="line"><span style="color:#A6ACCD;">        console.log(&#39;静态方法传入key来获取私有变量：&#39;, person[key]) </span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">const a = new Person() // 不传 默认 --</span></span>
<span class="line"><span style="color:#A6ACCD;">// output: --</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">a.getPrivateData1(&#39;#privateVar1&#39;)</span></span>
<span class="line"><span style="color:#A6ACCD;">// output: 传入key来获取私有变量：undefined</span></span>
<span class="line"><span style="color:#A6ACCD;">// output: 获取私有变量：  默认值  --</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// 使用静态方法</span></span>
<span class="line"><span style="color:#A6ACCD;">Person.staticGetPrivateData(a, &#39;#privateVar1&#39;)</span></span>
<span class="line"><span style="color:#A6ACCD;">// output: 静态方法获取私有变量：  默认值  --</span></span>
<span class="line"><span style="color:#A6ACCD;">// output: 静态方法传入key来获取私有变量：undefined</span></span></code></pre></div><p>从上面代码中我们可以看到，私有变量是只能内部读取或写入，不能通过动态key读取（外部调用就会报错）</p><p>注意：在class 中 公共属性 test 与 #test 是两个完全不同的值；</p><p>私有方法：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">class Person {</span></span>
<span class="line"><span style="color:#A6ACCD;">    #private;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span></span>
<span class="line"><span style="color:#A6ACCD;">    constructor () {</span></span>
<span class="line"><span style="color:#A6ACCD;">        this.#private = &#39;私有变量&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">        this.#methods() // 调用私有方法</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">    #methods () {</span></span>
<span class="line"><span style="color:#A6ACCD;">        console.log(&#39;私有方法#methods:&#39;, this.#private)</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">    static #staticMethods (person) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        if (person) {</span></span>
<span class="line"><span style="color:#A6ACCD;">            console.log(&#39;静态私有方法#staticMethods person获取值&#39;, person.#private)</span></span>
<span class="line"><span style="color:#A6ACCD;">            person.#methods()</span></span>
<span class="line"><span style="color:#A6ACCD;">        }</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">    init1 () {</span></span>
<span class="line"><span style="color:#A6ACCD;">        this.#methods()</span></span>
<span class="line"><span style="color:#A6ACCD;">        console.log(&#39;使用this&#39;)</span></span>
<span class="line"><span style="color:#A6ACCD;">        Person.#staticMethods(this)</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">    init2 (person) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        if (person) {</span></span>
<span class="line"><span style="color:#A6ACCD;">            console.log(&#39;使用传入实例&#39;)</span></span>
<span class="line"><span style="color:#A6ACCD;">            Person.#staticMethods(person)</span></span>
<span class="line"><span style="color:#A6ACCD;">        }</span></span>
<span class="line"><span style="color:#A6ACCD;">     </span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">const a = new Person()</span></span>
<span class="line"><span style="color:#A6ACCD;">// output: 私有方法#methods: 私有变量</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// a.#methods()  SyntaxError</span></span>
<span class="line"><span style="color:#A6ACCD;">// a[&#39;#methods&#39;]()  TypeError: a.#methods is not a function</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">a.init1()</span></span>
<span class="line"><span style="color:#A6ACCD;">// output: 私有方法#methods: 私有变量</span></span>
<span class="line"><span style="color:#A6ACCD;">// output: 使用this</span></span>
<span class="line"><span style="color:#A6ACCD;">// output: 静态私有方法#staticMethods person获取值 私有变量</span></span>
<span class="line"><span style="color:#A6ACCD;">// output: 私有方法#methods: 私有变量</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">a.init2(a)</span></span>
<span class="line"><span style="color:#A6ACCD;">// output: 使用传入实例</span></span>
<span class="line"><span style="color:#A6ACCD;">// output: 静态私有方法#staticMethods person获取值 私有变量</span></span>
<span class="line"><span style="color:#A6ACCD;">// output: 私有方法#methods: 私有变量</span></span></code></pre></div><p>从上面代码中我们可以看到，私有方法只能内部调用，在外部调用就会报错。</p><h2 id="六、继承-extends" tabindex="-1">六、继承 extends <a class="header-anchor" href="#六、继承-extends" aria-label="Permalink to &quot;六、继承 extends&quot;">​</a></h2><p>使用 extends 关键字，让子类继承父类的属性和方法。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">class Person {</span></span>
<span class="line"><span style="color:#A6ACCD;">    num = 1</span></span>
<span class="line"><span style="color:#A6ACCD;">    text = &#39;person&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">    getNum = () =&gt; console.log(this.num, this)</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">    addNum () {</span></span>
<span class="line"><span style="color:#A6ACCD;">        console.log(++this.num, this)</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// 继承</span></span>
<span class="line"><span style="color:#A6ACCD;">class Child extends Person {</span></span>
<span class="line"><span style="color:#A6ACCD;">    constructor () {</span></span>
<span class="line"><span style="color:#A6ACCD;">        super()</span></span>
<span class="line"><span style="color:#A6ACCD;">        this.getText()</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">    getText = () =&gt; console.log(this.text, this)</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">const a = new Child() // output: person  Child {}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(a instanceof Child) // output: true</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(a instanceof Person) // output: true</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">a.getText() // output: person Child {}</span></span>
<span class="line"><span style="color:#A6ACCD;">a.getNum() // output: 1 Child {}</span></span>
<span class="line"><span style="color:#A6ACCD;">a.addNum() // output: 2 Child {}</span></span>
<span class="line"><span style="color:#A6ACCD;">a.getNum() // output: 2 Child {}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">a.text // person</span></span>
<span class="line"><span style="color:#A6ACCD;">a.num // 2</span></span></code></pre></div><p>从上面代码中，我们可以看出Child 类 继承了 Person 的属性及方法，在Child 中也是可以调用Person的方法及属性，注意 this 的值会反映调用相应方法的实例或者类。子类中（Child）如果设置了 constructor 方法 就必须调用 super() ，否则就会出现新建实例时报错，如果没有 constructor 构造函数，在实例化继承类时会调用 super() ，而且会传入所有传给继承类的参数（后面会详细讲解）。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">class Person {</span></span>
<span class="line"><span style="color:#A6ACCD;">    static staticText = &#39;staticText&#39;;</span></span>
<span class="line"><span style="color:#A6ACCD;">    #private = &#39;private&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">    static staticMethods1 (person) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        console.log(&#39;staticMethods1&#39;, this)</span></span>
<span class="line"><span style="color:#A6ACCD;">        person.#privateMethods()</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">    #privateMethods () {</span></span>
<span class="line"><span style="color:#A6ACCD;">        console.log(&#39;#privateMethods&#39;, this)</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// 使用表达式格式 也是可以使用 extends 继承</span></span>
<span class="line"><span style="color:#A6ACCD;">const Child = class extends Person {</span></span>
<span class="line"><span style="color:#A6ACCD;">    methods () {</span></span>
<span class="line"><span style="color:#A6ACCD;">        console.log(&#39;methods&#39;, Child.staticText)</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">const a = new Child()</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">a.methods() // output: methods staticText</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">Child.staticMethods1(a)</span></span>
<span class="line"><span style="color:#A6ACCD;">// output: staticMethods1  class Child {}</span></span>
<span class="line"><span style="color:#A6ACCD;">// output: #privateMethods Child {}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">Person.staticMethods1(a)</span></span>
<span class="line"><span style="color:#A6ACCD;">// output: staticMethods1  class Person {}</span></span>
<span class="line"><span style="color:#A6ACCD;">// output: #privateMethods Child {}</span></span></code></pre></div><p>使用表达式格式 也是可以使用 extends 继承，类 的静态方法与属性是可以继承的，其私有属性及方法是不能继承的，可以从继承的共有方法与静态方法 中获取其私有属性或调用其私有方法。</p><p><strong>super</strong> 关键字可以作函数使用，也可以作对象使用，但是其只能在继承类中使用，且只能在继承类的constructor 构造函数、实例方法和静态方法中使用。作为函数时是在 继承类的constructor 构造函数中使用，根据要求如果继承类中定义了constructor构造函数就必须要调用super方法(调用父类的constructor)，否则就会报错。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">class Person {}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">class Child extends Person {</span></span>
<span class="line"><span style="color:#A6ACCD;">    constructor () {</span></span>
<span class="line"><span style="color:#A6ACCD;">        // 如果不调用 super() 就会报错</span></span>
<span class="line"><span style="color:#A6ACCD;">        // ReferenceError: Must call super constructor in derived class before accessing &#39;this&#39; or returning from derived constructor  </span></span>
<span class="line"><span style="color:#A6ACCD;">        super() // 调用父级的constructor</span></span>
<span class="line"><span style="color:#A6ACCD;">        console.log(this) // Child {}  </span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span></code></pre></div><p>注意： constructor() 中必须super() 顶部首段执行代码，否则也是一样报错；</p><p>在使用 super() 时应该注意下面几个问题：</p><ol><li><p>super只能在继承类构造函数和静态方法中使用。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">class Person {</span></span>
<span class="line"><span style="color:#A6ACCD;">    constructor () { </span></span>
<span class="line"><span style="color:#A6ACCD;">        // 在非继承类 的constructor 中使用super 会报错</span></span>
<span class="line"><span style="color:#A6ACCD;">        super() //  SyntaxError: &#39;super&#39; keyword unexpected here</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">    methods () {</span></span>
<span class="line"><span style="color:#A6ACCD;">        console.log(super.text) // undefined</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">    static staticMethods () {</span></span>
<span class="line"><span style="color:#A6ACCD;">        console.log(super.text) // undefined</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span></code></pre></div></li><li><p>不能单独引用super关键字，要么用它调用构造函数，要么用它引用静态方法。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">class Person {}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">class Child extends Person {</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">    constructor () {</span></span>
<span class="line"><span style="color:#A6ACCD;">        super // SyntaxError: &#39;super&#39; keyword unexpected here</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">    methods () {</span></span>
<span class="line"><span style="color:#A6ACCD;">        console.log(super) // SyntaxError: &#39;super&#39; keyword unexpected here</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">    static staticMethods () {</span></span>
<span class="line"><span style="color:#A6ACCD;">        console.log(super) // SyntaxError: &#39;super&#39; keyword unexpected here</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span></code></pre></div></li><li><p>调用super()会调用父类构造函数，并将返回的实例赋值给this</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">class Person {}</span></span>
<span class="line"><span style="color:#A6ACCD;">class Child extends Person {</span></span>
<span class="line"><span style="color:#A6ACCD;">    constructor () {</span></span>
<span class="line"><span style="color:#A6ACCD;">        super()</span></span>
<span class="line"><span style="color:#A6ACCD;">        console.log(this instanceof Person) // output: true</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">new Child()</span></span></code></pre></div></li><li><p>super() 的行为如同调用构造函数，如果需要给父类构造函数传参，则需要手动传入。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">class Person {</span></span>
<span class="line"><span style="color:#A6ACCD;">    constructor (text) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        this.text = text</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">class Child extends Person {</span></span>
<span class="line"><span style="color:#A6ACCD;">    constructor (text) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        super(text)</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// 这里注意 其text 会设置到Child 中</span></span>
<span class="line"><span style="color:#A6ACCD;">const a = new Child(&#39;设置 text&#39;) // Child { text: &#39;设置 text&#39; }</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(a.text) // output: 设置 text</span></span></code></pre></div></li><li><p>如果没有定义类构造函数，在实例化继承类时会调用super()，而且会传入所有传给继承类的参数。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">class Person {</span></span>
<span class="line"><span style="color:#A6ACCD;">    constructor (text) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        this.text = text</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">class Child extends Person {}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">const a = new Child(&#39;设置 text&#39;); // Child { text: &#39;设置 text&#39; }</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// 上面提到过 会默认 生成 constructor (...arge) {super(...arge)}</span></span></code></pre></div></li><li><p>在类构造函数中，不能在调用super()之前引用this，文章上面已经有案例及说明。</p></li><li><p>如果在继承类中显式定义了构造函数，则要么必须在其中调用super()，要么必须在其中返回一个对象。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">class Person {</span></span>
<span class="line"><span style="color:#A6ACCD;">    methods () {}</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">class Child1 extends Person {}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">class Child2 extends Person {</span></span>
<span class="line"><span style="color:#A6ACCD;">    constructor () {</span></span>
<span class="line"><span style="color:#A6ACCD;">        super()</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">class Child3 extends Person {</span></span>
<span class="line"><span style="color:#A6ACCD;">    constructor () {</span></span>
<span class="line"><span style="color:#A6ACCD;">        return {}</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">const a = new Child1() // Child1 {}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">const b = new Child2() // Child2 {}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">const c = new Child3() // {} 指向 实例函数 返回的对象</span></span></code></pre></div><p>关于JS Class 相关就介绍到这里，当然还有 Class的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes#mix-ins_%E6%B7%B7%E5%85%A5" target="_blank" rel="noreferrer">mix-ins</a> 混入及其他class相关知识，这边就不详细介绍了，有兴趣的同学可以自己去了解一下。</p><p>文章内容参考了 <a href="https://book.douban.com/subject/35175321/" target="_blank" rel="noreferrer">《JavaScript高级程序设计》(第4版) https://book.douban.com/subject/35175321/</a></p></li></ol></div></div></main><footer class="VPDocFooter" data-v-c4b0d3cf data-v-face870a><!--[--><!--]--><!----><div class="prev-next" data-v-face870a><div class="pager" data-v-face870a><a class="pager-link prev" href="/personalBlogs/blogs/Promise.all.html" data-v-face870a><span class="desc" data-v-face870a>←上一篇</span><span class="title" data-v-face870a>Promise.all</span></a></div><div class="has-prev pager" data-v-face870a><a class="pager-link next" href="/personalBlogs/blogs/%E6%9C%89%E4%BA%86for%E5%BE%AA%E7%8E%AF%20%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81forEach%EF%BC%9F.html" data-v-face870a><span class="desc" data-v-face870a>下一篇→</span><span class="title" data-v-face870a>有了for循环 为什么还要forEach？</span></a></div></div></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter has-sidebar" data-v-b2cf3e0b data-v-2f86ebd2><div class="container" data-v-2f86ebd2><!----><p class="copyright" data-v-2f86ebd2>Copyright © 2023 JIANG</p></div></footer><!--[--><!--]--></div></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"blogs_关于three.js渲染器three.webglrenderer()参数的介绍和使用.md\":\"d9af0403\",\"blogs_new set()的基础用法(es6).md\":\"7acbea17\",\"index.md\":\"c36bb269\",\"blogs_threejs实现简单全景看房demo😜.md\":\"8b4f1ac4\",\"blogs_tween.js 中文使用指南.md\":\"835f0b0d\",\"blogs_有了for循环 为什么还要foreach？.md\":\"9dd1d08b\",\"blogs_map对象详解.md\":\"3fef813d\",\"blogs_初始化模型视角.md\":\"7e8bb4e5\",\"blogs_使用 vue-router，页面加载完成后，_route 的值不正确.md\":\"7cfa5e05\",\"blogs_es6 module 模块.md\":\"3c47d71b\",\"blogs_javascript class类详解.md\":\"5b5afbc3\",\"blogs_查询场景中模型数据.md\":\"d659c061\",\"blogs_vue中的v-slot详解，作用域插槽和具名插槽.md\":\"9ed78544\",\"blogs_递归查询name.md\":\"83fb1471\",\"blogs_大屏适配方案汇总.md\":\"08819943\",\"blogs_index.md\":\"cd9b4dd0\",\"blogs_开发规范初版.md\":\"3f538129\",\"blogs_git协同开发.md\":\"be0b65b3\",\"blogs_前端异步(async)解决方案(所有方案).md\":\"c08f3f4e\",\"blogs_创建文本标签.md\":\"347c44c2\",\"blogs_vue组件中name的三大作用.md\":\"94b1760a\",\"blogs_浏览器的垃圾回收机制.md\":\"beff4284\",\"blogs_封装websocket方法.md\":\"3b820615\",\"blogs_js中reduce的用法.md\":\"6614fd96\",\"blogs_模型定位聚焦.md\":\"db61e41d\",\"blogs_异步并发生成标签.md\":\"2ccf6358\",\"blogs_通过three.path生成流动的箭头实现光路效果.md\":\"0959eaf8\",\"blogs_通过传入参数生成直线_曲线的路径.md\":\"1ab13c17\",\"blogs_more.md\":\"9a2706e7\",\"blogs_模型点击高亮效果.md\":\"df6368e5\",\"blogs_nprogress是什么.md\":\"e562c118\",\"blogs_promise.all.md\":\"594ffea2\"}")
__VP_SITE_DATA__ = JSON.parse("{\"lang\":\"zh-CN\",\"dir\":\"ltr\",\"title\":\"小江的网站\",\"description\":\"个人博客网\",\"base\":\"/personalBlogs/\",\"head\":[],\"appearance\":true,\"themeConfig\":{\"logo\":\"logo.png\",\"siteTitle\":\"小江的网站\",\"smoothScroll\":true,\"socialLinks\":[],\"nav\":[{\"text\":\"我的博客\",\"link\":\"/blogs/\"}],\"sidebar\":{\"/blogs/\":[{\"text\":\"博客目录\",\"collapsible\":true,\"items\":[{\"text\":\"概述\",\"link\":\"/blogs/\"},{\"text\":\"递归查询name\",\"link\":\"/blogs/递归查询name\"},{\"text\":\"查询场景中模型数据\",\"link\":\"/blogs/查询场景中模型数据\"},{\"text\":\"初始化模型视角\",\"link\":\"/blogs/初始化模型视角\"},{\"text\":\"模型点击高亮效果\",\"link\":\"/blogs/模型点击高亮效果\"},{\"text\":\"模型定位聚焦\",\"link\":\"/blogs/模型定位聚焦\"},{\"text\":\"通过传入参数生成直线\",\"link\":\"/blogs/通过传入参数生成直线+曲线的路径\"},{\"text\":\"通过three.path生成流动的箭头实现光路效果\",\"link\":\"/blogs/通过three.path生成流动的箭头实现光路效果\"},{\"text\":\"异步并发生成标签\",\"link\":\"/blogs/异步并发生成标签\"},{\"text\":\"git协同开发\",\"link\":\"/blogs/git协同开发\"},{\"text\":\"Map对象详解\",\"link\":\"/blogs/Map对象详解\"},{\"text\":\"Vue中的v-slot详解，作用域插槽和具名插槽\",\"link\":\"/blogs/Vue中的v-slot详解，作用域插槽和具名插槽\"},{\"text\":\"NProgress是什么\",\"link\":\"/blogs/NProgress是什么\"},{\"text\":\"Vue组件中name的三大作用\",\"link\":\"/blogs/Vue组件中name的三大作用\"},{\"text\":\"使用 vue-router，页面加载完成后，$route 的值不正确\",\"link\":\"/blogs/使用 vue-router，页面加载完成后，$route 的值不正确\"},{\"text\":\"new Set()的基础用法(ES6)\",\"link\":\"/blogs/new Set()的基础用法(ES6)\"},{\"text\":\"JS中reduce的用法\",\"link\":\"/blogs/JS中reduce的用法\"},{\"text\":\"Promise.all\",\"link\":\"/blogs/Promise.all\"},{\"text\":\"JavaScript Class类详解\",\"link\":\"/blogs/JavaScript Class类详解\"},{\"text\":\"有了for循环 为什么还要forEach？\",\"link\":\"/blogs/有了for循环 为什么还要forEach？\"},{\"text\":\"tween.js 中文使用指南\",\"link\":\"/blogs/tween.js 中文使用指南\"},{\"text\":\"大屏适配方案汇总\",\"link\":\"/blogs/大屏适配方案汇总\"},{\"text\":\"创建文本标签\",\"link\":\"/blogs/创建文本标签\"},{\"text\":\"封装websocket方法\",\"link\":\"/blogs/封装websocket方法\"},{\"text\":\"前端异步(async)解决方案(所有方案)\",\"link\":\"/blogs/前端异步(async)解决方案(所有方案)\"},{\"text\":\"关于three.js渲染器THREE.WebGLRenderer()参数的介绍和使用\",\"link\":\"/blogs/关于three.js渲染器THREE.WebGLRenderer()参数的介绍和使用\"},{\"text\":\"threejs实现简单全景看房demo😜\",\"link\":\"/blogs/threejs实现简单全景看房demo😜\"},{\"text\":\"更多\",\"link\":\"/blogs/more\"}]}]},\"outline\":\"deep\",\"outlineTitle\":\"章节导航\",\"docFooter\":{\"prev\":\"←上一篇\",\"next\":\"下一篇→\"},\"lastUpdatedText\":\"上次更新时间\",\"footer\":{\"message\":\"\",\"copyright\":\"Copyright © 2023 JIANG\"}},\"locales\":{},\"scrollOffset\":90,\"cleanUrls\":false}")</script>
    
  </body>
</html>